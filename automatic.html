<html>

<head>

<style>
#message { 
    position: absolute;
    top: 0;
    left: 0;
    background: black;
    color: black;
    transition: color 2s linear 2s;
}
#message:empty {
    background: black;
    color: white;
    content: '  --  #' attr(id) ' haha!';
    transition: none;
}

body, table, tr, td, th {
  overflow: auto;
  background-color: black;
  color: navajowhite;
  font-weight: bold;
  font-size: 3rem;
  height: 100%;
  padding-bottom: 0.5em;
}

table, tr, td, th {
    text-align: center;
}

/*table { display: flex; flex-wrap: wrap; width: 100%; max-width: 100%; }
td { box-sizing: border-box; flex-grow: 1; width: 100%; padding: 0.3rem; over-flow: hidden; font-size: 1vw; }
*/
table { width: 100%; }
tr {width: 100%; }
td {font-size: 0.9vw; flex-grow: 1; }

h1 { font-size: 1em; text-align: right; }
button {
    font-size: 0.7em;
    background: black;
    border-radius: 40px;
    color: white;
    border-style: dotted;
    border-color: white;
    margin: 0.3em;
    padding: 0.5em;
}

footer { font-size: 0.5em; text-align: center; position: absolute; bottom:0; z-index:1030;}

/* pretend were having color language */

span:nth-child(4n+0) { color: tomato; }
span:nth-child(4n+1) { color: deepskyblue; }
span:nth-child(4n+2) { color: lawngreen; }
span:nth-child(4n+3) { color: gold; }

/* color of pretty code layout boxes */
.fun, .args {
    display: inline-block;
    text-align: left;
    padding: 3px;
    margin: 3px;
    border: 3px solid white;
}

.fun {
    border-color: green;
}
.args {
    border-color: red;
    position: relative;
    top: 0px;
    margin-left: 1em;

}

</style>

</head>

<script>
  aaa = '0';
  function dom(id, optData, opt, optStyle) {
      let d = (typeof id == 'string') ?
	  document.getElementById(id) : id;
      if (!d) alert('dom(): no such dom id='+id);
      if (optData === undefined) return d;
      let prefix = '';
      if (dom.log || opt && opt.indexOf('l') >= 0) {
	  //prefix += new Date().toISOString();
	  // TODO: want ms?
	  prefix += new Date().toTimeString().substring(0, 8);
      }
      if (prefix != '') prefix += ': ';
  
      let w = d;
      let append = opt && opt.indexOf('a') >= 0;
      let prepend = opt && opt.indexOf('p') >= 0;
      if (append || prepend) {
	  w = document.createElement('div');
	  w.style = optStyle;
      } else if (optStyle) {
	  w.style = optStyle;
      }

      // TODO: this needs a pretty printer!
      if (opt && opt.indexOf('h') >= 0) {
	  // TODO: smaller font?
	  if (prefix == '')
	      d.appendChild(document.createTextNode(prefix));
	  w.innerHTML = optData;
      } else {
	  w.innerText = prefix+optData;
      }

      if (prepend)
	  d.insertAdjacentElement('afterbegin', w);
      if (append)
	  d.appendChild(w);

      return d;
  }
  // TODO: replace by dom
  function domT(id, ...rest){
      let d = dom(id);
      if (rest.length == 0)
	  d.innerText = '';
      else if (rest.length == 1)
	  d.innerText = '' + rest[0];
      else
	  d.innerText = rest.join(' ');
//	  d.innerText = d.innerText + JSON.stringify(rest);
      // TODO: add better pretty printer
      // especially for special objects
      // like: event, error, dom
  }
</script>

<script>
  function hardspaces(code) {
      let whitespace = ' \f\n\r\t\v\u00A0\u2028\u2029';
      return code.replace('['+whitespace+']', '\u00A0');
  }
  function code2html(code) {
      // https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
      let whitespace = ' \f\n\r\t\v\u00A0\u2028\u2029',
	  openparen = '{[(',
	  closeparen = ')]}',
	  breakchars = whitespace + openparen + closeparen;

      if (!code.length) return code;
      let c = code[0], r = code.substring(1);
      if ('{[('.indexOf(c) >= 0) {
	  // find posittion after breakchar
	  let i = 1;
	  while (i < code.length &&
		 breakchars.indexOf(code[i]) < 0)
	  {
//	      console.log('ch>'+code[i]+'< code=' + code[i].charCodeAt(0));
	      i++;
	  }
	  // include any space
	  while (whitespace.indexOf(code[i]) >= 0) i++;
	  let f = code.substring(0, i);
	  let r = code.substring(i);
	  console.log('--- i='+i + 'f>'+f + '< r>'+'<');
	  return '<span class=fun>' + f +
	      '<span class=args>' +
	      code2html(r);
      } else if ('}])'.indexOf(c) >= 0) {
	  let i = 1;
	  // include any space
	  while (whitespace.indexOf(code[i]) >= 0) i++;
	  c = '</span>' + code.substring(0, i) + '</span>'
	  r = code.substring(i);
//	  return '</span>' + c +
//	      '</span>' +
//	      code2html(r);
      } else if (c == '"') {
	  let i = 1;
	  while (i < code.length &&
		 code[i] != '"')
	      i++;
	  i++; // include the quote
	  // include any space
	  while (whitespace.indexOf(code[i]) >= 0) i++;
	  c = '<span class=fun>' + code.substring(0, i) + '</span>'
	  r = code.substring(i);
//      } else if (false) {
      } else if (true) {
	  // this cause problem: 'a b' -> 'ab', trailing white space is removed
	  let i = 1;
	  while (i < code.length &&
		 breakchars.indexOf(code[i]) < 0)
	      i++;
	  // i is now at unwanted char
	  // now points at non-white, or unwanted
	  c = '<span class=fun>' + code.substring(0, i) + '</span>'
	  r = code.substring(i);
      }
      //return '_'+c+'-' + code2html(r)
      return c + code2html(r)
  }
					 
  // basically just take all the text!
  function dom2code(idom) {
      idom = dom(idom);
      return hardspaces(idom.innerText);
  }
  
  var example_default = 'fac';
  var example_choice = 'foobar';
  var examples = {
      fac: '{fac^n (product (iota 1 n))}',
      math: '(+ 11111 (* 2222 3333 4444) (- 55555 666))',
      foobar: '(foo 3 (bar 4 3) "foobar")',
  }
  function example(name) {
      aaa += 'A';
      let code = examples[name];
      try {
	  dom('exp').innerHTML = code2html(code);
	  aaa += 'B';
      } catch(e) {
	  aaa += 'E';
	  doError(e);
      }
  }
</script>
  
<script>
  aaa += '1';
  function message(...rest) {
    if (message.clear) {
      message.clear();
      message.clear == undefined;
    }
    dom('message').innerHTML = '';
    clearTimeout(message.timer);
    message.timer = setTimeout(x=>domT('message', ...rest));
  }
  function doError(e, ...rest) {
    let s = dom('message').style;
    // reset colors next time message is called
    message.clear = _=>{
      s.backgroundColor = '';
      s.color = '';
    }
    s.backgroundColor='red';
    s.color='white';
    domT('message', 'Error: ' +e, ...rest);
  }
  aaa += '2';
  aaa += '3';
</script>

<script src='sortables.js'>
</script>

<script>
  aaa += '4';
  function doKey(e) {
    let a = e.altKey;
    let c = e.ctrlKey;
    let k = e.key;
    //message('event='+e, e, 'c='+c, 'alt='+a, 'key='+e.key);

    // some browsers don't implement
    if (c && !a && k=='r') window.location.reload();
    if (c && !a && k=='e') example();

    // save load
    if (c && a && k=='s') save();
    if (c && a && k=='l') load();

    // executing
    if (c && !a && k=='x') run();
    if (c && !a && k=='e') run('pass');
    if (c && !a && k=='s') run('step'); 
    if (c && !a && k=='t') run('ticker');
    if (c && !a && k=='c') run('break');
    if (c && !a && k=='b') run('back');
    if (c && a && k=='b') run('beginning');

    // TODO: structure editor
    // TODO: insert box for function
    if (k == '(') message('open paren');
    // TODO: skip forward to after
    if (k == ')') message('close paren');

    return false;
  }
  aaa += '5';
  // TODO: add concept of
  // user
  // - user. {
  //     fullname, email, we-blink, namespaces,
  //     default-namespace, init-namespace}
  // - user.namespace {
  //     name, functions-list}
  //     namespace should really just be
  //     a function that "includes"/set path
  // - user.namespace.function { current-def, 
  //     name, history count?, history intries
  // - user.namespace.function~000VER
  //     when a fun is updated, it's
  //     logged + add new version + update current
  // - user.namespace.log.stardate[.user]
  //     
  
  // store using window.localStorage
  // (window.sessionStorage)
  // (could stor inside webpage, load/save)

  // internal functions
  function iput(n, v) {
    return localStorage.setItem(n, v);
  }
  function iget(n) {
    return localStorage.getItem(n);
  }
  function ilist(a, b, p) {
  }

  function isearch(a, b) {
  }

  function dump() {
    let ls = localStorage;
    for(let i=0; i<ls.length; i++) {
      let k = ls.key(i);
      //console.log(`${i}\t${k}\t${ls.getItem(k)}`);
      console.log(`i=${i}\nkey=${k}<\ndata=${ls.getItem(k)}<`);
    }
  }

  var user = '';
  // 16 char hash prefix with 'h'
  var huser = 'hdeadbeefdeadbeef'; 

  function hash(s, optPrecision) {
    // TODO: use XTEA
    //throw "hash: not implemented!"
    h = 'DEADBEEFDEADBEEF';
    return 'h' + h.substr(-(optPrecision || 16));
  }
  
  // tHEX of fixed length
  function timestamp(optT) {
    if (optT === undefined) {
      optT = Date.now();
      // make sure unique (PER USER),
      // (then should add machine id...)
      // if too much data
      // means timestamp is "fake"
      // should we mark it, or add extra
      // digit? considering that most browsers
      // only give in resolution of 20-100ms
      // maybe it's ok...
      if (optT <= timestamp.last)
	optT = ++timestamp.last;
    }
    return 't' +
      (
	'0000000000000000' + optT.toString(16)
      ).substr(-16);
  }
  
  function get(n, space, tid) {
    tid = tid || timestamp();
    let hs = space ? hash(space) : huser;
    let kc = `${hs} ${n} current`;
    let kt = `${hs} ${n} timestamp`;
    let ot = iget(kt);
    let o = iget(kc);

    // if we have it, assume it's latest
    if (o) {
      return o;
    }
    // We don't know if it exists

    // check replication update authority
    // TODO: where the user got the ID from?
    // guessing?
    return `[loadget ${tid} ${hs} ${n}]`;
  }

  // [load-get TS N HSPACE]
  //   sends request and register callback
  //   [wait TS 100 3000 get-wait TS N HSPACE]
  // [wait TS MS LEFTMS FUN ARGS]
  //   checks if UUID available, if not,
  //   and not other jml evals, wait MS time.
  //   when data received call:
  //     [FUN ARGS]
  //   if error/timeout call:
  //     [FUN/error-timeout MSG ID FUN ARGS]
  //   which if not exists will call:
  //     [FUN/error CODE MSG ID FUN ARGS]
  //   or, which most likely is bad:
  //     [error FUN/error-timeout CODE MSG ID FUN ARGS]
      
  var hREPL = 'h0000000000000000'; // broadcast

  // Sync can use lastStorage.length
  // and compare, but order keeps changing
  // so need to look at keys
  // = search prefix and then sort

  // - Public Spaces
  // hUsers hUSER name: Your Name
  // hUsers hUSER address: address
  // hUsers hUSER address: address

  // - Space
  // hSPACE NAME current: VALUE
  // hSPACE NAME timestamp: nTS
  // hSPACE NAME nTS: DATA
  //   (DATA = hREST nOLDTS hUSER ... - VALUE)

  // ---- Workspace (configuration)
  // hSPACE work WORK exp: VALUE
  // hSPACE work WORK bases: WORK ...
  // hSPACE work WORK join: hSPACE1 hjsk ...
  // hSPACE work WORK join: [space SPACE1] [space jsk] ...
  // hSPACE work WORK define pet: hpeter
  // hSPACE work WORK define a: haronsson
  //   [haronsson:fac ..]
  //   [a;fac ..]

  //   [hpeter:fac ..]
  //   [pet:fac ...]p

  //   [fac ...] is either hSPACE1 hjsk ...
  //   [hSPACE:fac ...]
  //   [hSPACE1:fac ...]
  //   [hjsk:fac ...]
  
  // - Replication/Messaging
  // R hREPL tTS hSPACE NAME : DATA
  

  // -------- FORMAT:


  // -----------------EMAIL------------------
  // consider separating mail, msg, chat

  // notifications: there is no reason we could
  //   not notify about any ID! (like wiki update)
  
  // --------notify
  //  hspace hts name: hcheck hots huser - data

  // --------email

  //    FROM: hFrom
  //    DATE: ts
  //      TO: hTo
  // SUBJECT: ?
  // msg
  // >
  
  // --- use for messaging?
  //  key: hREPL tTIMESTAMP hSPACE NAME
  //         0        ts      to  'mail'
  // data: hREST nOLDTIMESTAMP hUSER ... - VALUE
  //         cs      pts       from        msg
  // send email
  //   put('mail', 'msg', 'to') user = from
  //   => means versioned messages,
  //      need to load
  //
  // How to mark read/unread?
  // could possibly use 'pts' for new version
  // but then each msg should have uniqe id
  //   mail-hFROM-sSUBJECT
  // for threading to work
  //   mail-hSUBJECT-hFROM
  // or just msgid
  //   mail-hTS-hFROM-hSUBJECT
  // groups should be their own "inbox"
  //   but means, user read data need to be
  //   stored per READER!

  // msg-tTS-hFrom
  // msg-tTS-hFrom-tTS-hFrom (a reply)
  // msg-tTS-hFrom-read

  // t15 jsk sends mail to peter
  //   hjsk: msg-t15-hjsk -> MSG
  //   hjsk: msg-t15-hjsk-status sent

  // hpeter: msg-t15-hjsk -> MSG
  // hpeter: msg-t15-hjsk-status -> unread

  // t16 peter reads
  // hpeter: msg-t15-hjsk-status -> read


  // t17 peter replies
  // hpeter: msg-t15-hjsk-status -> reply
  // hpeter: msg-t15-hjsk-status-t17-hpeter -> MSG2

  // hpeter: msg-t15-hjsk-status -> reply
  //   hjsk: msg-t15-hjsk-status-t17-hpeter -> MSG2
  //   hjsk: msg-t15-hjsk-status-t17-hpeter-status -> unread

  // t18 jsk replies
  // HMMMM?
  //   hjsk: msg-t15-hjsk-status-t17-hpeter-status -> reply
  //   hjsk: msg-t15-hjsk-status-t18-hjsk -> MSG3
  //   hjsk: msg-t15-hjsk-status-t18-hjsk-status -> sent

  // hpeter: msg-t15-hjsk-status-t18-hjsk -> MSG3
  // hpeter: msg-t15-hjsk-status-t17-hjsk-status > unread

  // doesn't able to retrieve children, only closure
  
  
  // user facing
  function put(n, v, space) {
    // TODO: begin, identical to "get"
    let tid = timestamp();
    let hs = space ? hash(space) : huser;
    let kc = `${hs} ${n} current`;
    let kt = `${hs} ${n} timestamp`;
    let ot = iget(kt);
    let o = iget(kc);
    // TODO: end "merge" by helper?


    // almost same as iget('hs n lex(ot)') after '- '
    // if not found, we don't know if it's on server
    // but it's an uninformed put meaning it's based
    // on timestamp 0 information. Works well for
    // creating unique messages.
    if (ot === null) {
      ot = timestamp(0);
    }
    
    // - create value as a ledger
    //   key: hSPACE NAME nTIMESTAMP
    let kn = `${hs} ${n} ${tid}`;
    // if it's ever extended, add BEFORE ' - '
    let d = `${ot} ${huser} - ${v}`;
    //   data: hREST nOLDTIMESTAMP hUSER ... - VALUE
    let data = `${hash(d, 8)} ${d}`;
    //    key: hREPL tTIMESTAMP hSPACE NAME
    let kr = `${hREPL} ${tid} ${hs} ${n}`;

    // update versioned store
    // TODO: make transacational/atomic/recover
    // - replication log
    iput(kr, data);
    // - local cache
    iput(kn, data);
    // - fast access current value
    iput(kc, v);
    iput(kt, t);
    return '[storeput ${tid} ${hs} ${n} ${v}]';
  }
  
  function list(a, b, p) {
  }
  function search(a, b, q) {
  }

  function save() {
    let x = dom2code('exp');
    put('exp', x);

    message('saved');
  }
  function load() {
    let x = get('exp');
    if (x != null)
      dom('exp', x, 'h');
    
    message('loaded');
  }


  document.addEventListener('visibilitychange', function doVis(e) {
      return;
      if (document.visibilityState == 'visible') {
	  // most browser focus, not opera
	  // this  still doesn't do anything
//	  dom('exp').focus();
	  load();
      } else {
	  save();
      }
  }, false);
    
</script>

<body spellcheck=false onkeydown='doKey(event);'>
<script>
  window.onerror = function(message, url, line, col, errorObj) {
    console.error(`WINDOW.ONERROR!
message  : ${message}
url      : ${url}
line     : ${line}
col      : ${col}
errorObj : ${errorObj}
`);
  }
 </script>

<!-- set some overflow so it doesn't resize window-->
<div id=message></div>
<div id=old style='color: white; position: absolute; top: 0; right: 0'>
OLD
</div>

<br/>
<button id=aaa></button>

<script>
  aaa += '6';
  tick = 0;
  function dbg() {
      tick++;
      let x;
      try  {
	  x = document.hasFocus();
      } catch(e) {
	  x = 'ERROR: ' + e;
      }
      let h = document.visibilityState;
      dom('aaa').innerHTML = '' + aaa + ', tick=' + tick + ' focus=' + x + ' vis=' + h;
//      dom("exp").focus();
  }
  aaa += '7';
  setInterval(dbg, 1000);
</script>

<h1>Automatic Lettering</h1>

<div style='width:100%; text-align:justify;'>
  <button>history</button>
  <button>list</button>
  <button>fact</button>
  <button>send</button>
  <button>download</button>
  <button>comm</button>
  <button onclick='save();'>save</button>
  <button onclick='load();'>load</button>
  <button onclick='dom("exp").innerHTML=code2html(hardspaces(dom("exp").innerText));'>prettyprint</button>
  <button onclick='dom("exp", dom2code("exp"));'>unpretty</button>
  <button onclick='example(example_choice)'>example</button>
</div>

<div id=exp contenteditable='true' style='white-space:pre; position:absolute; width:100%; height:80% disply:flex; text-align:center;'>
</div>
<!--
<span id=exp autofocus contenteditable='true' style='margin:0; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);'>
</span>
-->

<script>
  example(example_default);
</script>

<footer style='font-size:0.5em'>(c) Alienna Automatic Lettering Corporation</footer>

<script id=lastscript src='lastmodified.js'>
</script>

<script>
  // TODO: only enable in debug mode
  var lastmodified;
  setInterval(()=>{
      // delayed setup until browser ready
      if (!lastmodified
	  && typeof(getLastModified) == 'function') {
	  aaa += 'U';
	  lastmodified = getLastModified();
      }
      if (!lastmodified) return;

      let s = Date.now()/1000 - lastmodified;
	      
      // TODO: give user reload button
      let txt = Math.round(s) + 's';
      if (getLastModified() > lastmodified) {
	  let old = Date.now()/1000 - getLastModified();
	  txt = 'Outdated by ' + Math.round(old) + 's ' + txt;
      }
      domT('old', txt);
  }, 1000);

  // poll for change
  setInterval(()=>{
      let o = document.getElementById('lastscript');
      o.parentNode.removeChild(o);
      let s = document.createElement('script');
      s.id = 'lastscript';
      s.src = 'lastmodified.js?' + Date.now();
      document.body.appendChild(s);
  }, 1000);
</script>

<!-- TODO: move this up to top, but it requires, dom function, should it provide it, or an util library? -->
<script id=lastscript src='jsconsole.js'>
</script>

<script src="https://cdn.jsdelivr.net/npm/idb-keyval@3/dist/idb-keyval-iife.js">
</script>

<script>
  if (0) {
    var db=idbKeyval;
    console.log('db1');
    db.set('hello', 'world');
    console.log('db2');
// gives error:
//  db.get('hello', 'world').then(
//      val => console.log('val=', val));
    console.log('db4');
  }
</script> 

<script id='prettyprint'>
  function pprint(o, klass, depth) {
    if (!depth) depth = 0
    // these don't work??? wtf?
    switch (typeof(o)) {
    case undefined:
    case null:
    case 'undefined':
    case 'number':
    case 'boolean': return '' + o;
    case 'bigint': return '' + o + 'n';
    case 'string': return '"' + o + '"'; // TODO: quote "
    case 'symbol': {
      let s = o.toString();
      let f = Symbol.keyFor(o);
      return ':' + (f === s ? ':' : '') + s;
    }
    case 'function':
      return 'FUNC:' + o.name + '/';
      // TODO: if print props of fun then it get's circular!
      // + o.length + pprintprops(o, klass, depth+1);
    }
    // now assumed to be object

    if (o === null) return '' + o;

    if (Array.isArray(o)) {
      // TODO: make it not print num
      //      let r = pprintprops(o, klass, depth+1);
      let r = '';
      let l = o.length;
      for(let i=0; i<l; i++) {
	r += pprint(o[i], klass, depth+1) + ', ';
      }
      return r;
    }

    // TODO: arguments ... args.callee
    // TODO: date
    // TODO: regexp

    // object
    if (typeof o !== 'object') {
      console.error('ERROR: type of o is ', typeof(o), ' o=' + o);
      return;
    }
    return pprintprops(o, klass, depth+1);
  }

  function pprintprops(o, klass, depth) {
    // yeah, it's a friggin object!
    if (o === null) return 'null';

    // .prototype  .name == objtype?
    // constructor?
    // Function.getOwnProperties
    // .getProperties()

    /*
     var fooSym = Symbol('foo');
     var myObj = {};
     myObj['foo'] = 'bar';
     myObj[fooSym] = 'baz';
     Object.keys(myObj); // -> [ 'foo' ]
     Object.getOwnPropertyNames(myObj); // -> [ 'foo' ]
     Object.getOwnPropertySymbols(myObj); // -> [ Symbol(foo) ]
     assert(Object.getOwnPropertySymbols(myObj)[0] === fooSym);
     getOwnSymbols
     a  for (let x of o) ???
    */
    
    let op = Object.getOwnPropertyNames(o);
    let ra = [];
    for (let n of op) {
      let ns = n;
      if (!ns.match(/^\w+$/)) ns = quote(ns);
      ra.push(ns + ': ' + pprint(o[n], klass, depth+1));
    }
    return `{${ra.join(', ')}}`;
  }
  
  if (0) {
    console.log(pprint(3));
    console.log(pprint('foo'));
    console.log(pprint(3n));
    console.log(pprint(undefined));
    console.log(pprint(function plus(a,b){ return a+b; }));
    console.log(pprint({a: 3, b: 4}));
    console.log(pprint([3, 4]));
  }
</script>

<script src='jml.js'>
</script>

<script>
  function expEdited() {
    let d = dom('exp');
    let t = d.innerText;
    expEdited.changed = (expEdited.last !== t);
    expEdited.last = d.innerText;
    if (expEdited.changed)
      run.lastvalue = undefined;
  }
  dom('exp').onkeydown = expEdited;

  // how: normal all, 'step', 'tick', 'break', 'ticker'
  function run(how) {
    // format code
    function Formatupdate(r) {
      dom('exp').innerHTML = code2html(r);
      dom('exp').lastvalue = r;
    }

    // raw set html
    function update(r) {
      dom('exp').innerHTML = r;
      dom('exp').lastvalue = r;
      let z = new Blob(run.undo).size;
      message(`run.undo ${run.undo.length} items of ${z} bytes`);
    }

    // undo
    if (!run.undo) run.undo = [];
    if (how == 'back') {
      let r = run.undo.pop();
      // never remove first
      if (run.undo.length==0 && r)
	run.undo.push(r);
      if (!r) return;
      update(r);
      return;
    }
    if (how == 'beginning') {
      if (!run.undo.length) return;
      let r = run.undo[0];
      run.undo.length = 1;
      if (!r) return;
      update(r);
      return;
    }

    // break ^c (or any other key!)
    if (how == 'break'
	|| (how != 'tick' && run.ticker)) {
      clearInterval(run.ticker);
      run.ticker = 0;
      return;
    }
    // ticker ^t
    if (how == 'ticker') {
      run.ticker = setInterval(
	_=>run('tick'), 0);
      return;
    }

    // TODO: make a more efficient variant
    // that how='run' that only process
    // TextNodes!
    let x = dom('exp').lastvalue;

    // edited, so clear 'undo'
    if (false  && (!how || !x)) {
      expEdited.changed = false;
      run.undo = [];
      console.log('undo cleared');
    }
    
    // TODO: bad hack, because unprettyfy doe6sn't work! it looses spaces!
    if (!x) x = dom2code('exp');

    let r = jml(x, how);
    if (r === x) {
      // finished
      run('break');
    } else {
      update(r);
    }
    
    if (!run.undo.length
	|| run.undo[run.undo.length-1] !== x) {
      // TODO: avoid if too big!
      // TODO: if edited, do special save that doesn't get deleted easy
      run.undo.push(x);
      let z = new Blob(run.undo).size;
      // remove old (but not first) entries if if log too big
      while ((z > run.MAX_UNDO_BYTES ||
	      run.undo.length > run.MAX_UNDO_LEN+1)
	     && run.undo.length > 3) {
	run.undo.splice(1,2, '%UNDO:s REMOVED!%');
      }
    }
  }
  run.MAX_UNDO_BYTES = 10241024;
  run.MAX_UNDO_LEN = 1024;
</script>

<!-- anyway to see status on a script tag?-->
<!-- todo: provide a loadScript() function...-->
</body>
</html>
