<!--- https://raw.githack.com/yesco/AutomaticLettering/master/oric.html -->
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>
<script>
  // this gives syntax errors while loading
  // put this as first script
  // then at end we change to capture runtime errors
  window.onerror = (...args)=>{
    // let t = ''+args[0];
    let t = args.toString();
    let b = document.body;
    t = `<div style='background:red;''>${t}</div>`;
    b.insertAdjacentHTML('afterbegin', t);
  };
</script>

<script id='help'>
  function HELP(cmd) {
    if (cmd) {
      // extract DOC string from function!
      let f = window[cmd];
      if (f) {
	let s = f.toString();
	if (trace) print('FUN=' + f.toString());
	s = s.match(/\/\/\s*DOC\s*:?\s*([\s\S]+)/i);
	let doc;
	if (!s) {
	  doc = '- NO DOCS';
	} else {
	  s = s.join('').replace(/\n\s*[^\s\/][\s\S]*$/, '');
	  s = s.replace(/\n\s*\n[\s\S]*/, '');
	  s = ('\n'+s).replace(/\n\s*\/\/\s*/g, '\n');
	  s = s.replace(/^[\n]DOC[\s:]*/, '');
	  doc = s;
	}

	princ(cmd); TAB();

	// indent paragraph!
	let mincol = col;
	for(let i=0; i<doc.length; i++) {
	  let ch = doc.charCodeAt(i)

	  TAB(mincol);
	  if (ch == 10 & (
	    col > SCREEN_COLS-1 || col == mincol))
	    ;
	  else
	    putc(ch);

	}
	print();

	// related
	let rel = HELP.related.filter(
	  g=>g.match(RegExp(`\\b${cmd}\\b`))
	);
	if (rel.length)  {
	  print('\nRelated:');
	  rel.forEach(r=>print(r));
	}
	return;
      } else {
	print('?NO SUCH NAME');
      }
    }

    // list names!
    
    function printkeys(msg, k) {
      let num = 0;
      k.forEach(n=>{
	if (cmd && !n.match(cmd)) return;
	princ(n);TAB();
	num++;
      });
      if (num) {
	if (col > column) print();
	princ(num);
	print('WORDS ' + msg);
      }
    }

    printkeys(
      'MISSING', OKK(/(dummy|missing|impl|UNKN)/i));
    printkeys(
      'DEFINED', OKK(/(const|defined|native|innov)/i));
    //print('Usage: HELP [cmd]');

  }
  // push related words (space separated) on this!
  HELP.related = [];
</script>
<script>
  // -- Simplified testing of types and values
  function tType(t, x, err) {
    if (x === undefined) syntax_error();
    if (typeof x !== t) type_error();
    if (err) quantity_error();
    // okay
  }
  function tStr(s, err) {
    tType('string', s, err);
  }
  function tNum(n, err) {
    tType('number', n, err);
  }
  function tInt(n, err) {
    n = Math.floor(r);
    if (n > 32767 || r < - 32769)
      quantity_error()
    tType('number', n, err);
  }
  function tPos(n, err) {
    tNum(n, err || n < 0);
  }

  function error(msg, data) {
    print();
    princ(msg);
    if (data) { putc(32); princ(data); }
    if (lineno) { princ(' IN LINE'); princ(lineno); }

    stop(true);
    throw msg;
  }

  // NEW
  function run_error(name, e) {
    // TODO: print stacktrace?
    let msg = '?'+name+' BROKE: ';
    let emsg = ''+(e && e.msg || '');
    console.log(msg, emsg);
    let st = ''+e.stack;
    st = st.replace(/\(.*?\)/g, '');
    console.log(st);
    error(msg, emsg);
  }

  function subscript_error(info) {
    error("?BAD SUBSCRIPT ERROR", info);
  }

  function until_error(info) {
    error("?BAD UNTIL ERROR", info);
  }

  function disp_error(info) {
    error("?DISP MISMATCH ERROR", info);
  }

  // NEW?
  function save_error(info) {
    error("?CAN'T SAVE", info);
  }

  function syntax_error(cmd) {
    error('?SYNTAX ERROR: ', cmd);
  }

  // NEW
  function implemented_error(s) {
    error('?NOT IMPLEMENTED ERROR:', s);
  }
  
  // NEW?
  function unexpected_error(s) {
    error('?UNEXPECTED ERROR:', s);
  }

  // NEW?
  function unmatched_error(e, g) {
    error('?MATCHING ERROR, expected:' + e + ' got: ' +g);
  }

  // NEW?
  function eval_error(e) {
    error('?EVAL ERROR:', e);
  }
  
  function return_error() {
    error('?RETURN WITHOUT GOSUB ERROR');
  }
  
  function next_error() {
    error('?NEXT WITHOUT GOSUB ERROR');
  }
  
  function data_error() {
    error('?OUT OF DATA ERROR');
  }
  
  function cont_error() {
    error('?CAN\'T CONTINUE ERROR');
  }

  function quantity_error() {
    error('?ILLEGAL QUANTITY ERROR');
  }

  // 1. 7E38 -- 2.93E-39 OK!
  function overflow_error() {
    error('?OVERFLOW ERROR');
  }

  function dim_error(info) {
    error("?REDIM'D ARRAY ERROR", info);
  }

  // when calling some interactive funcs
  // like key$ and get, input
  function direct_error() {
    error('?ILLEGAL DIRECT ERROR');
  }

  function redo_error() {
    // TODO: actually not error, just message
    print('?REDO FROM START');
  }

  function string_error() {
    error('?STRING TOO LONG ERROR');
  }

  function line_error() {
    error("?UNDEF'D LINE ERROR");
  }
  
  function line_error() {
    error("?UNDEF'D FUNCTION");
  }
  
  function type_error() {
    error('?TYPE MISMATCH ERROR');
  }
  
  function div_error() {
    error('?DIVISION BY ZERO ERROR');
  }

  function complex_error() {
    error('?FORMULA TOO COMPLEX ERROR');
  }

</script>
  
<style>
/* My font! (jsk) */
@font-face {
    font-family: 'ORIC-ATMOS';
    src: url('oric-atmos-jsk.ttf');
}
@font-face {
    font-family: 'ORIC-ALT';
    src: url('oric-atmos-alt-jsk.ttf');
}

#screen {
    white-space: nowrap;

    /* todo: remove? */
    font-size: 1.5rem;

    color: white;
    background: black;

    overflow: hidden;
}

.text, .hires {
    font-size: 1em;
    //background: yellow;
    //letter-spacing: -9.3px;
    letter-spacing: -4.565px;
    line-height:12.195px;
    margin: 0;
    padding: 0;
}

.hires {
    /* change height to pixel cell... */
    //height:1px;
    //max-height:3px;
    line-height: 1px;
    //overflow:hidden;
}

/*container element*/
.text, .hires, .standard, .oric, .attr {
    font-family: 'ORIC-ATMOS', monospace;
}

/* span elements inside the container div */

  span {
      display: inline-block;
      /*height: 1px; /* haha you can try! */
  }
  
  .char {
      width: 0.30rem;
      border: 0px;
      padding: 0px;
      margin: 0px;
      //padding-right: 0.25rem;
      //padding-left: 1rem;
      max-height: 12px;
  }

  /* TODO: investigate!
  {
       font-size: 12px;
       letter-spacing: 0.015em;
       word-spacing: 0.001em;
  }
 */
  /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform */
  /* we can get double height! but only
     on each char; the problem is the nested
     elements - do it twice and it'll double
     again!

     TODO: I couldn't find a way to translate
     the it and 'clip-y' seems 'overflow-y: hidden isn't working...
 */

.alt {
    font-family: 'ORIC-ALT', monospace;
}

.normal {
    /* how to reset?/undo */
    transform: initial;
}
/* transforms 
   https://www.w3schools.com/cssref/css3_pr_transform.asp
   */
.double {
    transform:
	scale(1, 2)
        translateY(3px)
	;
    max-height: 12px;
    //overflow-y: hidden;
}
    
/* when displaying attributes...
   add this to a parent class (#screen) */

.show-attr {
    --vis-attr: visible;
}

.attr {
    font-family: 'ORIC-ATMOS';
    visibility: var(--vis-attr, hidden);
    font-weight: bold;
    /* this shows white on white! */
    filter: invert(30%);
}

/* INVERSE */
/* TODO: not correct as it only blinks specified colors? */
.inverse {
    filter: invert(100%);
    margin:0;
    padding:0;

    color: black;
    background-color: white;
    //color: white;
    //background-color: black;
}

.cursor {
    /* show attributes and cursor there */
    position: relative;
    /* this shifts the character, we want
       to move the inversion "box"
       top: -1px;
       left: 2px;
   */
    visibility: visible;

    animation: cursor_blinker 0.5s step-start infinite;
//    background-color: black;
//    color: inherit;

color: white;
background-color: black;
    /* this is confusing, it only inverts background when set! */

}

@keyframes cursor_blinker {
    50% {
	filter: invert(100%);
	background-color: inherit;
	color: white;
    }
}

/* BLINK
g
   https://stackoverflow.com/questions/16344354/how-to-make-blinking-flashing-text-with-css-3
   The best way to get a pure "100% on, 100% off" blink, like the old <blink> is like this
*/

.blink {
    animation: blinker 1s step-start infinite;
}

@keyframes blinker {
    50% {
	opacity: 0;
    }
}

#printer {
    color: blue;
    padding-left: 2rem;
    padding-right: 2rem;
    background: beige;
}

/* TODO: doesn't work on "lines"
#printer:nth-child(2n+0) {
    background: beige;
}
#printer:nth-child(2n+1) {
    color: lightskyblue;
*/
</style>
  
<script src='oric-exp.js'>
</script>

<script src='misc.js'>
</script>

<script src='sounds.js'>
</script>

</head>

<body style='background-color: black; color: white;'>
<div style='width:100%'>
  <img width='20%' src='oric-logo-black-export.svg'/>
  <div class='oric' style='float:right; top:0; width:80%; text-align:center; font-decoration:bold; text-justify:inter-word; font-size:2rem; letter-spacing:3px; '>WEB - BASIC
<sup><a tabindex='-1' class='oric' target='oricman' style='text-decoration:none; font-size:1.1rem; padding:0.1rem; padding-bottom:-0.1rem; color:black; background:white; font-weight:bold; letter-spacing:0px;' href='http://www.defence-force.org/computing/oric/library/lib_manual_oric/files/manual_atmos.pdf'>PDF</a></sup>
<div style='font-size:1rem;'>&copy;jsk@yesco.org</div>
  </div>
<span class='oric' style='position:relative; left:3px; top:-7px; letter-spacing:6px; transform-origin:left; transform:scale(1.17, 1);'><b>BASIC</b></span>
</div>

<br>

<!-- seemingly useless span, but need for getting correct width of 'screen'-->
<center><span id='foo'>
<div id='screen' class='text'>
</div>
</span></center>

<style>
.oricl, .oricr {
    background: red;
    width: 30px;
    height: 25px;
    border: 2px solid black;
    color: white;
    font-size: 15px;
    text-align: center;
    margin: auto;
    font-weight: bold;
}
.oricl {
    float: left;
}
.oricr {
    float: rigth;
}
</style>

<div style='width:100%' hidden>
  <span class='oricl'>CAPS</span>
  <span class='oricr'>ENTER</span>

  <div class='oricl'>SHIFT</div>
  <div class='oricr'>^</div>

  <div class='oricr'>CTRL</div>
  <div class='oricr'>FUNC</div>
  <div class='oricl'>&gt;</div>
  <div class='oricl'>v</div>
  <div class='oricl'>&lt;</div>
</div>



<script>
  window.onresize = function(){
    let s = dom('screen');
    
    let w = s.offsetWidth;
    let h = s.offsetHeight;

    let ww = window.outerWidth;
    let wh = window.innerHeight;

    s.style.zoom = Math.min(ww/w, wh/h);
  };
  // call an initial time after first render
  setTimeout(x=>window.onresize(), 1000);
</script>
<!-- id=exp is magical for jsconsole - it returns focus there -->
<div style='display:flex; width:100%;'>
  <input id='exp' autofocus style='flex:1; background:black; color:lightgreen; border:none; width:100; float:right;'>
</div>
<script>
  {
    let s = dom('screen').style;
    let e = dom('exp');

    // not good idea as it scrolls down...
    //dom('screen').onclick =
    //()=>e.focus();

    let sfilter;
    e.onblur = function() {
      sfilter = s.filter;
      // not working?
      s.filter = 'blur(2px)';
    }
    e.onfocus = function() {
      //s.background = '';
      s.filter = sfilter;
    }

    e.onblur();
    // can't force on opera :-(
    // and it's not default
    e.focus();
  }
  
</script>

<!---input id="file" type="file"/-->
<script>
  // inspired by https://stackoverflow.com/questions/16495125/parsing-binary-files-in-client-side-js
  // REFERENCE:
  //  https://developer.mozilla.org/en-US/docs/Web/API/FileReader
  // readAsBinaryString
  function readFile() {
    let fileInput = dom('file');
    let fReader = new FileReader();

    fReader.onload = function(e) {
      /// <-- this contains an ArrayBuffer
      console.log(e.target.result);
    }

    // onloadend
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer
    fileInput.onchange = function(e) {
      let file = this.files[0];
      fReader.readAsArrayBuffer(file);
    }
  }
</script>

<center><b style='color:beige;'>PRINTER (toggle on/off with CTRL-P)</b></center>
<pre id='printer'></pre>
<script>
  {
    let p = dom('printer');
    // select printer output on click!
    p.onclick = ()=>{
      let sel = window.getSelection();
      let range = document.createRange();
      range.selectNodeContents(p);
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }
</script>

<br>
ROW: <span id='row'></span>
COL: <span id='col'></span>
<br>
LINE: <span id='line'></span>
<br>
STATS: <span id='stats'></span>
<br>
ERROR: <span id='error' style='color:red;'></span>
<br>
VARS: <span id='vars'></span>
<br>
INFO:<br><span id='info'></span>
<br>
<br>
<script src='jsconsole.js'>
  //loadScript('jsconsole.js');
</script>
<script>
  DBG('logerr', true);
</script>

<script>
  // Configuration
  let TIMESLICE = 20; // run about X ms

  const SCREEN_COLS = 40, // ORIC: 40
	SCREEN_ROWS = 28, // ORIC: 28
	
	LastOne = 'foo';

  // Global ORIC ATMOS state
  var vars = {},
      stack = [], // [ [lno, restline] ...]
      line = '',
      lineToDo = [], // queue
      lineno = 0,
      caps = true,
      click = true,
      column = 2, // protected columns
      scoff = 0, // screen off if > 0 (count!)
      scstop = 0, // screen pause
      printer = undefined,
      double = false,
      trace = false, // debug tracing CTRL-P
      tron = false, // TRON/TROFF
      row = 1,
      col = column,
      paper = 7,
      ink = 0,

      // 0=TEXT=LORES0, 1=LORES1, -1=HIRES
      gedit = false,
      lores = 0,
      curx = 0,
      cury = 0;




  // --- slow down!
  // TODO: set if too much screen updates?
  // hack to make it slower
  // an oric does about 3000stms/s
  // for n==2 CHROMA is about 3s
  // for n==13 PRINT1-1000 16 s
  // TODO: instead, make MUSIC slower?
  let forceUpdate = false,
      forceUpdateLimit = 1024*1024;

  const ESC = 27;

  function boot() {
    stop('noprompt');
    
    // init
    vars = {};
    stack = [];
    line = '';
    lineno = 0;
    lineToDo = [];
    caps = true;
    click = true;
    column = 2;
    scoff = 0;
    scstop = 0;
    printer = undefined;
    double = false;
    trace = false;
    tron = false;
    forceUpdate = false;
    forceUpdateLimit = 1024*1024;
    
    row = 1;
    col = column;
    paper = 7;
    ink = 0;

    gedit = false;
    lores = 0;
    curx = 0;
    cury = 0;
    
    // at start only one channel enabled!
    PLAY['con1'] = 1;
    PLAY['con2'] = 0;
    PLAY['con3'] = 0;
    
    // stats
    putc.count = 0;
    putc.scrollcount = 0;

    screen.readcount = 0;
    screen.writecount = 0;

    run.count = 0;
    
    cont.intervalcount = 0;
    cont.millis = 0;

    // action
    CLS();
    showStatus();
    print(
`ORIC EXTENDED BASIC V1.2
\` 1983 TANGERINE

 372631 BYTES FREE`);
  }

  // TODO: define imgs for each character?
  // then we can 'poke' to change them?

  // TODO: calling twice messes something up
  function TEXT() {
    for(let row=0; row<SCREEN_ROWS; row++) {
      let r = '';
      // lol, let's create one extra as the last character is kind of hidden...
      for(let col=SCREEN_COLS; col>=0; col--) {
	c = '&nbsp;';
//	c = String.fromCharCode(128+32);
	let id = `r${row}c${col}`;
	r = `<span id='a${id}'><span class='char' id='c${id}'>${c}</span>${r}</span>`;
      }
      dom('screen', r+'</br>', 'ah');
    }

    domc.cache = {};
  }
  
  // mode: 0 or 1
  function LORES(mode) {
    // DOC: Set screen mode
    // 0 - text mode
    // 1 - alt character
    // New: "LORES" => preserve text!

    // TODO:
    // New: LORES 2 background attr mode!
    //   (draw w any color! 25x40
    // New: N lines scroll text at bottom
    // 3 - like 'HIRES' with 3 lines text
    // N - same but with N lines

    //tPos(mode);

    // actually, LORES fills screen with
    // background == black

    let text = 8, alt = 9;

    if (mode > 0) {
      let a = mode==0 ? text : alt;
      fill(1, 0, SCREEN_ROWS-1, SCREEN_COLS, a);

      lores = mode;
      return;
    }

    // NEW!

    // TODO: and back -> default text
    // change any 9,9 -> 8,9!

    // tries to preserve text!
    let last, lasthi;
    for(let r=1; r<SCREEN_ROWS; r++) {
      // ignore paper + ink ...
      screen(r, 0, 32); // set first col
      screen(r, 1, 32); // set second col
      
      last = undefined; lasthi = 0;
      for(let c=0; c<SCREEN_COLS; c++) {

	let ch = screen(r, c);
	let hi = ch & 0x80f;
	let c7 = ch & 0x7f;

	//console.log(`${r} ${c} [${ch}]`);
	if ((c7 === 0 || c7 === 7)
	    && col === 1) {
	  // default color, steal it!
	  //screen(r, c, alt+hi); // alt
	}

	// steal any space!
	// if text follows we'll fix it!
	if (c7 === 32)
	  screen(r, c, alt+hi); // alt
	
	if (c7 > 32 && last === 32) {
	  // we got text, need to patch
	  // c-1 is safe as we put 9 in 0
	  screen(r, c-1, text+lasthi);
	}
	
	last = c7; lasthi = hi;
      }
    }
  }

  function hires() {
    return lores < 0;
  }

  function HIRES(mode) {
    // DOC: Set hiresolution grahics mode
    // Three 3 lines at bottom is text
    // New: N lines of text (0--3)
    if (mode === undefined) mode = -3;
    tPos(-mode, -mode < SCREEN_ROWS);
    lores = mode;
  }

  HELP.related.push('HIRES CIRCLE CHAR CURMOV CURSET DRAW FILL PATTERN POINT  ');

  // set/get bit identified by mask
  // relative lores mode
  // 0 = off
  // 1 = on
  // undefined = outside screen  (off)
  function setbit(x, y, m) {
    x = INT(x+0.5);
    y = INT(y+0.5);

    function updatebit(r, c, mask) {
      r = INT(r); c = INT(c);
      if (r < 0 || c < 0) return;

      if (!hires()) {
	r++;  // skip status line
	c++; // skip first control column
      }

      if (r < SCREEN_ROWS &&
	  c < SCREEN_COLS) {

	let ch = screen(r, c);

	let c7 = ch & 0x7f;
	if (c7 < 32 || c7 > 96)
	  ch = 32 | (ch & 0x80);
	//if (ch < 32 || ch > 96)
	//ch = 32;

	switch(m) {
	case 0: ch &= ~mask; break;
	case 1: ch |= mask; break;
	case 2: ch ^= mask; break;
	}

	if ((ch & 96) == 96)
	  ch ^= 32;
	if (ch > 96)
	  ch ^= 32;
	if (ch < 32) ch += 32;

	if (m < 3) screen(r, c, ch);

	return (ch & mask) ? 1 : 0;
      } else {
	return;
      }
    }

    if (hires()) {
      let mask = 1 << (x % 6);
      return updatebit(y, x/6, mask);
    } else {
      let bit = (x % 2) + 2*(y % 3);
      let mask = bit<5 ? 1 << bit : 64;
      return updatebit(y/3, x/2, mask);
    }
  }

  function POINT(x, y) {
    // DOC: return 1 if pixel set at X,Y
    return setbit(x, y, 3)?1:0;
  }
    
  function CURSET(x, y, m) {
    // DOC: Set graphics cursor X, Y, MODE
    // 0 = clear bit  1 = set bit
    // 2 = xor        3 = ignore
    // New: draw outside of screen!
    // New: works in LORES mode!
    curx = x;
    cury = y;
    setbit(x, y, m)
  }

  function CURMOV(dx, dy, m) {
    // DOC: Set graphics cursor X, Y
    // MODE: 0 = clear bit  1 = set bit,
    //       2 = xor        3 = ignore
    // New: draw outside of screen!
    // New: works in LORES mode!
    curx += dx;
    cury += dy;
    setbit(curx, cury, m);
  }

  function DRAW(dx, dy, m) {
    // DOC: Draw a line relative DX,DY
    // New: draw outside of screen!
    // New: works in LORES mode!

    // TODO: https://www.geeksforgeeks.org/bresenhams-line-generation-algorithm/?ref=rp
    // OR: https://www.geeksforgeeks.org/mid-point-line-generation-algorithm/?ref=rp

    let steps = ABS(
      ABS(dx) > ABS(dy) ?
	dx : dy);

    let ix = dx/steps;
    let iy = dy/steps;
    let x = curx, y = cury;
    for(let i=0; i<steps; i++) {
      setbit(x, y, m);
      x += ix; y += iy;
    }
    curx = curx + dx;
    cury = cury + dy;
  }

  function CIRCLE(r, m) {
    // DOC: Draws a circle of RADIUS
    // New: draw outside of screen!
    // New: works in LORES mode!

    // TODO: https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/?fbclid=IwAR3fO_Ib4oC6is3FBdcw_9U1HvvYRMg2CIEKaHR3-ohMMew-0oHXL5Ou4W4
    if (r <= 0) return;

    function set(x, y) {
      setbit(curx + x, cury + y, m);
    }
    
    function setall(x, y) {
      // 8 symmetries!
      set(x, y);
      set(-x, y);
      set(x, -y);
      set(-x, -y);

      set(y, x);
      set(-y, x);
      set(y, -x);
      set(-y, -x);
    }

    let rr = r*r;
    let x = r, y = 0;
    while (x > y) {
      setall(x, y);
      y++;
      x = SQR(rr - y*y);
    }
    // for xor mode 2 it's soso...
    //setall(x, y);
  }

  function FILL(rows, cols, v) {
    // DOC: Fill area of screen at cursor
    // ROWS: number of rows to fill
    // COLS: number of cols to fill
    // CELL: Cell value to use
    fill(INT(cury/SCREEN_COLS),
	 curx % SCREEN_COLS,
	 rows, INT(cols / 6),
	 v);
  }

  // Structurally it is very similar to the TEXT mode, with 40 bytes per line, with each byte representing 6 pixels for a total of 240 pixels in width.
  // The main difference is that each line is only one pixel tall instead of 8, so there are 200 of these.
  // The actual graphical resolution is 240x200, but the screen has an additional area at the bottom containing 3 lines of TEXT mode.

  // From a memory point of view, HIRES mode is much more voracious:
  // 8000 bytes for the HIRES part of the screen (from #A000 to #BF3F)
  // 120 bytes for the TEXT part of the screen screen (from #BF68 to #BFDF)
  // 42 bytes lost between the HIRES and TEXT parts of the screen (from #BF40 to #BF67)
  // 1024 bytes for the default character set (from #9800 to #9BFF)
  // 1024 bytes for the secondary ("alternate") character set (from #9C00 to #9FFF)
  // This makes a total of 10210 bytes.

  // http://twilighte.oric.org/twinew/ula.htm
  
/*
ince we can POKE any value we like to the screen we can use this to set up a 
High RESolution colour display using all eight colours. The following 
program produces a sinusoidal striation of colour down the screen in this 
manner. 
10 HIRES 
20 FORY=0T0199 
30 S=INTCSINCY/l0J*8J 
40 FORX=0T039 
50 P=#A000+Y*40+X 
60 Q=CS+XJ-INTCCS+XJ/8J*8+16 
70 POKE P,Q 
80 NEXT 
90 NEXT 
By using this method of placing attributes on the HIRES screen we can 
produce more colours from the Orie. We simply mix two different colours 
together on alternate lines and we can make at least 36 different colours. 
The following program demonstrates some of the colours which can be 
achieved. Even more shades can be accessed by overlaying patterns of 
foreground colours on these striped backgrounds! 
t 'COPYRIGHT PAN LTD 
10 PAPER 0: INK 7 
20 HIRES 
30 FOR A=0 TO 7 
40 FOR 8=0 TO 7 
50 FOR 1=8*20 TO 8*20+20 
60 P=#A000+Y*40+A*5 
70 IF INTCY/2)=1/2 THEN Q=l6+A 
=-16+8 
80 POKEP,Q 
90 NEXT 
100 NEXT 
110 NEXT 
ELSE Q 
So far the subject of writing
*/

  HELP.related.push('HIRES TEXT LORES GRAB HIMEM RELEASE');
  HELP.related.push('RUN CLEAR GOTO GOSUB RETURN POP IF THEN ELSE ON FOR TO STEP NEXT REPEAT UNTIL PULL');
  HELP.related.push('RUN STOP CONT GOTO TRON TROFF');
  HELP.related.push('LOAD AUTO CSAVE STORE RECALL NEW DIM CLEAR');
  HELP.related.push('INPUT GET KEY$');
  
  const color = {
    black:   '#000000', 0: '#000000',
    red:     '#FF0000', 1: '#FF0000',
    green:   '#00FF00', 2: '#00FF00',
    yellow:  '#FFFF00', 3: '#FFFF00',
    blue:    '#0000FF', 4: '#0000FF',
    magnenta:'#FF00FF', 5: '#FF00FF',
    cyan:    '#00FFFF', 6: '#00FFFF',
    white:   '#FFFFFF', 7: '#FFFFFF',
  };
    
  let inverse = n=>7-n;
  
  function domc(id) {
    domc.cache = domc.cache || {};
    let d = domc.cache[id];
    if (!d) {
      d = dom(id);
      domc.cache[id];
    }
    return d;
  }
  
  function PLOT(x, y, s) {
    // DOC: at X,Y raw-write VALUE to screen
    // X: 0--39 (include 0--2 !)
    // Y: 0--26 (not modeline)
    // String of char code (0-255)

    if (printer)
      printer(`[ PLOT(${x},${y},"`);

    iplot(x, y+1, s);
  }
  function iplot(x, y, s) {
    if (typeof s === 'number')
      s = String.fromCharCode(s);
    
    if (printer) printer(s);

    for(let i=0; i<s.length; i++) {
      screen(y, x, s.charCodeAt(i));
      if (++x >= 40) {
	x = 0; y++;
      }
    }
        
    // not totally "rigth" but it looks better
    if (printer) printer('" ]\n');
  }
      
  function SCRN(x, y) {
    // DOC: Return char/attr at X, Y
    tPos(x, x < SCREEN_COLS);
    tPos(y, y < SCREEN_ROWS-1);
    return screen(y+1, x);
  }
  
  function POS() {
    // DOC: Column position
    return col;
  }
  
  function ROW() {
    // DOC: New: Row number
    return row;
  }
  
  // return text for one line,
  // if nohi strips 7bit
  // if noattr replace them with ' '
  function getScreenLine(r, nohi, noattr) {
    let t = '';
    for(let c=0; c<SCREEN_COLS; c++) {
      let ch = screen(r, c);
      if (nohi) ch = ch & 0x7f;
      if (noattr && (ch < 32)) ch = 32;
      t += String.fromCharCode(screen(r, c));
    }
    return t;
  }

  // BRAILLE
  // https://en.m.wikipedia.org/wiki/Braille_Patterns
  // bit-value:
  //  1   8
  //  2  10
  //  4  20
  // 40  80
  let BRAILLE = 2800; // REALLY!?

  // nodejs can't handle it?
  // let braille =⠀"⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟";
	 
  // this is like equivalent of POKE!
  // READ   screen(row, col) => ch
  // WRITE  screen(row, col, ch)
  //   ch <  0   magical pixels
  //   ch <  8   INK
  //   ch < 16   ... blink, ALT, double
  //   ch < 24   PAPER
  //   ch > 31   ASCII
  //   ch >127   ASCII inverted!
  //   ch > 255  Unicode ...
  function screen(row, col, ch, html) {
    let dc = domc(`cr${row}c${col}`);

    // TODO: speedup for read/scroll
    // screen.arr[row, col]
    // other idea: redraw from scratch!
    
    // --- READ screen?
    if (ch === undefined) {
      screen.readcount++;
      if (dc.screenchar === undefined)
	dc.screenchar = 32;
    return dc.screenchar;
    }

    // --- WRITE!
    
    // no write?
    if (scoff) return scoff++;

    screen.writecount++;
    dc.screenchar = ch;

    // hack for testing!
    if (html) {
      dc.innerHTML = html;
      dc.screenchar = ch;
      return
    }
    
    let da = domc(`ar${row}c${col}`);
    let t;

    // interpret char/attribute
    let c = ch & 0x7f;

    // clear all
    da.style = '';
    da.className = '';

    dc.style = '';
    dc.className = '';
    dc.textContent = '';

    // process byte
    if (ch > 255) { // unicode! lol
      // pass through, we don't c(h)ar(e)
      t = ch;
    } else if (c >= 32) { // ascii
      // TODO: implement inverse!
      // remove high-bit as it means inverse
      t = ch & 0x7f;
      if (ch & 0x80)
	dc.classList.add('inverse');
    } else if (ch < 0) { // bits...
      t =  BRAILLE - ch; // so it get's "added"
    } else if (c < 8) { // INK
      let fg = c & 0x07;
      if (c > 127) fg = inverse(fg);
      da.style.color=color[fg];
      //t = 32; // blankk it out
      t = 48 + fg; // hidden
      dc.classList.add('attr');
    } else if (c < 16) {
      // Character Set modifier
      // 8  Use Standard Charset
      // 9  Use Alternate Charset
      // 10 Use Double Size Standard Charset
      // 11 Use Double Size Alternate Charset
      // 12 Use Blinking Standard Charset
      // 13 Use Blinking Alternate Charset
      // 14 Use Double Size Blinking Standard Charset
      // 15 Use Double Size Blinking Alternate Char

      let alt = c & 1;
      let double = c & 2;
      let blink = c & 4;

      da.class = '';

      // TODO: consider attr12 !
      if (alt) {
	da.classList.add('alt');
	t = 'a'.charCodeAt(0);
      } else {
	da.classList.add('standard');
	t = '$'.charCodeAt(0);
      }

      if (blink)
	da.classList.add('blink');
      else
	da.classList.add('noblink');

      if (double)
	da.classList.add('double');
      else
	da.classList.add('normal');

      // hidden
      dc.classList.add('attr');

    } else if (c < 24) { // 16-23 paper

      let bg = c & 0x07;
      if (bg > 127) bg = inverse(bg);
      da.style.backgroundColor=color[bg];

      // hidden
      t = 48 + bg;
      dc.classList.add('attr');

    } else {
      // TODO: mode switching
      // idea: make screen garbled? lol
      // or stretch!

      // Video control attributes
      // 24-27 Switch to TEXT mode (60 Hz)?
      // 28-31 Switch to HIRES mode (60 Hz)?
    }

    if (t == 32) {
      dc.innerHTML = '&nbsp;';
    } else if (t !== undefined) {
      dc.textContent = String.fromCharCode(t);
    }

    // get out if set colors
    if (c < 32) return;
  }

  screen.readcount = 0;
  screen.writecount = 0;

  function screenSaved(rows=SCREEN_ROWS, cols=SCREEN_COLS) {
    let g = gCMD;
    let sc = {
      name: screen.name,
      version: screen.version,
      time: Date.now(),
      date: new Date().toISOString(),
      rows, cols,
      row, col, curx, cury,
      ink, paper,
      lores,
      gedit: {
	ox: g.ox, oy: g.oy,
	mode: g.mode,
	xmode: g.xmode,
	stack: g.stack,
	index: g.index,
	ink: g.ink,
	paper: g.paper,
      },
    };

    for(let r=0; r<SCREEN_ROWS; r++) {
      let h = '';
      for(let c=0; c<SCREEN_COLS; c++) {
	if (screen(r,c) === undefined)
	  console.log('scundef '+r+' '+c);
	h += screen(r, c).toString(16).padStart(2, '0');
      }
      sc[r] = h;
    }

    return sc;
  }

  // TODO: draw portion at offset
  function screenDraw(sc) {
    // TODO: really restore all?
    screen.name = sc.name;
    screen.version = sc.version;
    
    //name: screen.name,
    //version: screen.version,
    //time: Date.now(),
    //date: new Date.toISOString(),
    row = sc.row; col = sc.col;
    curx = sc.curx; cury = sc.cury;
    ink = sc.ink; paper = sc.paper;
    lores = sc.lores;
    
    let g = gCMD;
    g.ox = sc.gedit.ox || 0;
    g.oy = sc.gedit.oy || 0;
    g.xmode = sc.gedit.mode || 0;
    g.stack = sc.gedit.stack || [];
    g.index = sc.gedit.index || 0;
    g.ink = sc.gedit.ink || ink;
    g.paper = sc.gedit.paper || paper; 

    let rows = Math.min(SCREEN_ROWS, sc.rows);
    let cols = Math.min(SCREEN_COLS, sc.cols);
    for(let r=0; r<rows; r++) {
      let h = sc[r];
      for(let c=0; c<cols; c++) {
	let ch = parseInt(h.substr(c*2, 2), 16);
	screen(r, c, ch);
      }
    }
  }

  function INK(color) {
    ink = color;
    // skip status line
    for(let row=1; row<SCREEN_ROWS; row++) {
      screen(row, 1, color);
    }
  }
  function PAPER(color) {
    paper = color;
    // skip status line
    for(let row=1; row<SCREEN_ROWS; row++) {
      screen(row, 0, 16+color);
    }
  }

  function exmple_PAPER() {
    return `
l0 FOR I=0 TO 7 
20 INK I 
30 FOR J=0 TO 7 
40 PAPER J 
50 WAIT 50 
60 NEXT J 
70 NEXT I 
80 INK 0 
`;
  }

  function example_PRINTAT() {
    return `
10 FOR X=2 TO 30 
20 PRINT @X,10;·• WHIZZ2" 
30 NEXT X
`;
  }

  function printerToggle() {
    if (printer) return printer = undefined;

    let p = dom('printer');

    printer = function(c) {
      // TODO: print@, plot, (screen?
      if (typeof c === 'number') {
	if (c >= 32 || c === 10)
	  c = String.fromCharCode(c);
	else if (c === 4) c = '[ TOGGLE DOUBLE LINE ]';
	else if (c === 6) c = '[ TOGGLE KEYCLICK ]';
	else if (c === 7) c = '[ BELL ]';
	else if (c === 8) c = '[ BACKSPACE ]';
	else if (c === 9) c = '        '; // TODO: TAB
	else if (c === 12) c = '\n[ CLEAR SCREEN ]\n';
	else if (c === 13) c = '[ CR ]';
	else if (c === 14) c = '[ CLEAR LINE ]';
	else if (c === 15) c = '[ DISABLE SCREEN ]';
	else if (c === 17) c = '[ TOGGLE CURSOR ]';
	else if (c === 19) c = '[ TOGGLE SCREEN ]';
	else if (c === 20) c = '[ TOGGLE CAPS ]';
	else if (c === 27) c = '[ ESC ]';
	else
	  c = '[ CHAR: #' + c.toString(16) + ' (' + c + ') ]';
      }
      p.append(c);
    }
    return true;
  }
  
  // TODO: ORIC used to have blinking cursor
  // also has 'cursor' varaible controlled by
  let cursor = true;
  let raw = false;
  function cursorToggle(wantOn) {
    if (wantOn === undefined) {
      cursor = !cursor;
    } else if (typeof wantOn === 'string') {
      cursor = (wantOn.toLowerCase() === 'on');
    } else {
      cursor = !!wantOn;
    }

    if (!cursor) cursorHide();
    // don't show cursor here as this run as soon as key presseed leaving traces
    return cursor;
  }

  // cursorHide(),cursorShow() - don't call as it's managed by the system functions call cursorToggle() for your intent
  let cursorVisible = false;
  function cursorHide() {
    if (!cursorVisible) return;
    cursorVisible = false;
    let d = domc(`cr${row}c${col}`);
    //d.classList.remove('inverser');
    d.classList.remove('cursor');
  }
  function cursorShow() {
    // TODO: right place? lol
    dom('exp').value = line;
    
    if (!cursor || cursorVisible) return;
    cursorVisible = true;
    let d = domc(`cr${row}c${col}`);
    d.classList.add('cursor');
  }
  
function scroll(srow, erow, noClr) {
  let dir = srow > erow ? 1 : -1;

  // copy FROM row
  for(let r=erow; r!=srow; r+= erow<srow?1:-1) {
    //console.log('r=', r);
    // generalize for sideways scroll!
    for(let c=0; c<SCREEN_COLS; c++) {
      let old = screen(r, c);
      let nw = screen(r+dir,c);
      if (nw != old)
	screen(r, c, nw);
    }
  }
  if (!noClr) {
    for(let c=0; c<SCREEN_COLS; c++)
      screen(srow, c, 32);
    //console.log(JSON.stringify({paper, ink}));
    screen(srow, 0, paper+16);
    screen(srow, 1, ink);
  }
}

/*
Codes0-31 
CODE CHARACTER Control Code 
0 Null 
1 Copy CTRL-A 
2 
3 Break	 CTRL-C 
4 Double line printing CTRL-D (TODO: jsk)
5 
6 Keyclick CTRL-F 
7 Bell (PING) CTRL-G (TODO: jsk)
8 Backspace (Cursor left) CTRL-H  (TODO: jsk)
9 Cursor right CTRL-I  (TODO: jsk)
10 Line feed (Cursor down) CTRL-J  (TODO: jsk)
11 Cursor up CTRL-K  (TODO: jsk)
12 Clear screen CTRL-L  (TODO: jsk)
13 RETURN CTRL-M (beginning of line) (TODO: jsk)
14 Clear line CTRL-N  (TODO: jsk)
15 Disable screen CTRL-0  (TODO: jsk)
16 
17 Cursor CTRL-Q  (TODO: jsk)
18 
19 Screen CTRL-S  (TODO: jsk)
20 Caps (upper case) CTRL-T  (TODO: jsk)
21 
22 
23 
24 Cancel line CTRL-X 
25 
26 
27 ESC (Escape) (TODO: jsk)
28 
29 
30 
31 
32 Space
*/
  function putc(c) {
    if (typeof(c) !== 'number')
      alert('putc: only take nubmers: ' +  c);
    putc.count++;

    // print double (at next line too)
    if (double && row+1 < SCREEN_ROWS)
      screen(row+1, col, c);

    // TODO: if scoff should we printer?
    if (printer) printer(c);
    
    if (scoff) return scoff++;
    
    // TODO: how to handle inverse?
    let ch = c & 0x7f;

    // raw immediate mode
    if (raw) {
      // ESC A => \1
      if (c < 128) {
	c = ch & 0x1f;
      } else {
	// jsk; extension - allows INVERSE!
	// ORIC: gives space :-(
	c = ch;
      }
    } else if (c > 127) {
      raw = true;
      c = ch; // stripped high-bit
    }

    // raw next char mode
    if (ch === ESC) return raw = true;

    if (raw || ch >= 32) {
      screen(row, col, c);

      col++;
      raw = false;
      if (raw) alert('c===' + c);
      c = ch = undefined;
    }

    if (ch == 10) { row++; col = column; }

    // backspace
    if (ch == 8) {
      col--;
      if (col < column) {
	col = SCREEN_COLS-1;
	row--;
      }
      screen(row, col, 32);
    }

    if (col >= SCREEN_COLS) {
      row++;
      col = 2;
    }
    
    if (row >= SCREEN_ROWS) {
      scroll(SCREEN_ROWS-1, 1);
      row = SCREEN_ROWS-1;
    }
  }

  putc.count = 0;
  putc.scrollcount = 0;

  // 20LETSEL=0 => 20 LET SEL = 0
  // TODO: 63999 max
  //  
  // integer -32767 to 32768
  // A%
  // A$

  // DIM varname(exp, ...)
  // TEST:
  //  Q(9)=3
  //  Q(10)=4
  //  Q(11)=5 => ?BAD SUBSCRIPT ERROR
  //  Q(0)=77
  //  Q(-1)=44 => ?ILLEGAL QUANTITY ERROR
  
  // TODO: fix
  // TODO: maybe let an array be a function! __Arr(3,4) evaluate to the value, or if LET an LVALUE
  // TODO: how to see in an exppression it's
  // an variable and not function call?
  function DIM(n, ...dims) {
    // DOC: Dimension an multidimensional array DIM A$(1:st dim, 2:nd dim, ...)
    // All elements set to detault value.
    // ORIC: Any array index 0..10 is 'predefined'
    // New: Any index can be set once dimensioned, it's automatically extended (with nulls!)
    // Bug: Not capture index out of bounds
    // Bug: There is no diff between array varaibles and others with same name...
    // ...and so PRINT will happily print the array
    let v = 0.0;
    if (n.match(/^\w+\%/)) v = 0;
    if (n.match(/^\w+\$/)) v = '';
    
    function gen(dim, ...dims) {
      if (!dim) return v;
      return [...Array(dim)]
	.map(_=>gen(...dims));
    }
    
    vars[n] = gen(...dims);
  }

  // TEST:
  //   LET IF=2 => ?Syntax...
  //   LET THE=3 => ok
  //   LET THENN=4 => ?Syntax...
  function LET(n) {
    let v = this;
    v = v.replace(/^\s*LET\s*\S+\s*=\s*/, '');
    if (trace) print('LET: ' + v);
    let r = EVAL(v);
    if (r === undefined) return;

    // make sure type fit
    if (n.endsWith('%')) {
      tInt(r);
      r = INT(r);
    }
    if (n.endsWith('$')) r = ''+r;

    // indexing (interpolate using fixpoint!)
    let lastn = n;
    while (lastn != (n = n.replace(
      /\[([^\[\]]*)\]/g, (_,i)=>'['+EVAL(i)+']'))) {
      if (trace) print('IX: ' + n);
      lastn = n;
    }

    // okay, have value, try to set it
    if (trace) print('SET: ' + n);

    // array A(3,4)=77 complicates things...
    // TOOO: make a ref('A$', val)
    // or replace A$ with a function
    // ARRAY_A$
    let path = n.replace(/[\[\]]/g, ' ').trim()
	.split(/\s+/g);
    if (trace) print('PATH: ' + JSON.stringify(path));
    let nv = vars;
    let x;
    let lastx = path.shift();
    while ((x = path.shift()) !== undefined) {
      if (trace) print('LOOP lastx: ' + lastx);
      if (trace) print('LOOP x: ' + x);
      nv = nv[lastx];
      lastx = x;
    }
    if (trace) print('SET: ' + (nv == vars) + ' ' + lastx);
    nv[lastx] = r;
  }

  function EVAL(x) {
    try {
      if (trace) print('VARS: ' + JSON.stringify(vars));
      // pow!
      x = x.replace(/\^/g, '**');
      if (trace) print('EXP: >' + x + '<');
      // TOOD: not correct comparisons
      // as ORIC returns 0/-1 for false/true
      if (x.match(/(<|=|>)/))
	return implemented_error('comparisons');
      let r = (function(ATMOSexp){
	// fast cheat!
	with (vars) {
	  return eval(ATMOSexp);
	}
      })(x);
      if (trace) print('-->: ' + r);

      // check illegal values
      if (r === undefined) // ???
	type_error();

      if (typeof r === 'number') {
	if (r === Number.NEGATIVE_INFINITY ||
	    r === Number.POSITIVE_INFINITY)
	  div_error();
	if (Number.isNaN(r))
	  type_error();
	// 1. 7E38 -- 2.93E-39 OK!
	let a = ABS(r);
	if (a && (a < 2.93E-39 || a > 1.7E38))
	  overflow_error();
      }
     
      if (typeof r === 'string') {
	// TODO: relax?
	if (r.length > 255)
	  string_error();
      }

      // should we allow extensions?
      if (typeof r === 'object')
	type_error();

      return r;

    } catch(e) {
      console.log('?EVAL: ' + x);
      console.log('ERR=', e);
      //eval_error('' + e);
      //stop();
      throw e;
    }
  }
  
  function val(n) {
    //n = n.substring(0, 2);
    return vars[n];
  }
  
  // fill text/graphics cells
  function fill(row, col, rows, cols, v) {
    let f = v;
    if (typeof f !== 'function') f = ()=>v;

    for(let r=0; r<rows; r++)
      for(let c=0; c<cols; c++)
	screen(
	  row + r, col + c,
	  f(row + r, col + c));
  }

  // Also CTRL-L
  // TODO: manual says it'll clear screen
  // AND: set it to current INK/PAPER!!!?
  function CLS() {
    let start = Date.now();
    fill(0, 0, SCREEN_ROWS, SCREEN_COLS, 32);
    row = 1; col = 2; raw = false;
    PAPER(paper);
    INK(ink);
    //dom('error', 'CLS time ' + (Date.now()-start));
    showStatus();
  }

  // 20 INPUT"ENTER SALE PRICE";SELL
  function INPUT(prompt, v) {
  }

  function princ(txt) {
    if (txt === undefined || txt === '')
      return;

    // for numbers ORIC makes SURE it fits
    // without line breaks!
    if (typeof txt == 'number') {
      txt = ' ' + txt + ' ';
      if (col + txt.length > SCREEN_COLS)
	putc(10);
    } else {
      txt = '' + txt;
    }
    
    for(let i=0; i<txt.length; i++) {
      putc(txt.charCodeAt(i));
    }
  }
  function print(txt) {
    princ(txt);
    putc(10);
  }

  function TAB(pos) {
    // DOC: Move cursor to POS
    // New: If no arg move to next column
    // New: -POS is using custom tabwidth POS
    // New: "3" means use 3 cols (=INT(-40/3))
    
    // positive number
    if (+pos===pos && +pos > 0) {
      while(col < pos)putc(32);
      return '';
    }

    // use columns
    if (typeof pos === 'string')
      pos = -INT(SCREEN_COLS/(+pos));
    let width = (pos < 0) ? -pos : 8;
    while((col-column) % width !== 0)
      putc(32);
    
    // return '' as I think it's used in PRINT
    return '';
  }
  
  
  // #FFFFF 
  // PRINT "FOO"BAR"
  // PRINT "4*3="; 4*3
  // PRINT "FOO";"BAR" => FOOBAR
  // ?35 == PRINT 35
  // PRINT 1;2 => <spc>1<spc><spc>2<spc>
  // 40 PRINT"THE CODE FOR "A$"="ASC(A$)
  // PRINT "foo",
  // PRINT "bar"    > fooo       bar 
  // 20 PRINT @X,10;·• WHIZZ2" 
  // TEST: PRINT 1 2 3+6 =>  123  6
  // TEST: PRINT 1 2 3, 4 5, FOO, FOO& =>
  //   123     45   3
  //   ?SYNTAX ERROR
  // TEST: LET A=1 2 3 : PRINT A => 123
  // TEST: A=77 : AA=6 : A$="FOO"
  //   TEST: PRINT A A => 6
  //   TEST: PRINT 7A => 7  77
  //   TEST: PRINT 9AA4 5, 99 => 9  6   99
  //   TEST: PRINT 3A$6 =>  3 FOO 6
  //   PRINT 3A$77AA(3)5A$A =>
  //     3 FOO 77 0 5 FOO 77
  //   ?A$7A$AA => FOO 7 FOO 6
  //   ?A$3+4*10^2A => FOO 403  77
  //   PRINT A A => 6
  //   PRINT AA => 6
  //   PRINT A => 77
  //   ? A A+7 => 13
  // TEST: LET A B = 7 5
  //   PRINT AB =>  75
  //   PRINT AB 5 =>  75
  //   PRINT AB C => 75
  // TODO: PRINTAT
  //  20 PRINT @X,10;·• WHIZZ2"

  // TODO: print ctrl-codes perform action!
  function PRINT() {
    let line = this;
    line = line.replace(/^L*PRINT\s*/, '');
    line = line.trim();

    let exp = '', mode = 'normal', par = '';
    let nonewline = false;
    for(let i=0; i<line.length; i++) {
      let c = line[i];
      //if (trace) print('PRINT.c: ' + c);

      function finish(ev) {
	if (exp.length && !exp.match(/^\s*$/))
	  princ(ev?EVAL(exp):exp);
	exp = '';
	if (c === ',') TAB();
      }
      
      switch(mode) {
      case 'normal': {
	switch(c) {
	case ',':
	case ';': 
	case ' ': finish(true); break;
	case '\\': return unexpected_error('\\');
	case '"': finish(true); mode = 'string'; par += '"'; break;
	case '(': exp += c; mode = 'expr'; par += ')'; break;
	case '[': exp += c; mode = 'expr'; par += ']'; break;
	default: exp += c;
	}
	break;
      }
      case 'string': {
	if (c=='"') {
	  if (exp.length)
	    princ(exp)
	  exp = '';
	  mode = 'normal';
	} else {
	  exp += c;
	}
	break;
      }
	// TOOD: too simple
      case 'expr': {
	if (par)
	  if (')]"'.indexOf(c) >= 0) {
	    let e = par[par.length-1];
	    if (e !== c)
	      return unmatched_paren_error(e, c);
	    else
	      par = par.substring(0, par.length-1);
	  }
	
	switch(c) {
	case '\\': return unexpected_error('\\');
  
	case '(': par += ')'; break;
	case '[': par += ']'; break;
	case '"': par += '"'; break;
	  
	case ';':
	  if (par) return unexpected_error(';');
	  // else! fallthrough
 	case ',':
	case ' ': {
	  if (exp.length && !par.length) {
	    princ(EVAL(exp))
	    exp = ''
	    mode = 'normal';
	  }
	  if (c === ',') TAB();
	  break;
	}
	default: exp += c;
	}
	break;
      }
      }
      if (c !== ' ') nonewline = false;
      if (c === ';') nonewline = true;
    }

    // cleanup
    if (exp.length) {
      // TODO: missing " ?
      if (mode === 'string')
	princ(exp);
      else
	princ(EVAL(exp));
    }
    if (!nonewline)
      putc(10);
  }

  HELP.related.push('LIST LLIST EDIT CLOAD CSAVE');
  HELP.related.push('TEXT PRINT LPRINT CLS INK PAPER SCRN PLOT POS TAB SPC');
  /*
LPRINT, LLIST...

LPRINT BASIC Token: 143
Format: LPRINT A$

This command works exactly the same as a PRINT statement except that it is used to send the print items to a printer. However, it is not possible to use an LPRINT@ statement. Used vvith the control codes listed in Appendix 1, LPRINT can be used to regulate the output to a variety of printers. It is possible to alter the line length of the printer output by using POKE #256,i where i is the required line length. 

  Related keywords: CHR$, LLIST, PRINT
  */
  function LLIST() {
    // DOC: List program to printer

    // save state
    let psave = printer, ssave = scoff;

    // turn on printer, and screeen off!
    if (!printer) printerToggle();
    scoff = 1;

    // essense of LIST
    {
      line = '';
      lineno = -1;
      print();
      nextline();
      while (line) {
	princ(lineno);
	print(line);
	nextline();
      }
      print();
      lineno = 0;
      line = '';
    }

    // restore
    printer = psave;
    scoff = ssave;
  }

  // TODO: same complicated parsing as PRINT...
  function LPRINT(...args) {
    // DOC: Prints to the printer
    // TODO: doen't handle TAB()

    // save state
    let psave = printer, ssave = scoff;

    // turn on printer, and screeen off!
    if (!printer) printerToggle();
    scoff = 1;

    // cheat
    // TODO: keep track of col?
    PRINT.apply(this, args);

    // restore
    printer = psave;
    scoff = ssave;
  }


  // TODO: Basic Lines max 80 chars bell at 79?

  // LIST -100
  // LIST 100-
  // LIST 100-200

  // TODO: sorted?
  let lines = {
    //1: 'PRINT "HELLO!"',
    //2: 'END',
    
    10: 'LET A=0',
    20: 'PRINT A;',
    30: 'LET A=A+1',
    40: 'GOTO 20',
  };

  ylines = {
    5: 'LET E=1000',
    10: 'FOR I=0 TO E',
    15: 'PRINT I',
    20: 'NEXT',
  };
  
  xlines = {
    10: 'LET I=0',
    20: 'LET P=0',
    30: 'INK I',
    40: 'PAPER P',
    50: 'LET P=P+1',
//    50: 
  };
  
  function running() {
    return !!RUN.interval;
  }
  
  // TODO: like list but formats the code...
  // prettyprint
  // function PP()  {
  //
  //}

  // returns a miniparser object
  function parser(line) {
    let tokens = tokenizer(line, ORIC_TOKENZ);
    if (trace) print(JSON.stringify(tokens));
    let r = [];

    let c, t, s;
    let was = '', wasa = '';

    let p = {
      rest() {
	// umparse lol
	if (!c) return '';
	let all = [...tokens];
	all.unshift(c);
	return all.map(([t,s])=>s).join(' ');
      },
      // -- these just test
      // return type or test if type
      end() {
	return !c;
      },
      type(optT) {
	if (optT) return optT === t;
	return t;
      },
      num() { return this.type('number') },
      string() { return this.type('string') },
      keyword() { return this.type('keyword') },
      op() { return this.type('op') },
      name() { return this.type('name') },
	
      // return val or test if value
      val(optV) {
	if (optV) return optV === s;
	return s;
      },

      // - the following will go to next if match
      next() {
	c = tokens.shift();
	wasa = t;
	was = s;
	t = c && c[0];
	s = c && c[1];
	if (c) return true;
      },
      skip(es) {
	if (s === es) {
	  p.next();
	  return was;
	}
      },
      get(et) {
	if (t === et) {
	  p.next();
	  return was;
	}
      },
      getnum(alt) {
	let n = p.get('number');
	return (n === undefined) ? alt :
	  +n;
      },
      getstr(alt) {
	let s = p.get('string');
	return (s === undefined) ? alt :
	  (s.match(/^"(.*)"$/) || ['',alt])[1];
      },
      seek(es) {
	while(p.val() != es) {
	  if (p.end()) return;
	  if (trace) print('SEEK.skip> ' + p.val());
	  p.next();
	}
	return p.skip(es);
      },
    };

    p.skip();
    return p;
  }

  function LIST() {
    // DOC: List program lines
    // LIST 10 | 10- | -10 | 10-20
    // New: LIST "PRINT" - matches!

    // shouild be passed in as arg, or this?
    let p = parser(this);

    let printer = p.skip('LLIST');
    if (!printer && !p.skip('LIST')) return;

    let start = p.getnum(0);
    let end = (p.skip('-') ?
	       p.getnum(0) : start)
	|| 65536;
    p.skip(',');
    let match = p.getstr('');

    // INIT
    line = '';
    lineno = start - 1;
    print();
    
    RUN.interval = setInterval(_=>{
      if (scstop) return;

      for(let i=0; i>=0; i--) {
	nextline();
	if (!line || lineno > end) {
	  lineno = 0;
	  line = '';
	  stop();
	} else {
	  if (match && !line.match(match)) continue;
	  princ(lineno);
	  print(line);
	}
      }
    }, 0);
  }

  function saveline(lno, line) {
    if (trace) print('saveline.lno: ' + lno);
    if (trace) print('saveline.line: ' + line);

    // we remove one initial space
    // which means saving need to add one..
    let l = line.replace(/^\s/, '');
    if (trace) print('saveline.l: ' + l);

    // ? expansion! (short hand for PRINT)
    // TODO: another day!
    //line.replace(/^(([^"]*)(|"[^"]"))$/g,
    // what does the function get?

    // TODO: REM ?5 not expanded
    // BUT: ' ?5 IS!
    // NOT: ' sdfsdf "foo ?5 sdf" ISN'T!!!

    // store line (or remove)
    if (l.match(/^\s*$/))
      delete lines[lno];
    else
      lines[lno] = l;
      
  }
  
  function EDIT(lno) {
    // DOC: Print, move cursor to LINENO
    // New: Just EDIT if STOP:ped
    // New: Line keeps spaces!
    lno = lno || lineno;
    let line = lines[lno]
    // TODO: error?
    if (!line) return;

    print(lno + ' ' + line);
    cursorMove('u');
  }
  
  function TRON() {
    tron = true;
  }
  function TROFF() {
    tron = false;
  }


  function CLEAR() {
    // DOC: Clears variables
    lineno = 0;
    line = '';
    stack = [];
    lineTodo = [];
    vars = {}
  }

  function RUN(lno) {
    // DOC: Runs program (from LINE)
    // END, STOP, or CTRL-C interrupts
    // Continue with CONT or GOTO num
    CLEAR();
    GOTO(lno || 0);
  }
  
  // TODO: On ORIC you can CONT after END!
  function END() {
    stop('noprompt');
  }
  
  function nextline() {
    // crazy linear search for next!
    // you could goto any number
    // it just find the next numerically
    line = '';
    while (!line && lineno < 65536) {
      lineno++;
      // TODO: these aren't guaranteed to be in order? only when for-in!!!
      line = lines[lineno];
    }
    if (line === undefined) line = '';
  }

  function cont() {
    if (running()) return;
    
    RUN.interval = setInterval(_=>{
      if (scstop) return;

      cont.intervalcount++;
      let start = Date.now();
      let millis;
      let n = 0;
      forceUpdate = false;
      do {
	nextline();
	if (line && trace) print(lineno + ' ' + line)
	if (tron) princ('[ '+lineno+']');
	if (!run(line)) stop();
	millis = Date.now() - start;

	forceUpdate = (n++ > forceUpdateLimit);
      } while (!forceUpdate && millis  < TIMESLICE);
      cont.millis += millis;
    }, 1);
  }
  cont.intervalcount = 0;
  cont.millis = 0;
  
  // TODO: if program edited?
  function CONT() {
    if (!CONT.lineno)
      return cont_error();

    lineno = CONT.lineno;
    line = CONT.line;
    delete CONT.lineno;
    delete CONT.line;

    cont();
  }

  function GOSUB(lno) {
    stack.push(['RETURN', lineno, line]);
    lineno = lno-1;
    line = '';
  }
  function RETURN() {
    let ret = stack.pop();
    if (!ret) return_error();
    if (ret[0] !== 'RETURN')
      return return_error();
    [ret, lineno, line] = ret;
  }    

  // use same stack as GOSUB as they need to be matched! (you can't GOSUB and there NEXT)
  function FOR() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('FOR.init: ' + init);
    print('FOR.to: ' + to);
    print('FOR.step: ' + step);

    let v = init.match(/^(\w+)\s*=/);
    if (!v) syntax_error('');
    ('LET ' + init).LET();

    // TODO: this is when I realize
    // that doing it on the fly isn't going
    // to work very well,
    // HMMM,why was that again? lol
    // FOR-NEXT, GOSUB-RETURN and
    // and something about
    // FIE : FOR : BAR
    // FUM : NEXT : FOO
    //
    // FIE : STOP : BAR
    //
    // PRINT 11 : STOP : PRINT 22 : END
    // CONT -> 22
    // CONT ater END ok! haha
    //
    // notice: the loop is run at least once!
    //   and it'll do one step...
    // ?NEXT WITHOUT FOR ERROR IN LINE...
  }

  function TO() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('TO.to: ' + to);
    print('TO.step: ' + step);

    to = EVAL(to); // once or every time?
    step = EVAL(step); // once or every time?
    if (variable <= to)
      stack.push([lineno, `TO ${to} STEP ${step}`]);
  }

  function NEXT() {
    // TODO: ...
    // cheat for now
    return RETURN(); 
  }

  // TEST:
  //  IF 1 THEN ?1 ELSE ?2 => 1
  //  IF 0 THEN ?1 ELSE ?2 => 2
  //  IF1THENIF1THEN?1ELSE?2ELSE?3 => 1
  //  IF1THENIF0THEN?1ELSE?2ELSE?3 => 2
  //  IF0THENIF0THEN?1ELSE?2ELSE?3 =>>
  //  IF0THENIF1THEN?1ELSE?2ELSE?3 =>>
  

  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  // IF 1 THEN ?2 : ?3 ELSE ?4 : ?5 : ?6
  //   => 2 3 5 6
  // IF "" THEN ?1 ELSE ?2 => 2
  // IF ("") THEN ?1 ELSE ?2 => ?FORMULA COMPL
  // IF "A" THEN ?1 ELSE ?2 => 1
  // IF ("A") THEN ?1 ELSE ?2 => 1

  
  function IF() {
    let p = parser(this);
    p.next();
    pIF(p);
  }

  // TODO: BAD ONE....
  function getExp(p) {
    let x = '';
    // TODO:  This is probably too 'promiscous'!
    // Compared to ORIC it just will give less errors
    while(p.val() != 'THEN' && p.val() != ':' && p.val() != 'ELSE') {
      x += p.val();
      if (!p.next()) break;
    }
    if (trace) print('EVAL.exp= ' + x);
    return EVAL(x);
    // TODO: make it return a closure()?
  }

  function pIF(p) {
    let exp = getExp(p);
    p.skip('THEN') || syntax_error();
    if (!exp && !p.seek('ELSE')) return;
    if (p.num()) return GOTO(p.getnum());
    statements(p);
  }

  function pPRINT(p) {
    let exp = getExp(p);
    print(exp);
    return true;
  };

  function statements(p) {
    do {
      while (p.skip('ELSE') && p.seek(':')
	     || p.skip(':'));
    } while (statement(p));
    return true;
  }

  function isParser(f) {
    let p = f.isParser;
    if (p) return p;
    let n = f.isNormal;
    if (n) return false;
    // we don't know - investigate
    let code = f.toString();
    p = code.match(/^function \w+\(p\)/);
    if (p)
      f.isParser = true;
    else
      f.isNormal = true;
    // tail it
    return isParser(f);
  }

  function statement(p) {
    if (trace) print('STMT> ' + p.rest());
    // comments
    if (p.skip('REM') || p.skip("'")) {
      while(!p.end());
      return false;
    }

    if (p.keyword() || p.name()) {
      let name = p.val();
      if (trace) print('STMT.name> ' + name);
      // first try parser version
      // (for now pNAME is preferred over NAME)
      let f = window['p'+name] || window[name];
      if (!f) syntax_error(name);

      if (trace) print('STMT.func> ' + f.name);
      try {
	if (isParser(f)) {
	  if (trace) print('STMT.isParser> ' + name);
	  // call with parser
	  p.next();
	  f.call(p, p); // redundant!
	  if (trace) print('3CALL.done> ' + p.rest());
	} else {
	  print('STMT.isNormal> ' + name);
	  let line = p.rest();
	  if (trace) print('LINE= '+line);

	  //return run(line);
	  // TODO
	  let args = evalArgs(p);
	  if (trace) print('ARGS= ' + JSON.stringify(args));
	  f.apply(line, args);
	  //f.apply(p.rest(), evalArgs(p));
	}
      } catch(e) {
	run_error(name, e);
      }
      return true;
    }

    // if it's not statement then LET!
    return LET(p);
  }

  // each function "return;" when can't go on
  function expression(p) {
    if (p.num()) return op(p, p.getnum());
    if (p.str()) return concat(p, p.getstr());
    if (p.skip('-')) return exp(p)
    if (p.skip('+')) return exp(p);
    if (p.keyword()) return func(p, p.get('keyword'));
    if (p.name()) return varr(p, p.get('name'));
    if (p.skip('(')) {
      let e = expression(p);
      p.skip(')') || syntax_error('NO ")"');
      return e;
    }
  }

  function op(p, val) {
    let o = p.get('op');
    let e = expression(p);
    if (e === undefined) throw "op: operand missing!";
    switch(o) {
    case '+': return val + e;
    case '-': return val - e; // 5-3*4+3
      // TODO: priorioties??
    case '*': return val * e;
    case '/': return val / e;
    case '^': return Math.pow(val, e);

    case '=': return (val === e) ? -1 : 0;
    case '<': return (val < e) ? -1 : 0;
    case '<=': return (val <= e) ? -1 : 0;
    case '<>': return (val !== e) ? -1 : 0;
    case '>': return (val !== e) ? -1 : 0;
    case '>=': return (val !== e) ? -1 : 0;
    default: syntax_error(o);
    }
  }

  function varr(p, name) {

    function retval(v) {
      if (v !== undefined) return v;
      // default value
      switch(name.substr(-1)) {
	case '%': return 0;
	case '$': return '';
	default: return 0.0;
      }
    }

    let arr_i = p.val('(') && index(p);
    let v = vars[name];
    if (!arr_i) return retval(v);

    // autodim? DIM name(10)
    if (typeof v !== 'object' || !Array.isArray(v))
      v = vars[name] = {};

    // iterate through indices
    let i;
    while (i = arr_i.pop()) {
      if (typeof v !== 'object' || !Array.isArray(v))
	subscript_error();
      v = v[i];
    }
    return retval(v);
  }

  function index(p) {
    if (!p.skip('(')) return;

    let i, a = [];
    while ((i = expression(p)) !== undefined) {
      a.push(i);
      if (!p.skip(',')) break;
    }
    if (!p.skip(')')) syntax_error('MISSING ")"');
    return a;
  }

  // evaluate list of arguments till end of statement, or error
  function evalArgs(p) {
    let a = [];
    let e;
    while (((e = expression(p)) !== undefined)) {
      a.push(e);
      if (!p.skip(',')) break;
    }
    return a;
  }

  function REPEAT() {}
  function UNTIL() {}

  function stop(noprompt) {
    //print('STOPPED!');
    let wasrunning = running();
    if (col > 2) print();
    if (wasrunning) {
      clearInterval(RUN.interval);
      delete RUN.interval;
      if (!noprompt) prompt();
    }
    line = '';
    return wasrunning;
  }
  
  function GOTO(lno) {
    tPos(lno);
    // DOC: Goto given LINENO
    // New: if no line, search next
    lineno = lno-1;

    cont();
  }

  // -- dummies
  function REM() {
    // DOC: REMMARK nice days, isn't?
  }
  // haha thought it was autonum?
  function AUTO() {
    // DOC: CSAVE "fnme", AUTO autoruns!
  }
  // CALL DEEK (#FFFC) ' HARD RESET
  // CALL DEEK (#FFFA2 ' WARM RESTART
  function CALL() {
    error("?WHO'RE YOU GONNA CALL? STEVE?");
  }
  function USR() {
    error('USSR NOT ANSWERING. TRY LATER!');
  }
  
  function FRE() { return FRE.size; }
  FRE.size = 393737; // Atmos 38737;
  // LOL
  function GRAB() { FRE.size *= 2; }
  function HIMEM() { FRE.size *= 2; }
  function RELEASE() { FRE.size *= 2; }
  
  function STOP() {
    cursorHide();
    let lno = lineno;
    let l = line;
    if (stop('noprompt')) {
      if (col>2) print();
      princ(' BREAK IN   '+lineno);
      CONT.lineno = lno;
      CONT.line = l;
      prompt();
    }
    cursorShow();
  }
  
  // WAIT 100 = 1s
  function WAIT(decaseconds) {
  }
  
  function example_VAT() {
    return `
10 REM *VAT Calculation* 
20 INPUT"ENTER SALE PRICE";SELL 
30 LET VAT=0. 15*SELL 
40 LET PRICE=SELL+VAT
50 PRINT "TOTAL=";PRICE 
60 'Round agan for next calculation
70 WAIT 500:CLS:GOTO 20
`;
  }

  function  example_NAME() {
    return `
10 A$="0RIC" 
120 LET Al$="BASI·C" 
130 LET LAST$="LESSON" 
140 INPUT"ENTER YOUR NAME,PLEASE";NAME$ 
150 CLS:PRINT A$;" ";Al$;" ";LAST$ 
160 PRINT "FOR ";NAME$
`;
  }

  function example_KEY() {
    return `
10 PRINT"PRESS A KEY" 
20 GET A$ 
30 PRINT"YOU PRESSED "A$ 
40 PRINT"THE CODE FOR "A$"="ASC(A$) 
50 GOTO 10
`;
  }

  function example_DEF() {
    return`
5 REM*Define Function M to convert feet 
to metres 
10 DEF FNM(FEET)=FEET*0.3048 
20 INPUT"HOW MANY FEET";X 
30 M=FNM(X) 
40 PRINT X;"FEET EQUAL";M;" METRES"
`;
}

  function example_FOR() {
    return `
10 FOR L=l TO 5:PRINT L*L:NEXT L 

10 FOR L=10 TO 5 STEP-l:PRINT L*L:NEXT 

10 CLS 
20 FOR LOOP=0 TO 25 
30 PRINT CHR$(65+LOOP)+CHRS(97+LOOP); 
40 NEXT LOOP 
`;
  }

  function example_READDATA() {
    return `
10 REM*READ o.nd DATA* 
20 FOR 0=0 TO 6 
30 READ D$ 
40 PR1NT D$ 
50 NEXT 
60 REM . . . lots more program 
70 ' 
2000 DATA MONDAY,TUESDAY,WEDNESDAY,THUR 
SDAY 
2010 REM ... more program in between 
3000 DATA FRIDAY, SATURDAY,SUNDAY 
4000 REM .. co.n do it 0.90.in 
4010 RESTORE 
4020 FOR K=l TO 7 
4030 READ DAY$:PRINT DAY$:NEXT
`;
  }

  function example_DIM() {
    return `
10 INPUT"HOW MANY NAMES" ;N% 
20 DIM NAME$(N%):DIM AGE(N%)
30 CLS:SLJM=0 
40 FOR K=1 TO N%
50 PRINT "ENTER NAME t'-10. "K 
60 INPUT NAME$[K]
70 PRINT NAME$[K]"'S AGE ?" 
80 INPUT AGE[K] :SLJM=SLJM+AGE[K]
80 CLS 
100 NEXT K 
110 FOR K=N% TO 1 STEP -1 
120 PRINT :PR1NT NAME$[K]" JS";
130 NEXT K
`;
  }
  
  function example_2DIM() {
    return `
10 DIM NXC10,3) 
20 CLS 
30 FOR K=l TO 10 
40 ~OR J=l TO 3 
50 NxCK,JJ=K"J 
60 PRINT NxCK,JJ 
70 NEXT J 
80 PRINT 
90 NEXT K
`;
  }

  function example_BUBBLESORT() {
    return `
5 REM*NUMERIC BUBBLE SORT** 
10 CLS:LET J=15 'Number of items 
20 DIM NUMCJJ'ATray foT numbeTs 
30 'Example numbers generated here" 
40 FOR K=0 TO J 
50 LET NUMCKJ=RNDC1J*1000 
60 PRINT NUMCKJ 
70 NEXT K 
99 ' 
100 REM*SORT*ROUTINE* 
101 ' 
110 FOR M=l TO CJ-lJ 
120 FOR N=M TO J 
125 REM If correct ordeT 
already,then skip 
130 IF NUMCMJ<NUMCNJ THEN 170 
135 REM Incorrect order,so swap 
140 TEMP=NUMCMJ 
150 NUMCMJ=NUMCNJ 
160 NUMCNJ=TEMP 
170 NEXT N 
180 NEXT M 
189 ' 
190 REM**ENDSORT** 
191 ' 
200 REM *Print sorted list* 
210 CLS:PRINT ''SORTED LIST:" 
220 FOR K::::JTO J 
230 PRINT NUMCKJ 
240 NEXT K 
`;
  }

  // loop is completed, the address is removed, and a subsequent NEXT will 
  // activate a jump to the address now on the top of the pile. The stack can only 
  // hold 10 addresses, and more than 10 loops will give an ?OUT OF MEMOR
  
  function READ() {}
  function DATA() {}
  function RESTORE() {}
  
  // GET K$
  function GET() {}
  function READ() {}
  function DATA() {}

  function ASC(s) {
    // DOC: get ascii number from string
    tString(s, s === '');
    return s.charCodeAt(0);
  }

  function CHR$(n) {
    // DOC: get char from ascii number
    tNum(n, n < 0 || n > 255);
    // TODO: cheat with allo unicode?
    return String.fromCharCode(n);
  }

  function STR$(n) {
    // DOC: make a string from a number
    tNum(n);
    return (n < 0 ? '' : ' ') + n.toString();
  }

  function HEX$(n) {
    // DOC: return #HEX for number
    // Curiosity: return #0 for string
    if (typeof n !== 'number') return '#0';
    tNum(n, n < 0 || n > 65535);
    return '#' + INT(n).toString(16).toUpperCase();
  }  

  function LEN(s) {
    tStr(s);
    return s.length; }

  function LEFT$(s, len) {
    // DOC: From S return LEN first chars.
    tStr(s); tPos(len);
    return  s.substring(0, len);
  }    
  function RIGHT$(s, len) {
    // DOC: From S return LEN last chars.
    tStr(s); tPos(len);
    return  s.substr(-len);
  }

  function MID$(s, pos, len) {
    // DOC: From S from POS get LEN chars
    tStr(s); tPos(pos); tPos(len);
    return s.substr(s, from, len);
  }

  function SPC(n) {
    tPos(n);
    return ' '.repeat(n);
  }
  
    
  function VAL(s) {
    // Oric: doesn't even need to terminate "string in PRINT, but in VAL("FOO   have to...
    
  }    
  
  // REM comment
  // ' commment
  function REM() {}

  // ---------------- MATH
  // NOTE: All math (even I%+1) is performed
  // using floating numbers, only when LET
  // is the quantity checked
  //
  // + - * / ^
  //   / == div_error()... check...
  
  // Oric BASIC has the following built-in numeric functions: 

  HELP.related.push('ABS INT'); {
    ABS = Math.abs;
    function INT(n) {
      // DOC: Removes the decimals
      // (it may not fit into I%)
      tNum(n);
      return Math.floor(n);
    }
    SGN = n=>(n>0)?+1:(n<0)?-1:0;
  }

  HELP.related.push('EXP LN LOG ^'); {
    EXP = Math.exp;
    LN = Math.ln;
    LOG = Math.ln10;
  }

  HELP.related.push('PI SIN COS ATN TAN'); {
    ATN = Math.atan;
    COS = Math.cos;
    PI = Math.PI;
    HELP.PI = `
// DOC: Mathematical pi
`;
    SIN = Math.sin;
    TAN = Math.tan;
  }

  HELP.related.push('TRUE FALSE AND OR NOT'); {
    TRUE = -1;
    HELP.TRUE = `
// DOC: True value
// (actually -1 == all bits set!)
`;

    FALSE = 0;
    HELP.FALSE = `
// DOC: False value
// (actually 0 == all bits zero!)
`;

    function AND(a, b) {
      // DOC:And two expressions
      // (bitwise 'and' 2 values)
      // Related: AND OR NOT TRUE FALSE
      return a & b;
    }
    function OR(a, b) {
      // DOC: Or of two expressions
      // (bitwise 'or' 2 values)
      // Related: AND OR NOT TRUE FALSE
      return a | b;
    }
    function NOT() {
      // DOC: Not and expression
      // negate all bits (0 <=> -1)
      // Related: AND OR NOT TRUE FALSE
      return ~a;
    }
  }

  SQR = Math.sqrt;

  // TODO: neg seeds!
  // TODO: find original algrithm
  function RND(n) {
    // DOC: RND(0) - random number [0, 1[
    // TOOD:
    // RND(-N) always starts same sequence
    tNum(n);
    if (n < 0)
      error('?RND(-SEED) not implemented');
    //if (!n)
    return Math.random();
    //return Math.floor(n * Math.random());
    // Too bad it's not there... lol
  }

  // tested by means of conditional operators: 
  // Equal to 
  // <> Not equal to 
  // > Greater than 
  // < Less than 
  // >= Greater than or equal to 
  // < = Less than or equal to 
  // These operate much as you would expect for numeric values. Two things 
  // need to be remembered, however. The fir

  // 10 DEF FNMCFEETJ=FEET*0.3048 
  //function DEFFN(n, exp) {}

  function example_ONGOTO() {
    return `
10 l NPUT" ENTER 1 .. 2 OR 3_, PLEASE' ' ;N 
20 ON N GOTO 150,200,300 
140 RP1 
159 PRINT "LINE 150 FROM N=J";GClTO 10 
190 REM 
200 PRINT "LINE 200 FROM N=2":GOTO 10 
290 REM 
300 PRINT "LINE 300 FROM N=3" :GOTO 10
`;
  }

  // https://osdk.org/index.php?page=articles&ref=ART9.
  
  // So if the first byte of the screen (#BB80), contains the value 65 (ASCII code for the upper case A letter), we know that this block of 6x8 pixels will be filled with graphical information stored at the address #B400+(8*65).

/* special addresses:
some may be considere "simulated"

--- KEYS
$17 Set to 1 if CTRL C pressed, otherwise 0. 
$35-$84 Input buffer. (79 bytes) 
$208 Key address if pressed — #38 if no key pressed. 
$209 Key status, 
 #38 - Default, 
 #A2 - CONTROL, 
 #A4 - Left SHIFT, 
 #A5 - FUNCTION (Atmos only), 
 #A7 - Right SHIFT. 
$20A Saved key column for repeat. 
$20C Bit 7 is set if CAPS is on otherwise clear. 
$20D 
$20E Repeat counter for keyboard. 
$20F 
$210 Temporary store of row of key being tested for repeat. 
$211 Temporary store of keyboard row during strobe routine. 

--- TEXT
$12,$13 Address of text cursor. 
$2E CTRL O flag. 0 if output to screen enabled.$30 Cursor position for Basic printout. 
$31 Screen line width. 
$32 8 - multiple line width. 
$21F 0 - LORES, 1 - HIRES. 
$23B-$23D Jump to GET KEY routine (V1.1). 
$23E-$240 Jump to SEND BYTE TO PRINTER (V1.1). 
$241-$243 Jump to PRINT TO STATUS LINE (V1.l). 
$24E Keyboard initial repeat deiay (V1.l). 
$24F Keyboard successive repeat delay (V1.1). 
$250 
$251 Cursor enabie in CTRL routines (Vl.l).
$256 Printer width (Vl.l). 
$257 Screen width (Vl.l). 
$258 Printer cursor position (V1.1). 
$259 Screen cursor position (V1.1). 
$265 Current cursor state indicator, 0 - off, 1 — on. 
$266,$267 
$268 Cursor row number, (status line is row 0).
$269 Cursor column position. 
$26A Flag byte. 
 Bit Flag function when bit is set to 1. 
 0 Cursor on. 
 1 Printout to screen enabled. 
 2 Unused. 
 3 Disable keyciick. 
 4 Previous printed character was ESC 
 5 Protect columns 0 and 1 of screen. 
 6 Double height characters. 
 7 Unused. 
$26B Paper colour (+16). 
$26C Ink colour. 
$26D,$26E Start address of screen memory. 
$26F Number of text lines available on screen (V1.0). 
$270 Cursor on/off flag. 
$271 Cursor invert flag. 
$272,$273 Keyboard timer. 
$274,$275 Cursor timer. 
$278,$279 Address of second line on screen (V1.1). 
$27A,$27B Address of first line on screen (V1.1). 
$27C,$27D Number of characters normally used in screen scrolling, 
26 x 40 – 1,040 or #410 (V1.1). 
$27E Number of rows of text available (V1.1). 
$2C0 Screen status, 0=GRAB, 2=TEXT and 3=HIRES.

--- HIRES
$10,$11 Address of hires cursor. 
$A6,$A7 Himem. 
$212 Holds FB code in hires commands. 
$213 Pattern data for hires screen. 
$214 Temporary copy of pattern byte for drawing lines. 
$215 Holds position of pixel in byte corresponding to position of 
cursor on hires screen. 
$216,$217 Temporary store of hires X and Y cursor positions. 
$218 Temporary store for content of $215. 
$219 Hires cursor — X coordinate. 
$21A Hires cursor — Y coordinate. 
$21F 0 - LORES, 1 - HIRES. 
$2C0 Screen status, 0=GRAB, 2=TEXT and 3=HIRES.$2C1,$2C2 Char set start address in HIRES mode (V1.1). 
$2C3 Cursor movement in hires, 0 = Absolute, 1 = 
$2DF Latest key from keyboard. Bit 7 set if valid. 
$2E0 Non zero if error in Sound / Graphics routines. 
$2F1 Bit 7 set to 1 if printer enabled. 
$2F2 Bit 7 is EDIT flag, set to 1 when on. 
$2F4 TRACE flag, set if bit 7 is set. 

--- PROGRAM
$A8,$A9 Current line number, top byte is #FF if in command mode. 
$AA,$AB Previous line number. 
$AC,$AD Last line start address. 
$AE,$AF Temporary copy of line number. 
      
$B4,$B5 Last variable name accessed. 
$B6,$B7 Address of last variable value accessed
$E9,$EA Position pointer in program. 
$252 ELSE pending flag, 1 - on, 0-off (Vl.l). 
$253-$255 
$2F5,$2F6 Indirect jump for '!' routine. 
$2FB-$2FD Jump to '&' routine. 


--- HARDWARE
$220 0 - 48K Oric, 1 - 16K Oric. 
$228-$22A Jump to IRQ routine (V1.0). 
$22B-$22D Jump to NMI routine (V1.0). 
$244-$246 Jump to IRQ routine (Vl.l). 
$247-$249 Jump to NMI routine (Vl.l). 
$24A—$24C RTI instruction which can be intercepted by a jump (Vl.l). 
$230 RTI instruction (V1.0). 

$21—$23 Jump location for USR command. 

--- INTERNAL
      
$18,$19 Tokenising pointer. 
$1A—$1C Jump location to print 'Ready'. 

$C3—$C5 Jump location to evaluate numeric functions. $C5 also used as a 
temporary store of the rounding byte for mathematical operations. 

$E2—$F2 Routine to step through program to find next non space char. See 
$EC9C of disassembly. 

$20B Not used but gets written over by routine that sets $208 - $20A. 

$238-$23A Jump to PRINT CHARACTER on screen (V1.1).
$24D Tape speed, 0 - fast, 1 - slow (Vl.l). 

$261,$262 Indirect jump for CTRL character routine.
$263,$264 Temporary storage. 
$276,$277 Spare counter — also used by WAIT (and printer in V1.0). 
*/

  example_TIMER =`
9 REM *** PRINTS THE CURRENT TIMER IN HECTOSECONDS
10 LET D=DEEK(630)
20 PRINT D
30 STOP
`;

  HELP.related.push('PEEK POKE DEEK DOKE SCRN'); {
    // LOCAL VARS USED FOR PEEK/DEEK etc 

    const SCREEN = 0x0BB80;
    const SCREEN_LEN = SCREEN_ROWS * SCREEN_COLS;
    //const SCREEN_LEN = 1120;
    const CHARS = 0xB400;
    const CHARS_LEN = 1024;
    const ALTS = 0xB800;
    const ALTS_LEN = 896;

    const HIRES = 0xA000;
    const HIRES_LEN = 8000;
    const HIRES_TEXT = 0xBF68;
    const HIRES_TEXT_LEN = 120;

    // TODO: charset moves?
    const HIRES_CHARS = 0x9800;
    const HIRES_CHARS_LEN = 1024;
    const HIRES_ALTS = 0x9C00;
    const HIRES_ALTS_LEN = 1024;    
    
    function PEEK(a, v) { // LOL
      tPos(a);
      print(`PEEK ${a} ${v} ${HEX$(a)}`);

      if (a === 0x276) return DEEK(0x276) % 256;
      if (a === 0x277) return INT(DEEK(0x276) / 256);

      // DOC: Read memory byte at ADDR
      // Simulator: only screen memory value!
      if (hires())
	error('?PEEK/POKE not defined for HIRES mode');
	
      if (a >= SCREEN &&
	  a <= SCREEN + SCREEN_LEN) {
	let o = a - SCREEN;
	print(`PEEK in screen o = ${o}`);
	// TODO: this may overlap! LOL
	let row = INT(o / SCREEN_COLS);
	print(`PEEK in screen row = ${row}`);
	let col = o % SCREEN_COLS;
	print(`PEEK: row=${row} col=${col}`);
	let x = screen(row, col, v);
	print(`PEEK: => ${x}`);
	return  x;
      }

      // easter egg!
      return PEEK(
	(a % SCREEN_LEN) + SCREEN, v);

      error('?PEEK/POKE not defined for this address');
    }
    function POKE(a, v) {
      tPos(a); tPos(v, v < 256);

      if (a === 0x276) return deek276 = (deek276 & 0xff00) + v;
      if (a === 0x276) return deek276 = (deek276 & 0x00ff) + v*256;
      // DOC: Set memory ADDR byte to VAL
      // Simulator: only screen access!
      PEEK(a, v); // LOL
    }

    let deek276 = 0;
    function DEEK(a, v) {
      tPos(a);
      // timer hs (10ms)
      if (a === 0x276) {
	// reset?
	if (typeof v === 'number')
	  doke276 = v;
	return 0x10000 - INT(
	  Date.now()/10 - deek276)
	  % 0x10000;
      }
      
      return 256*PEEK(a+1) + PEEK(a);
    }

    function DOKE(a, v) {
      tPos(a); tPos(v, v < 655356);
      if (a === 0x276) return DEEK(a, v);
      POKE(a, v % 256);
      POKE(a+1, INT(v / 256));
    }
  }
  
  /* (ASCII A) which is (in decimal) 46600. Try the following program which POKES new values into these locations and then PRINTS an A. The A should appear as an italic A because we have now redefined the way Orie draws an A. Try switching to HIRES mode and use CHAR to place an A on the screen to prove that the characters have been copied down correctly.*/
  
  // jsk: Just got an IDEA!
  // 1. whenever poked in letter 'X'
  //    (chardef area)
  //    - record it
  // 2. when "done" (subjective)
  //    - creata an svg put in
  //      SPRITE[hex(chardef)] = svg
  //      CHAR2SPRITE['X'] = hex(chardef)
  // 3. in screen replace every 'X'
  //
  // gif: will work
  // svg symbol: can they be redefined?

  example_CHARDEF = `
10 FOR A=0 TO 7 
20 READ B 
30 POKE 46600+A,B 
40 NEXT 
50 DATA 14,17, 17,17,62,34,34,0 
`;

  function OLD() {
    // DOC: New: Get old program back
    if (OLD.stack.length)
      lines = OLD.stack.pop();
    else
      print('?NOTHING TOO OLD');
  }
  OLD.stack = []; // don't clean

  function NEW() {
    // DOC: Delete currerent program
    // New: use OLD to get it back...

    // TODO: ask if program is dirty...
    // maybe autosave?
    stop(true);
    OLD.stack.push(lines);
    lines = {};
  }
  
  // TODO: load basic from any URL!
  // CLOAD "filename" [,S] 
  // CLOAD "" [,S] - search/list
  // CLOAD "filename", J [,S] - join! 
  // CLOAD "filename", V [,S] - verify
  // TODO: add DIR()
  // TODO: remember name
  // TODO: add versions
  function CLOAD(name, info) {
    // DOC: Loads a file "NAME"
    // New: Without arguments lists examples
    // New: With 'CLOAD D' shows names with 'D'
    if (!name) name = '';
    
    let origline = this;
    function load(src) {
      if (!src) return;
      NEW();
      let name = beautyname(names[0]);
      print('Program ' + name + ' loading...');
      let n = 0;
      ('\n'+src).replace(
	/\n\s*(\d+)(.*)/g,
	(_, lno, l)=>{
	  saveline(+lno, l);
	  if (trace) { princ(+lno); print(l); }
	  n++;
	});
      princ(n); print('lines loaded');
      if (origline.match(/,\s*AUTO/)) RUN();
      return true;
    }
    
    // get names from window
    let names = Object.keys(window)
	.filter(n=>n.startsWith('example'));
    // add names from localstorage
    names = names.concat(lssearch('CSAVE:'));

    // filter matches
    if (name) {
      if (name.match(/^".*"/))
	names = names.filter(
	  n=>n.match(RegExp(
	    `^CSAVE:${name.replace(/"/g,'')}\$`)));
      else
	names = names.filter(n=>n.match(name));
    }

    // names are now "ugly" use this to show
    function beautyname(n) {
      return n
	.replace(/^example_+/, '')
	.replace(/^CSAVE:(.*)/, '"$1"');
    }
      
    // to load (instead of list, require match  to be proper prefix)
    if (trace) { print("NAMES:"); print(names); }
    
    name = name.replace(/"/g,'');

    if (names.length == 1 &&
      names[0].match(RegExp(`^(?:example_*|CSAVE:)${name}`))) {
      let src;
      
      // try load from examplesNAME...
      src = window[names[0]];
      if (src) {
	// ok, it's not a string?
	if (typeof src === 'function') try {
	  src = src();
	} catch(e) {}
      }

      // try localStorage
      if (!src)
	src = lsget(names[0]);

      if (load(src)) return;
    }

    // all else (and no return is:)
    if (name)
      print('?CLOAD NAME ERRROR');

    // list'em
    print("Matching names:");
    print();
    names
      .map(beautyname)
      .forEach(n=>(princ(n), TAB("3")));
    print();
  }
  
  // For the HIRES screen: 
  // CSAVE"filename",A40960,E48000 (48K)
  // CSAVE"filename",A8192,EIS232 (16K)
  //
  // For the TEXT and LORES screens: 
  // CSAVE"filename",A48000,E49119 (48K)
  // CSAVE"filename",Al5232,El635l (16K)
  //
  function CSAVE(name, opt) {
    // DOC: Save program lines
    // foo - in localStorage
    // TODO: Implement AUTO
    // TODO: "foo.tap" - download
    // TOOD: load/save memory (screens)
    if (!name) name = '';
    if (opt) return save_error('USING '+opt);
    name = name.replace(/"/g, '');
    if (name.match(/^\w+/)) {
      let src = Object.keys(lines)
	  .map(lno=>`${lno} ${lines[lno]}\n`)
	  .join('');
      let lns = src.match(/\n/g).length;
      if (trace) print(src);
      lsput('CSAVE:' + name, src);
      princ(lns); 
      print('lines saved in ' + name);
    } else {
      save_error('BAD NAME: '+name);
    }
  }

  function STORE() {}
  function RECALL() {}
  
  function example_TAB() {
    return `
10 FOR 1=0 TO 5 
20 PRINT TAB(I); "HELLO" 
30 NEXT I 
HELLO 
HELLO 
 HELLO 
  HELLO 
   HELLO 
    HELLO
`;
  }
  
  // sounds
  // https://bulba.untergrund.net/emulator_e.htm
  // The PLAY command allows you to mix tones and gives access to eight preset envelope shapes.
  // After using MUSIC and SOUND to set channel and select the tones and noise you want, you use PLAY to mix the channels, select an envelope and control the duration of the final sound. In this way, quite complex sounds can be built up even considering the limitations of the single voice and the pre-set envelopes. The three main sound commands can be used in programs written in
  /* 
PLAY BASIC Token: 169
Format: PLAY t, s, e, d

t=tone channel 0-7 (bit value 111)
s=sound channel 0-7 (bit value 111)
e=envelope 0-7
d=duration 0-32767

This is one of the Oric's rather complex sound commands which, once you get used to them, offer a music/sound potential well in advance of the machine's competitors. However, the commands are a little difficult to grasp, particularly if you're not musically minded, so it is well worth spending some time working your way through Chapter 7. For the present we will restrict ourselves to clarifying the format of the command. 
Your Orie is endowed with three sound/tone channels and PLAY is the command which determines the combination of these channels. In terms of the command format at the top of the page, t (tone) ands (sound) determine which channels are activated (0--7). The effects of the combination of channels is really only comprehensible· after a little experimentation, but the following chart will be of some use for future reference.

The column on the left represents the value oft or s, whilst the righthand column tells you which combination of channels are activated by this value. 

channel combination
0 no channels I
1 2 2 3 1and2 4 3 s 1and3 6 2and3 7 1, 2 and 3 


*/
  example_CHORD = `
90 REM*** CHORD *** 
99 PLAY 7,0,0,0 
100 MUSIC 1,4,1,5 
110 MUSIC 2,4,5,5 
120 MUSIC3,4,8,S 
140 STOP
`;
  
  example_ANDROID = `
5 REM *** ANDROIDS *** 
10 A=l 
50 REPEAT 
60 LET A=A+l 
90 READ X,Y 
100 PLAY 3,0,0,0 
110 MUSIC 1,1,X,6 
120 MUSIC 2,4,Y,5 
140 WA1T 15 
150 UNTIL A=193 
160 RESTORE
170 GOT0 10 
1000 DATAl, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8,8, 1,8,8,8, 1,8,8,8,3,6, 10,5,3,3, 10,3 
1010 DATA 1, 10, 8, 10, 1, 10, 8 , 10, 1, 8, 8, 8, 1 ,8,8,8,1,8,8,8,1,8,8,8 
1020 DATA 3,3, 10,5,3,6, 10,6, 1, 10,8, 10, 1 ,10,s,10
1030 DATA 1,8,8,8,1,8,8,8,1,8,8,8,1,8,8,8,3,3, 10,5,3,3, 10,3 
1040 DATA 1,1,8,1,·1,1,8,l,l,l,8,l,l,l,8 , 1, 1, 1,8, 1, 1, 1,8, 1, 1, 1,8, 1, 1, 1,8, 1 
1050 DATAl,8,8,8, 1,8,8,8, 1,8,8,8, 1,8,8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 3, 6, 10, 5, 3, 3, 10, 3 
1060 DATA 1, 10, 8, 10, 1, 10, 8, 10, 1, 8, 8, 8, 1 ,8,8,8, 1,8,8,8, 1,8,8,8 
1070 DATA 3, 3, 10, 5, 3, 6, 10, 6, 1, 10, 8, 10, 1 ,10,8,10 
1080 DATA 1,8,8,8,1,8,8,8,l,8,8,8,l,8,8 
,8,3,3, 10,5,3,3, 10,3 
1085 DATA 1,1,8,l,1,l,8,l,l,l,8,l,l,l,8,1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 8, 1 
1090 DATA 3, 3, 10, 3, 3, 3, 10, 3, 5, 5, 12, 5,5,5,12,5 
2000 DATA 6,6,1,6,6,6,1,6,1,l,8,1,1,l,8,1 
2010 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2020 DATA 6,6,1,6,6,6,1,6,1,1,8,1,1,1,8,1 
2030 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2040 DATA 6,6,1,6,6,6,1,6,1,1,8,1,1,1,8,l 
2050 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2060 DATA 6,6,1,6,6,6,1,6,8,8,~,8,8,8,3,8
`;
  function PLAY(channels, noise, envelope, duration) {
    // DOC: "shape" of the sound:
    // CHANNELS 0-7 : 1 (1st) + 2 (2nd) + 4 (3rd)
    // ENVELOPE 0--7 shape, see below
    // DURATION 0--32767
    // _ banjo  : env 1, dur 1000
    // _ machine: env 6, dur 19
    
    // Tip: PLAY 0,0,0,0 'OFF
    // Note: MUSIC C,3,4,0 '0 = Use envelope
    // Envelopes (firist shape same length)
    // 1 |\             "slow-die"
    // 2 /|             "slow-start"
    // 3 |\    |\|\ ... "saw"
    // 4 /\    /\/\ ... "sine"
    // 5 |\|~  ~~~~ ... 
    // 6 /|    /|/| ... "saw"
    // 7 /     ~~~~ ... "slow-start"
    
    // TODO: noise! channels > 
    // channels noise envelope duration

    // PLAY 0,... ' all off
    if (!channels)
      return sounds('0v0 1v0 2v0 3v0');

    let c = 1;
    for (let b=1; b<8; b*=2) {
      let e = channels & b;
      PLAY['con'+c] = e;

      // If enabled start saved stuff
      if (e) 
	sounds(PLAY['c'+c] || '');
      else
	sounds(`${c} v0`);
      i++;
    }
  }

  example_PLAY = `
l REM ***PLAY***
5 CLS
10 CLS:PRINT:PRJNT
20 INPLUT"ENTER NUMBER (0-7) FDR SOUND SHAPE"; E
30 IF E<0 DR E>7 THEN 20
40 INPUT "ENTER A NUMBER (0-65535) FOR DURATION"; O
50 PRINT "THIS IS SOUND ENVELOPE "; E; " WITH A "; O; " DURATION"
60 SOUND 1, 1500, 0
70 PLAY l, 0, E, D
80 PRJNT "PRESS ANY KEY TO STOP PLAY"
90 GET A$: GOT0 5
`;

  // on Xiaomi A4 note+ it plays 3s
  // original oric about 6s
  example_CHROMANG = `
10 REM CHROMATIC (WITHOUT FOR)
20 LET I=0
25 PLAY 1,0,0,0
30 LET O=INT(I/12)
35 IF O-6 THEN 40 ELSE GOTO 100
40 LET N=INT(I-O*12)+1
45 MUSIC 1,O,N,2
50 PRINT O, N
60 LET I=I+1
70 GOTO 30
100 PLAY 0,0,0,0
  `;
  
  example_CHROMATIC = `
l REM *** CHROMATIC SCALE *** 
5 CLS 
10 PAPER 5 
20 FOR 0=0 TO 6 
30 FOR N=l TO 12 
40 MUSIC 1,0,N,10 
50 WAIT 30 
60 NEXT N 
70 NEXT 0 
75 END 
`;

  example_KEYBOARD =`
10 REM *** KEYBOARD ***
11 PRINT "0 1 2 .. - = /"
20 GET A$
30 A=VAL(A$)
40 IF A$="- " THEN A=11
50 IF A$="=" THEN A=12
60 IF A$="/" THEN PLAY 0,0,0,0: STOP
70 IF A=0 THEN A=10
80 MUSIC 1, 3, A, 8
85 WAIT 20: PLAY 0,0,0,0
90 GOTO 20 
`;
  
  HELP.related.push('SOUND MUSIC PLAY');
  
  function MUSIC(c, o, n, v) {
    // DOC:Make music using:
    // CHANNEL 1--3
    // OCTAVE 0--7
    // NOTE 1--12 see below
    // VOLUME 0--15
    // Imagine a piano keyboard:
    // _   2   4       7  9   11
    // | |C# |D# | | |F# |G# |A# | |
    // | |   |   | | |   |   |   | |
    // | \-------/ | \-----------/ |
    // |   |   |   |   |   |   |   |
    // | C | D | E | F | G | A | H |
    // \---------------------------/
    // _ 1   3   5   6   8  10  12
    tPos(c, c < 1 || c > 3);
    tPos(o, o > 6);
    tPos(o, n < 1 || n > 12);
    tPos(v, v > 15);
    v = INT(100 * v / 15) / 100;
    // we need to save it for PLAY
    let seq = PLAY['c'+c] =
	`${c} o${o} n${n} v${v}`
    // only play if channel enabled with PLAY
    if (PLAY['con'+c]) sounds(seq);
  }

  example_WAVES = `
l80 REM*** WAUES *** 
181 REM page 106
200 PLAY 0, 1.•0,0 
205 Z=NT(RND(1)*20)
210 FOR I=0 TO 31
220 SOUND 4,I,7 
230 WAIT Z
240 NEXT I 
250 GOT0 205
`;
  
  function SOUND(c, p, v) {
    // DOC: Make pitch (X/freq) and noise
    // CHAN:1--3 + 4 (noise!)
    // PITCH: 0--65536 X/freq
    tPos(c, c > 7);
    tPos(p, p < 65536);
    tPos(v, v > 15);
    if (c > 3)
      throw "SOUND: doesn't support noise yet!";
    v = INT(100 * v / 15) / 100;
    const MAGIC = 30800;
    let f = INT(MAGIC / p);

    // we need to save it for PLAY
    let seq = PLAY['c'+c] =
	`${chan} v${vol} f${f}`;
    // only play if channel enabled with PLAY
    if (PLAY['con'+c]) sounds(seq);
  }

  HELP.related.push('PING ZAP EXPLODE SHOOT SOUND');

  function ZAP() {
    sounds('[oric_zap]');
    // TODO: wait as long as it takess to
    // play like he original..
  }
  function PING() {
    sounds('[oric_ping]');
    // thisone doessn't block
  }
  function SHOOT() {} // "snare-drum"
  function EXPLODE() {}


</script>

<script>
  function rand(n) {
    return Math.floor(Math.random()*n);
  }
  
  TEXT();

  boot(); //run('boot'); prints prommpt
  prompt();

/*
var svgns = "http://www.w3.org/2000/svg";
for (var x = 0; x < 5000; x += 50) {
    for (var y = 0; y < 3000; y += 50) {
        var rect = document.createElementNS(svgns, 'rect');
        rect.setAttributeNS(null, 'x', x);
        rect.setAttributeNS(null, 'y', y);
        rect.setAttributeNS(null, 'height', '50');
        rect.setAttributeNS(null, 'width', '50');
        rect.setAttributeNS(null, 'fill', '#'+Math.round(0xffffff * Math.random()).toString(16));
        document.getElementById('svgOne').appendChild(rect);
    }
}

  */

  // TODO: remove svg experiments!
  if (0) {
  screen(
    1,5,'A', charA=`
<div style='top:1.55px; position:absolute; max-width:10px; max-height:142px; overflow:visible; zoom:1;'>
<svg viewBox="0 0 6 8" xmlns="http://www.w3.org/2000/svg" style='background:white'
xmax-width:10px; xmax-height:10px;'
width='10px' height='12px'>
  <use xlink:href='#A'>
</svg>
<div>
`);
  screen(1,2,'A', charA);
  screen(2,2,'A', charA); screen(2,3,'A', charA)
  screen(3,2,'A', charA);
  }  
  // js: create rect
  // - https://stackoverflow.com/questions/32985564/how-to-style-manipulate-contents-of-svg-use-element
  
  if (0)  window.onerror = function(message, url, line, col, errorObj) {
    dom('error', `WINDOW.ERROR:
message  : ${message}
url      : ${url}
line     : ${line}
col      : ${col}
errorObj : ${errorObj}
`);
  }

  let lastrun = 0;
  setInterval(_=>{
    dom('line', line);
    dom('row', row);
    dom('col', col);
    dom('vars', JSON.stringify(vars));
    
    dom('stats', 'Statements: '+run.count+
	' sps= ' + Math.floor(1000*(run.count-lastrun)/(cont.millis)) +
	' scoff= ' + scoff);
    lastrun = run.count;
    
  }, 100);
  // clear initial error
  dom('error', '');
  
  function clickSound(special) {
    editChar.n = ((editChar.n || 0) + 1)%20;
    let named = special ?
	'[oric_okey]' : '[oric_key]';
    if (click) {
      sounds('' + (editChar.n+3) + named);
      // compatible keysound, turn off vol of 1
      sounds('1v0');
    }
  }

  function editChar(ch) {
    clickSound();
    cursorHide();
    let c = String.fromCharCode(ch);
    // ignore keyboard setting
    if (caps)
      c = c.toUpperCase();
    else
      c = c.toLowerCase();
    line += c;
    putc(c.charCodeAt(0)); // lol

    cursorShow();
  }    

  function INVERSE(...args) {
    // DOC: New: Inverse part of the screen
    // New: INVERSE row, col, len
    // New: INVERSE "STR"
    // New: INVERSE ' - turns off all

    let lochar = c=>String.fromCharCode(c.charCodeAt(0)&0x7f);
      
    if (args.length === 0) {
      fill(0, 0, SCREEN_ROWS, SCREEN_COLS,
	   (r,c)=>{
	     let ch = screen(r, c);
	     let c7 = ch & 0x7f;
	     if (c7 !== ch) screen(r, c, c7);
	   });
    } else if (args.length === 3) {
      let [r,c,len] = args;
      // set hibit
      for(let i=0; i<len; i++)
	screen(r, c+i, screen(r, c+i)|0x80);
    } else if (args.length === 1) {
      let s = args[0];
      let len = s.length;
      // protect regexp chars
      s = s.replace(/([^\w])/g, '\\$1');

      for(let r=1; r<SCREEN_ROWS; r++) {
	getScreenLine(r).replace(
	  RegExp(s, 'g'), (a,i)=>
	    INVERSE(r, i, len));
      }
    }
  }

  function doAction(action) {
    INVERSE();

    // go one down line
    print();

    try {
      if (action.www)
	return urlView(action.www);
      else if (action.linktext) {
	// TODO:
      } else if (action.button)
	return run(action.button);
    } catch (e) {
      alert('doAction.error: ' + e + '\n' +
	    e.stack);
    }
  }

  // only return match if cursor at it
  function atmatch(s, re, dbg) {
    let res;
    s.replace(RegExp(re, 'g'), (a,m,i)=>{
      if (i <= col && col <= i+m.length)
	res = m;
      if (dbg) alert('atmatch: i='+i+' m='+m);
    });
    return res;
  }

  function findAction() {
    try {

      // TODO: use alt inverse so we don't deastroy inverse on the screen by user
      INVERSE();
      let r = xfindAction();
      if (r) {
	if (r.linktext) {
	  let id = `${wget.pageid} ${r.linktext}`;
	  let url = wget.url[id];
	  //alert('Lookup '+r.linktext+'\n='+url);
	  if (url) {
	    r.www = url;
	  } else {
	    // partial match...
	    let re = RegExp(
	      r.linktext.replace(/([^\w])/g, '\\$1'));
	    let mk = Object.keys(wget.url)
		.filter(k=>k.match(re));
	    if (!mk.length) {
	      r.msg = 'link not matched';
	    } else if (mk.length == 1)
	      r.www = wget.url[mk[0]];
	    else { // choices
	      //r.msg = 'too many matches';
	      //r.www = m[0]; // what the heck
	    }
	  }
	  
	  if (r.www) r.type = 'WWW';
	}

	// fix url (if all uppercase)
	if (r.www) {
	  if (r.www === r.www.toUpperCase())
	    r.www = r.www.toLowerCase();
	}

	let txt = r.button || r.www || r.msg;
	if (!txt) {
	  txt = Object.keys(r).filter(
	    k=>k.match(/(www|button|linktext)/))
	      .map(
		k=>`${k.toUpperCase()} ${r[k]}`).join('');
	}

	txt = r.type + ' ' + txt;
	clearline(0);
	iplot(0, 0, txt.substr(0, SCREEN_COLS));

	INVERSE(r.hilite);
      }
      return r;

    } catch(e) {alert(e);}
  }
  function xfindAction() {
    // TODO:
    // - CTRL-U should go to top bar and
    // - show current URL, return there
    // - should go to it

    let ln = getScreenLine(row, 'nohi');

    // - [!WWW 1 3] - button
    let button = atmatch(
      ln,
      /(\[!{0,1}[^\]]+\])/);
    if (button) return {
      button: rget(button, /\[!{0,1}(.*)\]/)[0],
      hilite: button,
      type: 'button',
    };

    // - blue link name under cursor
    // (ok this is sketchy: 'blue')
    // (what if change markup?)
    // match till next attr
    // '\4link\4link\0'
    // TODO: attr inside linktext
    let linktext = atmatch(
      ln, /(?<=\4)\s*([^\0-\37]{2,})\s*[\0-\037]/);
    if (linktext) return {
	type: 'linktext',
	linktext,
	hilite: linktext,
    }

    // try till EOL
    linktext = atmatch(
      ln, /\4\s*([^\0-\37]{2,})\s*$/g);
    if (linktext) return {
      type: 'linktext',
      linktext,
      hilite: linktext,
      partial: true,
    }

    // - under/before around current cursor
    let atCursor = atmatch(
      ln, /([^\0-\37\s]{3+)/);
    if (atCursor) {
      // - url under cursor (more strict)
      let [url] = rget(
	atCursor,
	/\b([\w\.\/\?:&=\+%\-\"\'!\$~@#\^\*_]{3,}[^\.])\b/i);
      if (url && url.match(/\S\.\S/))
	return {
	  type: 'WWW',
	  www: url,
	  hilite: url,
	};
    }

    // nothing
    return;
  }

  function editEnter() {
    // DOC: Run line buffer command
    // New: If emtpy find [button] at cursor or URL
    cursorHide(); // turned on by run/stop
    if (line) {
      print();
      // TODO: right place? lol
      // (we hide it in case of error)
      dom('exp').value = line;
      // run turns on cursor if appropriate
      // and not if background running
      run(line);
      line = '';
      return;
    } else {
      let action = findAction();
      if (action)
	return doAction(action);
    }
    print();
    cursorShow();
  }

  // basically make other arguments splittable
  function quoteStrings(line) {
    return line.replace(
      /\".?\"/g,
      s=>s.replace(/!/g, '!!')
	.replace(/ /g, '!s!')
	.replace(/'/g, '!q!')
	.replace(/:/g, '!c!')
      	.replace(/\(/g, '!po!')
        .replace(/=/g, '!e!')
        .replace(/,/g, '!com!')
    );
  }
  function unquoteStrings(line) {
    return line.replace(
      s=>s.replace(/!c!/g, ':')
	.replace(/!s!/g, ' ')
      	.replace(/!po!/g, '(')
        .replace(/!pc!/g, ')')
        .replace(/!e!/g, '=')
        .replace(/!q!)/g, "'")
        .replace(/!com!)/g, ',')
	.replace(/!!/g, '!'));
  }

  function prompt(noprompt) {
    if (!noprompt) {
      // why was added? because break?
      //if (col > 2)
      print();
      print('Ready');
    }
    cursorShow();
  }

  // interprets and runs one line
  // returns true if ok
  // END return false
  function run(line) {
    // special commands
    if (line.match(/^\S+\.\S/))
      return urlView(line);
    // TODO: [button]?
    // TODO: NAME [.COM] (any file...)
    // TODO: !EXTNAME [.COM] (new funcs)

    let toks = tokenizer(line, ORIC_TOKENZ);
    if (trace) {
      princ('TOKENS:');
      print(JSON.stringify(toks, null, 2));
    }
    
    line = line.trim();

    // remove leading ':' (used for indent!)
    line = line.replace(/^[\s:]*/, '');

    // TODO: remove ll cursorShow from here...
    
    // fast comments
    // TODO: inncorrect REM is a statement...
    //   PRINT 33 : REM foo
    //   PRINT 33 ' foo
    if (line.match(/^(REM|')/))
      return (cursorShow(), 'REM');
	
    if (!line || line === '')
      return (cursorShow(), '');

    // NN PRINT ... new line?
    // New: retains initial spacing! lola
    let linedef = line.match(/^\s*(\d+)(.*)$/);
    if (linedef) {
      saveline(+linedef[1], linedef[2]);
      return (cursorShow(), 'EDIT');
    }

    line = line.trim();
    let orig = line;

    // ok, we have command  to execute
    line = quoteStrings(line);

    // TODO: incorrect as F!
    // if (1) THEN ?3:?4 ELSE ?5 : ?6 : ?7
    //   ORIC => 3 4 6 7
    if (trace) print('LINE: ' + line);
    if (0) {
      let many = line.split(':');
      if (trace) print('MANY: ' + many.length);
      // TODO: incorrect, and can't CTRL-C!
      if (many.length > 1) {
	let r= many.map(unquoteStrings)
	    .some(x=>!run_h(x));
	return r;
      }
    }

    let cmd = run_h(line, orig);
    
    // if it's not running in background
    if (!running()) prompt(cmd === 'EDIT');
    return true;
  }
  // internal: takes quotedStrings param
  function run_h(line, orig) {
    run.count++

    // rough parameter extraction
    let a = line.split(/[\s;=\(\),]+\s*/g);
    if (trace) print('------' + a.join(' | '));
    a = a.map(unquoteStrings);
    if (trace) print('------' + a.join(' | '));

    // hehe - crap!
    if (!orig.match(/^(LIST|LLIST|LPRINT|PRINT|LET|INPUT|FOR|HELP|DIM|CLOAD|CSAVE|REM|IF|REPEAT|WHILE|UNTIL|NEXT|GET)/)) {
      if (trace) print('---EVAL---' + a.join(' | '));
      a = a.map((x,i)=>!i?x:EVAL(x));
    }

    // make numbers great again
    a = a.map(x=>(+x==x?+x:x));
    //if (trace) print('--num---' + a.join(' | '));

    let cmd = a.shift();

    // call function
    let f = window[cmd];
    if (trace) print('LINE: ' + line);
    if (f) {
      try {
	// TODO if f.len !+ a.length => ?SYN
	// problem is with ...args count=0
	f.apply(orig, a);
      } catch(e) {
	// TOOD: make into error?
	// simplify error handl: just throw strings!
      }
    } else {
      stop(true);
      try { syntax_error(cmd); } catch(e) {}
      return;
    }

    return  cmd;
  }
  run.count = 0;
  
  function editBackspace() {
    cursorHide();
    // Oric: move to newline if...
    if (!line) {
      if (col > column) print();
    } else {
      // delete char
      putc(8);
      line = line.substring(0, line.length-1);
    }
    cursorShow();
  }
  
  function editCancel() {
    line = ''; 
    cursorHide();
    princ('\\');
    print();
    cursorShow();
  }

  function editCopy() {
    // DOC: CTRL-A copies char from screen into edit buffer
    // New: If it's 0--31 - an attribute it's prefixed by ESC (27)
    // ORIC programs can handle and display ESC and attributes so encoded
    let c = screen(row, col);
    // escape read attributes
    if ((c & 0x7f) < 32) {
      editChar(27);
    }
    editChar(c);
  }

  let arrows = {l:37, u:38, r:39, d:40};
  function cursorMove(direction, steps=1) {
    direction = direction.toLowerCase();
    let c = arrows[direction[0]];
    while(steps--)
      editArrow(c);
  }

  function uglies(f) {
    let c = f( screen(row, col) );
    // wrap around
    if (c >= 96) c = c - 64;
    if (c < 32) c = c + 64;
    screen(row, col, c);
    let ch = String.fromCharCode(c);
    // build strange bitmap
    let bits = c.toString(2).padStart(7, '0');
    // skip 2nd highest bit (32)
    bits = bits[0]+bits.substr(-5);
    bits = bits.split('').reverse().join('')
      .match(/(..)/g)
      .join(' ');
    clearline(0);
    iplot(2,0,`CHAR '${ch}' ${HEX$(c)} (${c}) ALT: \u0009${ch}\u0008 ${bits}`);
  }

  // This is probably a crazy idea!
  // adding full TELETEXT EDITING!
  function editExt(k, kc, a, s, c, e) {
    // DOC: New! Extended full screen editing!
    // CTRL-A copy ATTR/chr at cursor
    // ALT-G  enter GEDIT mode!
    // CTRL-H DEL char (scroll left)
    // CTRL-I INS spc (scroll right)
    // CTRL-J toggle protected col 2
    // CTRL-M CR, move to col 2
    // CTRL-P toggle "printer" log
    // CTRL-R reload sim (reset)
    // CTRL-Y yanks (pastes) the edit
    // CTRL-BS delete line, scroll up
    // CTRL-ENTER insert line, " down
    // CTRL-arrow copy ATTR to dir
    // CTRL-? help for color ATTRs
    // CTRL-1 insert INK 1 (red)
    // ALT-3  insert PAPER 3 (yellow)
    // CTRL-ALT toggle show ATTRs
    // CTRL-ALT-U "uglies" charcode+1
    // - TELETEXT/ALT block chars
    // CTRL-SHIFT-1 toggle bit 1
    // CTRL-SHIFT-6 toggle bit 6
    
    //e.preventDefault();
    try{
      cursorHide();
      //if (!k.match(/[0-9a-z]/)) return;
      //alert(`editExt: '${k}' ${kc} ${a?'a':''} ${s?'s':''} ${c?'c':''}`);

      // TODO:
      switch(k) {
      //case 'v': alert("editExt: can't catch 'v"); break;
      
	// ins char shift right after cursor
      case 'i': 
	if (c) {
	  for(let i=SCREEN_COLS-1; i>col; i--)
	    screen(row, i, screen(row, i-1));
	  screen(row, col, 32);
	}
	break;

	// DEL shift left after cursor
      case 'h':
	if (c) {
	  for(let i=col; i<SCREEN_COLS-1; i++)
	    screen(row, i, screen(row, i+1));
	  screen(row, SCREEN_COLS-1, 32);
	}
	break;
      case '/': // unsifted ? lol
      case '?': 
	clearline(0);
	iplot(0,0,'COLOR:CTRL- ALT- 0 \21'+'1\0\22'+'2 \23'+'3\7\24'+'4 \25'+'5\0\26'+'6 \27'+'7\0');
	break;
      
	// Yank! (paste line buffer)
	// (ALT-Y stays, and move down)
      case 'y': {
	let sr=row, sc=col;
	princ(line);
	if (a) {
	  row=sr+1; col=sc;
	  if (row >= SCREEN_ROWS) row=0;
	}
	break; }

	// uglies - block graphics
      case 'u': if (c && a) uglies(x=>x+1); break;

	// fg: CTRL-# bg: ALT-#
	// (and CTRL-ALT-# uglies)
      case (k.match(/^\d$/)?k:false): {
	// uglies - block graphics
	// C-A-#   1 2
	//         3 4
	//         5 6
	// 0 = 00 00 00
	// 7 = 11 11 11
	// 8 = 10 01 10
	if (c && a) {
	  kc = kc - 48; // 0--9
	  uglies(x=>{
	    switch(kc) {
	    case 0: return 32+0;
	    case 7: return 32+1+2+4+8+16+32;
	    case 8: return x ^ (95-32);;
	    case 9: return x ^ (1+4+16);
	    case 6: return x + 32; // !
	    default: return x ^ (1<<(kc-1));
	    }
	  });
	  break;
	}
	// colors CTRL ->  0-- 7 (fg)
	// colors ALT  -> 16--23 (bg)
	editChar(ESC);
	k = kc-48 + (a?16:0);
	editChar(k + 64); // ESC A = \1
	break; }
      }
      //alert('EDITEXT: '+k + ' kc='+kc);
      cursorShow();
    } catch(err){throw err; alert(
      'ERROR: ' + err +
	`\neditExt: '${k}' ${kc} ${a?'a':''} ${s?'s':''} ${c?'c':''}`);}
    
  }
  
  // A graphical edit mode!
  // ======================
  // https://www.oric.org/software/lorigraph-1241.html
  // TODO: Lorigraph was apparently one of
  // the better drawing programs for ORIC
  // Features:
  // - pixel (' ', 1, 0)
  // - line (l)
  // - line-line-line (l arrow l arrow l))
  // - star (back to origin) (l o arrow l o)
  // - rectangle (m arrow r)
  // - ROMB! (TODO:)
  // - attributes (TODO:)
  // - block (?) (TODO:)
  // - swap (TODO:)
  // - copy (TODO:)
  // - mirror (TODO:)
  // - chars (symbols, fonts)
  // - text (oric) (TODO:)
  // - erase (TODO:)
  // - invert (TODO:) kind of a "fill"
  // - rotation (TODO:)
  // - flip (rot, mirror, unrot) (TODO:)
  // - fill (I'm assuming 'paint') (TODO:)
  // - print (TODO:)
  // - save (TODO:)
  // - load (TODO:)
  // - pattern (TODO:)
  // - paper
  // - ink
  // - write/erase (xor?)

  // this contains state as well as impl
  var gCMD = {
    ox: undefined,
    oy: undefined,
    mode: 2, // xor
    xmode: 0, // crosshair
    step: 1,

    stack: [], // lol
    index: 0,

    ops: [],

    saved: undefined,

    // colors will be multiples of 8+color...
    ink: 7, 
    paper: 0,

    // const - don't save

    xmodes: 'x+/ ',

    // functions as map
    // (all functions are added by name too!)
    //    l: functinon draw()... key='l'
    //    L: fucntion... key = 'L'
    //  A_l: fun... key = 'ALT-l'
    //
    // it can be called by can be called by
    //   gCMD.apply(gCMD, 'l');
    //   gCMD.apply(gCMD, 'draw');
    //
    // screen update func: call save('func')
    // this enables 'replay'!
    
    save: function save(name) {
      this.ops.push([name, this.getState()]);
    },
    getState: function getState() {
      return {
	curx, cury,
	ox: this.ox, oy: this.oy,
	mode: this.mode,
	xmode: this.xmode,
	ink: this.ink,
	paper: this.paper,
      };
    },
    applyState: function applyState(s) {
      curx = s.curx; cury = s.cury;
      this.ox = s.ox; s.oy = s.oy;
      this.mode = s.mode;
      this.ink = s.ink;
      this.paper = s.paper;
    },
    A_r: function replay() {
      // TOOD: save text?
      // TODO: save and restore stack
      CLS(); LORES(1);
      console.log('replay.1');
      this.ops.forEach(op=>{
	console.log('replay.2');
	let o = op[0];
	let s = op[1];
	console.log('replay.3 op=' + op + ' ' + JSON.stringify(s));
	this.applyState(s);
	console.log('replay.4');
	// replay command!
	(this[o])(); // no args
	console.log('replay.5');
      });
      console.log('replay.6 done');
    },
    h: function home() {
      this.ox = curx;
      this.oy = cury;
      if (hires()) {
	throw "gCMD: hires mode not implemented";
      } else {
	curx = INT((SCREEN_COLS-1) * 2 / 2);
	cury = INT((SCREEN_ROWS-1) * 3 / 2);
	this.mark();
      }
    },
    ' ': function toggle() {
      this.save('toggle');
      CURMOV(0, 0, 2);
      this.mark();
    },
    0: function unset() {
      this.save('unset');
      CURMOV(0, 0, 0);
      this.mark();
    },
    1: function set() {
      this.save('set');
      CURMOV(0, 0, 1);
      this.mark();
    },
    m: function mark() {
      // don't mark twice (keep other)
      // erh? this is a noop..
      // keep for thirdx...
      if (this.ox == curx && this.oy == cury)
	return;
      this.ox = curx;
      this.oy = cury;
      this.push();
    },
    o: function other() {
      let x=curx; curx=this.ox; this.ox=x;
      let y=cury; cury=this.oy; this.oy=y;
      CURSET(curx, cury, 3);
    },
    push: function push() {
      let last = this.stack[this.stack.length-1];
      // don't push if already at top
      if (last && last.x == curx && last.y == cury)
	return;

      this.stack.push({x: curx,y: cury});
      this.index = this.stack.length-1;
      return this.stack.length;
    },
    pop: function pop() {
      let r = this.stack.pop();
      if (!r) return 'No more positions!';
      
      CURSET(r.x, r.y, 3);
      return this.stack.length;
    },
    p: function prev() {
      if (this.index > 0) this.index--;
      let pos = this.stack[this.index];
      CURSET(pos.x, pos.y, 3);
      return this.index;
    },
    n: function next() {
      if (this.index+1 < this.stack.length)
	this.index++;
      let pos = this.stack[this.index];
      CURSET(pos.x, pos.y, 3);
      return this.index;
    },
    B: function block() {
      // DOC: fill all with background color
      try{
	let old = this.paper % 8 + 16
      this.paper++;
      fill(1, 0, SCREEN_ROWS-1, SCREEN_COLS,
	   (r,c)=>{
	     let ch = screen(r, c);
	     // this erases attr of same color :-(
	     if (ch === 32 || ch  == old) 
	       return this.paper % 8 + 16;
	     else
	       return ch;
	     });
} catch(e) {alert(e);}
    },
    L: function lores() {
      this.ink = ink;
      this.paper = paper;
      LORES();
    },
    l: function line() {
      this.save('line');
      this.other();
      this.push();
      DRAW(this.ox-curx, this.oy-cury, this.mode);
      this.push();
      this.mark();
    },
    c: function circle() {
      this.save('circle');
      sq = (v)=>v*v;;
      let r = SQR(sq(this.ox-curx) + sq(this.oy-cury));
      this.other();
      CIRCLE(r, this.mode);
      this.other();
      // save current pos
      this.push();
      return INT(r);
    },
    r: function rect() {
      this.save('rect');
      let x = curx, y = cury;
      this.other();
      DRAW(this.ox-x, 0, this.mode);
      DRAW(0, this.oy-y, this.mode);
      DRAW(x-this.ox, 0, this.mode);
      DRAW(0, y-this.oy, this.mode);
      this.other();
    },
    I: function Ink() {
      INK(++this.ink % 8);
    },
    P: function Paper() {
      PAPER(++this.paper % 8);
    },
    q: function quit() {
      if (hires()) {
	throw 'GEDIT: quit not defined for hires yet!';
      } else {

      }

      gedit = false;

      cursorShow();
      setTimeout(showStatus, 500);
      return 'BYE!';
    },
    // also works as init function
    init: function init() {
      cursorHide();

      if (typeof this.ox === 'undefined') {
	// init if first time only
	this.h();
	this.ox = curx;
	this.oy = cury;
      }

      gedit = true;
    },
    x: function crossmode() {
      this.xmode = (this.xmode+1) % this.xmodes.length;
      return this.xmodes[this.xmode].repeat(10);
    },
    cross: function cross() {
      // save
      let x=curx;
      let y=cury;

      let m = this.xmodes[this.xmode];
      switch(m) {
      case '+':   // long cross
      case 'x': { // straight cross
	let z = m == 'x' ? 5 : 300;
	CURSET(x, y, 3); DRAW(+z, 0, 2);
	CURSET(x, y, 3); DRAW(-z, 0, 2);
	CURSET(x, y, 3); DRAW( 0,+z, 2);
	CURSET(x, y, 3); DRAW( 0,-z, 2);
	break; }
      case '/': {
	let z = 5;
	CURSET(x, y, 3); DRAW(+z+1,-z-1, 2);
	CURSET(x+1, y-2, 3); DRAW(+z,-z, 2);
	CURSET(x+2, y-1, 3); DRAW(+z,-z, 2);
	// we need to draw x,y even times!
	CURSET(x, y, 2);
	break; }
      default: // none;
      }

      // restore
      CURSET(x, y, 3);
    },
    // show other "cross"
    ocross: function ocross(x, y) {
      let sx=curx;
      let sy=cury;
      let m = this.xmodes[this.xmode];
      if (m !== 'x' && m !== '+') return;

      let z = m == 'x' ? 3 : 300;
      CURSET(x, y, 3); DRAW(+z,+z, 2);
      CURSET(x, y, 3); DRAW(-z,-z, 2);
      CURSET(x, y, 3); DRAW(+z,-z, 2);
      CURSET(x, y, 3); DRAW(-z,+z, 2);

      CURSET(sx, sy, 3);
    },
    arrowup: function(){cury-=this.step},
    arrowdown: function(){cury+=this.step},
    arrowleft: function(){curx-=this.step},
    arrowright: function(){curx+=this.step},

    CA_arrowup: function(){cury-=this.step},
    CA_arrowdown: function(){cury+=this.step},
    CA_arrowleft: function(){curx-=this.step},
    CA_arrowright: function(){curx+=this.step},

    // unhifted ?
    '/': function(){this.help()},
    '?': function help() {
      // toggle - restore if saved
      if (this.saved) {
 	screenDraw(this.saved);
	this.saved = '';
	return;
      } else {
	this.saved = screenSaved();
      }

      // show help
      let h =
'\33\3\33\24'+`G(raphical) EDIT`+'\33\20\33\7'+`
  by (c) Jonas S Karlsson

A raw screen editor (LORES 1)
- text and attr line editing
- graphical TELETEXT drawing

SHIFT/ALT-arrow move 10/25

----------------------------------------
move    h-home     o-other   arrow-keys
        p-prev     n-next    CTRL/SHIFT

pixel   SPC-toggle 1-set     0-unset
draw    l-line     c-circle  r-rect
fill               C         R

----------------------------------------
---------x---------x---------x---------x
color    I-Ink     P-Paper 
m-mode   L-lores 

q-quit  ?-back to edit  q-quit

---------x---------x---------x---------x
CTRL-    ALT-         G(raphical)EDIT
   C-? help               ? help
=================  =====================
                   SPC toggle pixel
-A copy            a copy   
-B  -              b?brush  
-C break           c circle  C fill    
-D double                             
-E  -              e?erase   E?export       
-F keyclck         f?fill    F Flip
---------x---------x---------x---------x
-G bell                             
-H del             h home              
-I insert A-inv              I ink
-J column                        
-K                                    
-L CLS    A-Load   l line    L LORES  
-M |<--            m mark    M?mode
-N clrline         n next       
-O out-off         o other      
-P printer         p prev    P paper
---------x---------x---------x---------x  
-Q cursor          q quit          
-R reload          r rect    R fill
-S screen A-Save   s?swap       
-T caps            t text    T textfont
-U  -                             
-V  -                              
-W?write           w?write
-X cancel                          
-Y yank            y?yank        
-Z?undo            z?undo
---------x---------x---------x---------x
-? color help
-0 black bkground  0 unset
-1 red       "     1 set
-2 green     "     
-3 blue      "
-4 yellow    "
-5 magnenta  "
-6 cyan      "
-7 white     "     
-8 textmode        8 flip
-9 blockgrph       9 rotate
                   +
                   -
---------x---------x---------x---------x
-arrw copy step25 step 1    step 10
C-RET insert line
C-BS delete line
`;
      CLS();
      print(h);
      return;
      // print K-name ...
      Object.keys(this).filter(
	k=>k.length==1).sort().map(
	  k=>k+'-'+this[k].name)
	.forEach(s=>{
	  if (s.length + POS() >= SCREEN_COLS)
	    TAB();
	  princ(s); TAB();
	});

    },

  };
  // make all functions keys too!
  Object.keys(gCMD).forEach(
    k=>{ let f = gCMD[k];
	 if (f && f.name)
	   gCMD[f.name]=f;
       });

  function GEDIT(k, kc, a, s, c, e) {
    // DOC: G(raphical) EDIT!
    // For HIRES or LORES mode
    // Simple key commands to draw
    // ALT-G to activate
    // ?-for help, q-quit
    let g = gCMD;

    function msg(txt) {
      clearline(0);
      iplot(0, 0, txt);
    }
    
    // undraw if needed
    if (gedit) {

      // undraw x
      g.cross();

      // undraw o
      if (typeof GEDIT.ox !== 'undefined')
	g.ocross(GEDIT.ox, GEDIT.oy);
      GEDIT.ox = undefined;
    }

    // increase step length!
    if (s)
      g.step = 10;
    else if (a)
      g.step = 25;
    else
      g.step = 1;

    // undo
    //if (c && g.last) g.last.call(g);
    //if (c) g.circle();

    if (s && k.length===1)
      k=k.toUpperCase();
    // if alt key do prefix by CAS_key
    if (a)
      k=(c?'C':'')+(a?'A':'')+(s?'S':'')+'_'+k;

    let f = g[k];
    console.log('GEDIT: ' + k + ' ' + (f?f.name:'nope'));
    if (!f) {
      msg('GEDIT: ?-help q-quit');
    } else {
      msg('GEDIT.' + f.name);
      let r;
      try  {
	r = f.call(g, k, kc, a, s, c, e);
      } catch(e) {
	alert('GEDIT.'+f.name+': ERROR\n'+e);
      }
      if (r)
	msg('GEDIT.' + f.name + ': ' + r);
      
      // update pos in right corner
      let pos = '\3'+`${ABS(curx-g.ox)} ${ABS(cury-g.oy)}`+'\2'+`${curx} ${cury}`;
      iplot(40-pos.length, 0, pos);
    }
   
    // save for undo
    //if (c) g.circle();
    
    //if (c && g.last) {
    //g.last.call(g);
  //} else {
    //g.last = f;
  //}

    if (hires()) {
      throw 'GEDIT: Hires mode note done!';
    } else {
      // update cursor to same cell!
      col = 1 + INT(curx / 2) % SCREEN_COLS;
      row = 1 + INT(cury / 3) % SCREEN_ROWS;
      if (col < 0) col += SCREEN_COLS;
      if (row < 0) row += SCREEN_ROWS;
    }

    // if we're exiting don't draw!
    if (!gedit) return;

    // draw o
    GEDIT.ox = g.ox;
    GEDIT.oy = g.oy;
    if (typeof GEDIT.ox !== 'undefined')
      g.ocross(GEDIT.ox, GEDIT.oy);

    // draw x
    g.cross();
  }

  function editArrow(ch) {
    cursorHide();
    switch(ch) {
    case 37: col--; break; // left
    case 38: row--; break; // up
    case 39: col++; break; // right
    case 40: row++; break; // down
    }
    // move cursor, wrap around (?)
    if (col < column) col = SCREEN_COLS-1
    if (col > SCREEN_COLS-1) col = column;
    if (row < 0) row = SCREEN_ROWS-1;
    if (row > SCREEN_ROWS-1) row = 0;

    findAction();

    cursorShow();
  }

  function clearline(r, optCol) {
    optCol = optCol || 0;
    iplot(
      optCol,
      typeof r==='number'?r:row,
      SPC(40-optCol));
  }

  function showStatus() {
    function update(col, status, msg) {

      if (col < 0) col += SCREEN_COLS;
      iplot(col, 0,
	   status ? msg : SPC(msg.length));
    }

    // difficult to update if OFF!
    // (lol we update even if off :-)
    // (ctrl-o on ORIC stopps updates)
    let saved = scoff; scoff = 0;
    
    clearline(0);
    
    // gEdit mode
    update(0, gedit, 'GEDIT');

    // CTRL-Q: toggle cursor
    update(-4, caps, 'CAPS');

    // CTRL-P: toggle printer
    update(-4 -2 -7, printer, 'PRINTER');
    
    // CTRL-O: toggle screen (centered)
    update(Math.floor(SCREEN_COLS-10)/2,
	     saved, 'SCREEN OFF');

    // CTRL-S: toggle screen (centered)
    if (scstop) {
      // only overwrite status ofscoff if scstop
      update(Math.floor(SCREEN_COLS-12)/2,
	     scstop, 'SCREEN PAUSE');
    }

    // restore, no write to screen
    scoff = saved;
  }
  
  function writeScreen() {
    // now to give it a name?
    // string put in 0,0? lol?
    let sc = screenSaved();
    let name = sc.name || 'noname';
    let id = 'SCREEN:' + name + ' ' + sc.date;
    sc.id = id;

    let dispid = sc.date.replace(/\..*$/, '')
	.replace(/[:-]/g, '')
	.replace('T', ' ');
    dispid = name + ' ' + dispid;
    clearline(0); iplot(0, 0, dispid);
    sc.dispid = dispid;

    let msg = lsput(id, JSON.stringify(sc)) ?
	'\2--SAVED' : '\1--FAILED';
    iplot(dispid.length, 0, msg);
    // TODO: make current state as not dirty
  }

  function readScreen() {
    // TODO: if dirty,save first!
    let q = readScreen.queue;
    if (!q || !q.length) {
      q = readScreen.queue = lssearch('SCREEN:');
    }
    let id = q.pop();
    let sc = lsget(id);
    if (sc) {
      sc = JSON.parse(sc);
      screenDraw(sc);
      let dispid = sc.dispid;
      if (dispid) {
	clearline(0);
	iplot(0, 0, dispid);

	let index = ' ' + q.length;
	iplot(40-index.length, 0, index);
      }
    } else {
      clearline(0); iplot(0,0,'\1FAIL: '+id);
    }
  }

// wget.url["pageid linkid"] = url
// wget.url["pageid linktxt"] = url
// wget.pageid = pageid // last seen  
function wget(url, cb) {
  // plain on JSONP! (works from file://)
  let s = document.createElement('script');
  // create a callback that cleans up
  wget.cb = wget.cb || {};
  wget.url = wget.url || {};
  let n = wget.n = (wget.n || 0) + 1;
  wget.url[n] = url;
  wget.pageid = n;
  wget.form[n] = {};
  wget.cb[n] = function(data){
    try {
      cb(data, undefined, n, url);
    } catch(e) {
      alert(`wget.cb: ${url}\n${''+e}\n${''+e.stack}`);
    }
    // cleanup
    s.remove();
    delete wget.cb[n];
  };
  if (url == 'g.coom') {
    s.src = 'google.com.js';
  } else {
    s.src = 'http://yesco.org/wget.pl?jsonp=(wget.cb['+n+'])&'+url;
  }
  console.log(s.src);
  // TODO: cleanup on error
  s.onerror = 'alert("load err");';
  s.onload  = 'alert("load ok");';
  // actrivate
  document.body.appendChild(s);
}
wget.url = {};
wget.db = {};
wget.form = {};

function HTML2TELETEXT(nid, h) {
  // TODO: move styling to stylemap
  // TODO: base URL
  // TODO: handle link broken by end of screen, and attr not follow...
  
  // - \u0320 non-breakable space
  // - \u030a force newline
  // (These retain color after new line)
  // - \u0102 set green START
  // - \u0202 set green END (matching)
  // - \u0112 set green back START
  // - \u0212 set green back END (matching)

  let scandimap = {'Æ': 'AE', 'Å': "A'", 'å':"a'", 'Ä':'a"', 'ä':'a"', 'Ð':'D-', 'ð':'TH', 'Ø':':0/', 'ø':'o/', 'Ö':'O"', 'ö':'o"', 'Þ':'TH|', 'þ':'TH|'};
  let scandis = RegExp('([ÆÅåÄäÐðØøÖöÞþ])', 'g');

  function getAttr(s, name) {
    // quoted
    let [q1, val] = rget(
      s, `${name}\s*=\s*(['"])(.*?)\\1`);
    // try unquoted
    if (!q1) {
      [val] = rget(
	s, `${name}\s*=\s*([^\s>]+?)`);
    }
    return val?val:'';
  }
    
  // TODO: replace inside out, innermost <>
  let n = 0;
  h = h
    .replace(/&raquo;/ig, '>>')
    .replace(/&copy;/ig, '\`')

    .replace(/\r/g, '\n')
    .replace(/[\x00-\x09\x11-\x1F]/g, '')
    .replace(/\xa0/g, '\u0320' /*nbsp*/)
    .replace(/\ufffd/g, ' ' /*unknown*/)

    .replace(/\u2014/g, '-'/*nobrdash*/)
    .replace(/\ufeff/g, '')
    .replace(scandis,
	     (a,c)=>(scandimap[c] || '\\?'))
    .replace(
      /([^\0-\x7f])/g,
      (a,c)=>`\\u${c.charCodeAt(0).toString(16).padStart(4, '0')}`)

    .replace(
      /<img [\s\S]*?src=(['"])(\S+?)\1[\s\S]*?>/g,
      (a,q, src)=>{
	// TODO: hardcode some rendering
	// TODO: render alt as "big font"?
	let [_, alt] = rget(a, /alt=(['"])(\S+?)\1/);
	// TODO:? use diff counter for images
	n++;
	if (alt)
	  wget.url[`${nid} ${n}`] = alt;
	let lid = `${nid} ${n}`;
	wget.url[lid] = src;
	// TODO: generalize
	if (alt === 'Google') {
	  /* wow, this was difficult:
	   TOOD: return mixed with &nbsp; have effect on spacing...
	   TODO: \u0117 .. \u0110 without breakable space goes to column 0, hmmmm
	  */
	   return `
\u030a
\u0117
&nbsp;
\u0110
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
\u0210
\u0217

\u030a
\u0117
&nbsp;
\u0110
&nbsp;
\u0104G\u0204
\u0101o\u0201
\u0103o\u0203
\u0104g\u0204
\u0102l\u0202
\u0101e\u0201
&nbsp;&nbsp;
\u0210
\u0217

\u030a
\u0117
&nbsp;
\u0110
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
\u0217
`;
	  } else {
	    return ` [IMG ${lid}&nbsp;\u0112\u0100${alt?alt:''}&nbsp;\u0200\u0212] `;
	  }
      })
    .replace(
      /\s*<a [\s\S]*?>\s*([\s\S]*?)\s*<\/a>\s*/g,
      (a, txt)=>{
	let href = getAttr(a, 'href');
	n++;
	// save as '1 2'
	// and     '1 TXT'
	wget.url[`${nid} ${txt}`] = href;
	let lid = `${nid} ${n}`;
	wget.url[lid] = href;
	return '\u0104' + txt + '\u0204';
      })
    .replace(/\u0204(\s+)\u0104/g, '\u0304$1')
    .replace(/<button[\s\S]*?>([\s\S]*?)<\/button>/g, '[? $1 ]')
    .replace(
      /<input[\s\S]*?>/g,
      (a)=>{
	let name = getAttr(a, 'name') || 'isindex';
	let type = (getAttr(a, 'type') || 'text').toLowerCase();
	let value = getAttr(a, 'value');
	if (name && value) {
	  wget.form[wget.pageid][name] = value;
	}
	if (type === 'hidden') return '';
	let size = getAttr(a, 'size') || 12;
	//value = value.padEnd(size, '\u0320');
	value = value.padEnd(size, '\u007E');
	if (type === 'submit') {
	  //return ` [SUBMIT ${nid} ${name}: \u0116${value}&nbsp;\u0216]\u030a`;
	  // TODO: ink dissapared!
	  //return `&nbsp;\u0104\u0116${value}\u0216\u0204&nbsp;foo\u030a`;
	  return `
\u0104&nbsp;`+ // TODO: this is so it doesn't take column 01..
// maybe this can be used as difference for block and inline-block??? haha
`\u0113
${value}
&nbsp;
\u0204
&nbsp;` + // TODO: this is needed between INK+PAPER, why? otherwise cannot restore paper!
`\u0213` + // TODO: 6_1foo (one too many _) 
``;
	} else if (type === 'text') {
	  return `\u0101\u0116${name}\u0100${value}\u0216\u0200\u0201\u030a`;
	} else {
	  // TODO: button
	  // TODO: checkbox
	  // TODO: rang
	  // TODO: reset
	  // TODO: radio
	  // TODO: search
	  return ` [INPUT ${nid} ${type} ${name}: \u0116${value}\u0216]\u030a`;
	}
      })
    .replace(
      /<textarea[\s\S]*name=([^\s>]+)[\s\S]*?>([\s\S]*?)<\/textarea>/g,
      (a,id,val)=>{
	return `\n[WWW ${nid} ${id}\n${val}\n]\n`;
      })

    .replace(/<(\w+)[\s\S]*?>/g, '<$1>')
    .replace(/<!--[\s\S]*?-->/g, '')
    .replace(/<head[\s\S]*?\/head>/g, '')
    .replace(/<title[\s\S]*?\/title>/g, '')
    .replace(/<style[\s\S]*?\/style>/g, '')
    .replace(/<script[\s\S]*?\/script>/g, '')
    .replace(
      /<pre>([\s\S]*?)<\/pre>/gi,
      (a)=>a.replace(/\n/g, '\u030a\u0320\u0320')
	.replace(/ /g, '\u0320'))

    .replace(/\n/g, ' ')
    .replace(/ +/g, ' ')

    .replace(/<br>/g, '\n')
    .replace(/<hr>/g, '\n--------------------\n')

    .replace(/<b>([\s\S]*?)<\/b>/g, '\u0101$1\u0201')
    .replace(/<i>([\s\S]*?)<\/i>/g, '\u0105$1\u0205')

    .replace(/<li>\s*/g, '\n\u0101*\u0201')
    .replace(/<p>\s*/g, '\n\u0320\u0320')
    .replace(/<\/p>\s*/g, '\n')
    .replace(/<div>/g, '\n')
    .replace(/\/div>/g, '\n')
    .replace(/\n\n+/g, '\n\n')

    .replace(/<h1>([\s\S]*?)<\/h1>/g, '\n\u0110\u0107$1\n\n\u0210\u0207')
    .replace(/<h2>([\s\S]*?)<\/h2>/g, '\n\u0112\u0100$1\n\u0212\u0200')
    .replace(/<h3>([\s\S]*?)<\/h3>/g, '\n\u0113\u0100$1\n\u0213\u0200')
    .replace(/<h4>([\s\S]*?)<\/h4>/g, '\n\u0116\u0100$1\n\u0216\u0200')
    .replace(/<[\s\S]*?>/g, ' ')

    .replace(/ +/g, ' ')
    .replace(/ *\n */g, '\n')
    .replace(/ *([\0-\37]) */g, '$1')
    .replace(/^\n*/, '')

    .replace(/&nbsp;/ig, '\u0320')
    .replace(/&gt;/ig, '>')
    .replace(/&lt;/ig, '>')
    .replace(/&amp;/ig, '&')


    .trim();
  return h;

// TODO: double! didn't work...?
//    .replace(/<h1>([\s\S]*?)<\/h1>/g, '\n\u0110\u0107\x1aJ$1\n\n\u0210\u0207')

//    .replace(/(?<=[\u0000-\u0007])([\u0000-\u0007])/g, '$1')
//    .replace(/(?<=[\u0010-\u0017])([\u0000-\u0017])/g, '$1')

}

// TODO: Wired.com break something
// TODO: ibm.com too much empty lines
function urlView(url) {
  clearline(0);
  iplot(0, 0, 'Loading '+url+' ...');
  wget(
    url,
    function(h, err, nid, url) {
      CLS();
      let u = url;
      iplot(0, 0, u.substring(0, SCREEN_COLS));
      showPage(h, err, nid, url);
    });
}

function showPage(h, err, nid, url){
  let txt = HTML2TELETEXT(nid, h);
  let i = 0;
  let step = 40;;

  // colors
  let isink = c7=>(c7 <= 7);
  let ispaper = c7=>(16 <= c7 && c7 <= 24);

  // charcodes of current inc/paper
  let cink = ink;
  let cpaper = paper + 16;

  let cstack = [];

  let lastwasink = false;
  let lastwaspaper = false;
  let lastwasspace = (ch == 32);

  let rowcounter = 0;
  let lastrow = 0;

  // TODO: make it the default
  if (cink !== 7 || cpaper !== 0+16) {
    column = 2;
  }
  
  function myputc(ch) {
    if (row != lastrow) {
      rowcounter++;
      lastrow = row;
    }

    if (cink == 7 && cpaper == 0+16 && col <= column && (lastwasink || lastwaspaper || lastwasspace))
{      col = 0; column=0; }
    // TODO: make it the default
    if (cink !== 7 || cpaper !== 0+16) {
      column = 2;
      if (col < column) col = column;
    }
    //console.log('putc '+JSON.stringify({ c: String.fromCharCode(ch), ch, col, cpaper, cink, lastwasink, lastwaspaper, lastwasspace }));


    // horunge (bastad childs)
    // TOOD: fix ugly word breaks
    // TODO: cheat at .,:,? at EOL?

    let c7 = ch & 0x7f;

    // optimize corner cases
    // if at beginning of line and space
    if (col == column && (ch == 32 || ch == 10)) {
      // ignore such space!
      return;
    } else if (col == column
	       && (isink(c7) || ispaper(c7))){
      // save space by using protected
      //let cont = (ch & 0x0F00 != 0x0300);
      if (isink(c7)) {
	screen(row, 1, cink = c7);
	lastwasink = 1;
      } else if (ispaper(c7)) {
	screen(row, 0, cpaper = c7);
	lastwaspaper = 1;
      }

      return; // done here
    } else if (ch == 32 && lastwasspace) {
      // ignore soft spaces
      return;
    }

    if (ch == 32 && (lastwasspace || lastwasink || lastwaspaper))
      return;

    // escape control codes
    if (ch != 10 && c != 27 && ch < 32) {
      if (lastwasspace ||
	  (lastwasink && isink(ch)) ||
	  (lastwaspaper && ispaper(ch))) {
	// how about more levels... lol
	if (col > 2) col--; // BS
      }
      // update
      if (isink(ch)) {
	cink = ch;
	lastwasink = 1;
      }
      if (ispaper(ch)) {
	cpaper = ch;
	lastwaspaper = 1;
      }

      putc(ESC);
      putc(ch+64);
      // TODO: if write at last pos...?
      lastwasspace = true;
      // no return as this might have wrapped line and we need fall through for cols
    } else {
      // finally print it!
      lastwasink = false;
      lastwaspaper = false;
      
      lastwasspace = (ch == 32);

      // hard newline (pre, br)
      if (ch == 0x030a) ch = 10;
      // hard space (pre)
      if (ch == 0x0320) ch = 32;

      // TODO: paper 0 ink 7
      // <h1> can just move cursor to col=0!
      if (col == column && (lastwasink || lastwasspace || lastwaspaper) && cink == 7 && cpaper == 0+16) {
	col = 0;
      }
      //lastwasspace = false;

      putc(ch);
    }

    // at newline need continue color
    if (col == column) {
      // but only if default is different
      if (ink != cink)
	myputc(cink);
      if (paper != cpaper)
	myputc(cpaper);
    }
  }

  RUN.interval = setInterval(
    function printSlow() {
      // TODO: handle pageing?
      if (scstop) return;

      let end = i + step;
      for(; i<end; i++) {

	if (i > txt.length) {
	  if (col !== column) print();
	  print('-- ' + url);
	  stop();
	  return;
	}

	let ch = txt.charCodeAt(i);
	let c7 = ch & 0x7f;

	if (ch >= 0x0300) {
	  // continue color (delimiter)
	  myputc(ch);
	} else if (ch >= 0x0200) {
	  // end color
	  let t = cstack.pop();
	  if (!t) {
	    // ingore unmatched
	    //myputc(32);
	    myputc('?'.charCodeAt(0));
	  } else if (cpaper != t.cpaper) {
	    // restore paper
	    myputc(t.cpaper);
	    //myputc('P'.charCodeAt(0));
	  } else if (cink != t.cink) {
	    // restore ink
	    myputc(t.cink);
	    //myputc('I'.charCodeAt(0));
	  } else {
	    // TODO: graphics ???
	    myputc(32);
	  }
	  //princ(`[i:${t.cink}p:${t.cpaper}]`);
	} else if (ch >= 0x0100) {
	  // start color
	  cstack.push({c7, cink, cpaper});
	  if (c7 == cink || c7 == cpaper) {
	    // same
	    myputc(32);
	  } else {
	    myputc(c7);
	  }
	  //myputc('v'.charCodeAt(0));
	} else {
	  myputc(ch);
	}
	
	// top when screen full
	if (0 && !(rowcounter % (SCREEN_ROWS-2))) {
	  // this doesn't work CTRL-S becomes 'b'??? wtf???

	  // doesn't move cursor
	  iplot(2,SCREEN_ROWS-1,'-- CTRL-S TO CONT/STOP');
	  scstop = 1;
	  return;
	}
      } // for
    }, 0); // set interval
} // 


  dom('exp').addEventListener('keydown', function(e) {
    let c=e.ctrlKey,a=e.altKey,s=e.shiftKey;
    let k = e.key.toLowerCase();
    let ch = e.code;
    let kc = e.keyCode; // legacy

    //console.log("KEY k='+k+' kc="+kc+" c="+c+" a="+a+" s="+s);

    // magicall show attributes!
    if (c && a)
      dom('screen').classList.toggle('show-attr');

    // gedit mode?
    if (a && !c && k=='g') {
      if (gedit) {
	GEDIT('quit');
      } else {
	GEDIT('init');
	showStatus();
      }
    }

    // if in gedit mode and arrow, exit
    if (gedit && (a || k.startsWith('arrow')))
      return GEDIT(k, kc, a, s, c, e);

    // make ctrl click sound
    if ((c && !a && !s && k !== 'control')
	|| kc==13 || kc==8
	|| (37<=kc && kc<=40))
      clickSound(true);

    // editing
    if (kc==13) {
      if (c) {
	scroll(row, SCREEN_ROWS-3, true);
      } else {
	editEnter();
      }
    }
   			      
    if (kc==8) {
      if (c) { // delete line
	scroll(SCREEN_ROWS-3, row);
      } else {
	editBackspace();
      }
    }

    if (c && k=='n') clearline(row, 2);
    if (c && k=='m') col = 2; // CR
    if (c && k=='u') {
      if (1) { // for debugging
	wget.pageid = 1;
	showPage(`
foobar
<a href='works.com'>works</a> <a href='fie.org'> fie</a><a href='fum.sex'>fum </a> <a href='fish.ing'>fish</a> <a href='works.th'>works</a>
`, undefined, wget.pageid, 'http://home.com/');
	return;
	showPage(`
foo
<h1>bar</h1>
fie<b>fum</b>crap<br>
<b>bold<i>italic<br>
still italic</i>back to bold</b>back to default<p>

foo
<h1>bar</h1>
fie<b>fum</b>crap<br>
<b>bold<i>italic<br>
still italic</i>back to bold</b>back to default<p>

`);
	return;
      }

      clearline(0);
      showStatus();
      let u = wget.url[wget.pageid];
      iplot(0, 0, u.substring(0, SCREEN_COLS));
      
      cursorHide();
      row = 0; col = 0;
      cursorShow();
      // debug:
      //CLS();
      //showPage('foobar <a href=foo>bbbb</a> fum');
      //showPage('foobar<h1>Fish</h1>fiefum');
      //findAction();     
    }

    if (c && k=='j') ; // down (rotate?)
    if (c && k=='k') ; // up (rotate?)

    // save screen!
    if (c && k=='w') writeScreen();
    if (c && k=='k') readScreen();
    if (a && k=='arrowup') readScreen();

    // arrow, C-arrow = copy
    let char = screen(row, col);
    if (!a && (37<=kc && kc<=40)) {
      editArrow(kc);
      // drag/trail char to new pos!
      if (c) screen(row, col, char);
    }

    // my extensions
    if ((c || a) && k.length==1)
      editExt(k, kc, a, s, c, e);
   
    // too easy boot? lol
    if (c && k=='r') window.location.reload();
    // tracer
    if (c && a && k=='p') trace = !trace;

    // ALT-
    if (a) {
      

      return;
    }
    // WARNING: NO ALT (below here)
    
    // CTRL-
    if (!c) return;
    
    if (c && k=='c') STOP();
    if (c && k=='x') editCancel();
    if (c && k=='g') PING();
    if (c && k=='l') {
      cursorHide();
      CLS();
      cursorShow();
    }
    if (k=='a') editCopy();
    if (k=='f') click = !click;
    if (k=='q') cursorToggle();
    if (k=='p') showStatus(printerToggle());
    if (k=='t') showStatus(caps = !caps);
    if (k=='o') showStatus(scoff=scoff?0:1);
    if (k=='s') showStatus(scstop=!scstop);
    if (k=='d') showStatus(double=!double);

    if (k=='j') showStatus(column=2-column);

    //if (c) e.preventDefault();
  })

  dom('exp').addEventListener('keypress', function(e) {
    let c=e.ctrlKey,a=e.altKey,s=e.shiftKey;
    let k = e.key.toLowerCase();
    let ch = e.code;
    let kc = e.keyCode; // legacy
    let legc = e.charCode;

    // override all chars in gedit mode!
    if (gedit && k.length==1)
      return GEDIT(k, kc, a, s, c, e);

    //    if (legk > 16) 
    //    alert(`k=${k} legc=${legc} legk=${legk} ch=${ch}`);
    // TODO: use e.code - but it's crap
    // and don't reflect shift
    if (e.keyCode==13) return;
    editChar(legc) // , e.getModifierState("CapsLock"));
    // hmmm, doesn't work?
    //if (c) e.preventDefault();
  });

  if (0) window.onerror = function(e) {
    dom('error', ''+e);
  };
  
  if (0) {
    screen(10, 10, 77);
    screen(12, 12, 3);
    screen(14, 14, 16+5);
    PAPER(7);
    INK(5);
  }
  
  if (0)
    setInterval(_=>{
      for(let i=0; i<100; i++)
	screen(
	  rand(SCREEN_ROWS),
	  rand(SCREEN_COLS),
	  rand(256));
      PAPER(rand(8));
      INK(rand(8));
    }, 0);


  // ORIC BASIC KEYWORDS
  // https://www.defence-force.org/computing/oric/coding/annexe_1/index.htm

  // Note: STR$ indicates a value of 334 for the token. It seems to be
  // hard to put in a byte !
  // NAME	CODE	TYPE
  function OricKeywords(cb) {
    `
ABS	216	
function
AND	209	
operator
ASC	236	
function
ATN	229	
function
AUTO	199	
parameter
CALL	191	
instruction
CHR$	237	
function
CIRCLE	173	
instruction
CLEAR	189	
instruction
CLOAD	182	
instruction
CLS	148	
instruction
CONT	187	
instruction
COS	226	
function
CSAVE	183	
instruction
CURMOV	171	
instruction
CURSET	170	
instruction
DATA	145	
instruction
DEEK	231	
function
DEF	184	
instruction
DIM	147	
instruction
DOKE	138	
instruction
DRAW	172	
instruction
EDIT	129	
instruction
ELSE	200	
instruction
END	128	
instruction
EXP	225	
function
EXPLODE	164	
instruction
FALSE	240	
constant
FILL	175	
instruction
FN	196	
function
FOR	141	
instruction
FRE	218	
function
GET	190	
function
GO	247
instruction
GOSUB	155	
instruction
GOTO	151	
instruction
GRAB	159	
instruction
HEX$	220	
function
HIMEM	158	
instruction
HIRES	162	
instruction
IF	153	
instruction
INK	178	
instruction
INPUT	146	
instruction
INT	215	
function
KEY$	241	
function
LEFT$	244	
function
LEN	233	
function
LET	150	
instruction
LIST	188	
instruction
LLIST	142	
instruction
LN	224	
function
LOG	232	
function
LORES	137	
instruction
LPRINT	143	
instruction
MID$	146	
function
MUSIC	168	
instruction
NEW	193	
instruction
NEXT	144	
instruction
NOT	202	
operator
ON	180	
instruction
OR	210	
operator
PAPER	177	
instruction
PATTERN	174	
instruction
PEEK	230	
function
PI	238	
constant
PING	166	
instruction
PLAY	169	
instruction
PLOT	135	
instruction
POINT	243	
function
POKE	185	
instruction
POP	134	
instruction
POS	219	
function
PRINT	186	
instruction
PULL	136	
instruction
READ	149	
instruction
RECALL	131	
instruction
RELEASE	160	
instruction
REM	157	
instruction
REPEAT	139	
instruction
RESTORE	154	
instruction
RETURN	156	
instruction
RIGHT$	245	
function
RND	223	
function
RUN	152	
instruction
SCRN	242	
function
SGN	214	
function
SHOOT	163	
instruction
SIN	227	
function
SOUND	167	
instruction
SPC	197	
function
SQR	222	
function
STEP	203	
instruction
STOP	179	
instruction
STORE	130	
instruction
STR$	334	
function
TAB	194	
function
TAN	228	
function
TEXT	161	
instruction
THEN	201	
instruction
TO	195	
instruction
TROFF	133	
instruction
TRON	132	
instruction
TRUE	239	
constant
UNTIL	140	
instruction
USR	217	
function
VAL	235	
function
WAIT	181	
instruction
ZAP	165	
instruction
`.replace(/(\S+)\t(\d+)\t\n(\S+)/g,
	  (_, word, code, what)=>
	  cb(word, code, what));
  }

  OricKeywords.name2code = {};
  OricKeywords.code2name = {};
  OricKeywords.type = {};

  OricKeywords.defined = [];
  OricKeywords.status = {};
  OricKeywords.missing = [];
  OricKeywords.innovated = [];
  
  OricKeywords((name, code, type)=>{
    OricKeywords.name2code[name] = code;
    OricKeywords.code2name[code] = name;
    OricKeywords.type[name] = type;
    OricKeywords.type[code] = type;
  });

  // deduce shit
  OricKeywords.missing = new Set();
  for(let k in OricKeywords.name2code) {
    OricKeywords.missing.add(k);
    // assume mssing till removed
    OricKeywords.status[k] = 'missing';
  }
  for(let k in window) {
    // Oric functions are all uppercase!
    
    if (k.toUpperCase() == k) {
      OricKeywords.missing.delete(k);
      OricKeywords.status[k] = 'window';
      
      OricKeywords.defined.push(k);

      let s = '';
      let f = window[k];
      if (typeof f === 'function')
	s += 'function';
      else
	s += 'const?';
      //if !f) continue; // || !f.toString) continue;
      if (typeof f == 'function') {
	f = f.toString();
	f = f.replace(/^function \w+/);
	if (f.length < 20) s += ',named,dummy';
	if (f.match(/implemented/)) s += ',not implemented';
	if (f.match(/(if|while|return|for|=)/)) s += ',DEFINED';
	if (f.match(/native code/)) s += ',native';
      }

      // NEW?
      if (OricKeywords.name2code[k])
	OricKeywords.missing.delete(k);
      else {
	s += ',NEW';
	OricKeywords.innovated.push(k);
      }

      if (s == '') s = 'UNKNOWN';
      
      dom('info', `== ${k} - - ${s}`, 'a');
      OricKeywords.status[k] = s;
    } else{
      //dom('info', `!! ${k}`, 'a');
    }
  }
  // make array out of set!
  OricKeywords.missing = [...OricKeywords.missing];

  dom('info',
      'INNOVATED - '+OricKeywords.innovated.join('\nINNOVATED - '),
      'a');
  dom('info',
      'MISSING - '+OricKeywords.missing.join('\nMISSING - '),
      'a');
  dom('info',
      Object.keys(OricKeywords.status).map(
	k=>`STATUS - - ${k} - - ${OricKeywords.status[k]}\n`).join(''),
      'a');

  function OKK(s) {
    return Object.keys(OricKeywords.status)
      .filter(
	k=>!!OricKeywords.status[k].match(s));
  }
  function OKC(s) {
    return OKK(s).length;
  }
  dom('info',
      '\nORIC ATMOS BASIC SIMULATOR STATUS'+
      '\n================================='+
      '\nMissing: '+OricKeywords.missing.length+
      '\nDefined: '+OKC(/defined/i)+
      '\nNative: '+OKC('native')+
      '\nNamed: '+OKC('named')+
      '\nNotImpl: '+OKC('impl')+
      '\nInnovated: '+OricKeywords.innovated.length+
      '\n----------------',
      'p');

  // create the missing funcs to throw error
  OricKeywords.missing.forEach(
    n=>window[n]=()=>implemented_error(n));

  // remove non-basic names... not extensions
  'DBG,OKK,OKC,TEMPORARY,PERSISTENT,EVAL,HTML,STORE,GEDIT'.split(',').map(
    n=>{
      delete OricKeywords.status[n];
    });

  // TODO: move? maybe move symbols out to oric-exp?
  var ORIC_TOKENZ = ',' +
      Object.keys(OricKeywords.name2code).join(',') + ',';

</script>

<!--
<!--



l REM***MUSIC***
10 FOR 0=0 T0 6
20 FOR N=l T0 12
30 MUSIC l,O,N,10
40 PLAY 3,0,7,0
50 WAIT 30 
60 NEXT N
70 NEXT O
80 PLAY 0,0,0,0
90 EXPLODE

  -->

<script>
</script>

<script>
  // place this at end to log runtime errors at end!
  // this will catch any runtime errors
  // syntax errors excluded (see above)
  window.onerror = (...args)=>{
    let t = args.toString();
    // let t = ''+args[0];
    let b = document.body;
    t = `<div style='color:red;background:white;'>E:${t}</div>`;
    b.insertAdjacentHTML('afterbegin', t);
    return false;
  };
</script>

</body>

</html>

