<html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>

<style>
/*default version*/
@font-face {
	font-family: 'oric-atmos';
	src: url('oric-atmos.ttf'); 
	src: 
		local('oric-atmos'),
		local('oric-atmos'),
		url('oric-atmos.ttf') 
		format('truetype');
}
/*container element*/
pre, span, div { font-family: 'oric-atmos', monospace; }
/*span elements inside the container div*/

  span {
      display: inline-block;
      font-size: 1.5rem;
      text-align: left;
  }
  
  .char {
      width: 0.30rem;
      border: 0px;
      padding-left: 0.25rem;
  }

  /* TODO: investigate!
  {
       font-size: 12px;
       letter-spacing: 0.015em;
       word-spacing: 0.001em;
  }
 */
  /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform */
  /* we can get double height! but only
     on each char; the problem is the nested
     elements - do it twice and it'll double
     again!

     TODO: I couldn't find a way to translate
     the it and 'clip-y' seems 'overflow-y: hidden isn't working...
 */
  .double {
      width: 0.30rem;
      border: 0px;
      padding-left: 0.25rem;

      //max-height: 45px;
      transform:
	  scale(1, 2)
	       /* translateY(15px); */
      ;
      overflow-x: visible;
      /* overflow-y: hidden; /* doesn't work */
  }
</style>
  
<script src='misc.js'>
</script>

</head>

<body style='background-color: black; color: white;'>
<div style='width:100%'>
  <img width='20%' src='oric-logo-black-export.svg'/>
  <div style='float:right; top:0; width:80%; text-align:center; font-decoration:bold; text-justify:inter-word; font-size:3rem;'>W E B - B A S I C</div>
</div>

</br>

<center>
  <div id='screen' style='width:83%; color: black; font-size: 1.05em; text-align: left;
'></div>
</center>

<br><br>
<!-- id=exp is magical for jsconsole - it returns focus there -->
<input id='exp' autofocus style='background:black; color:black; border:none;'>
<input id="file" type="file"/>
<script>
  // inspired by https://stackoverflow.com/questions/16495125/parsing-binary-files-in-client-side-js
  // REFERENCE:
  //  https://developer.mozilla.org/en-US/docs/Web/API/FileReader
  // readAsBinaryString
  function readFile() {
    let fileInput = dom('file');
    let fReader = new FileReader();

    fReader.onload = function(e) {
      /// <-- this contains an ArrayBuffer
      console.log(e.target.result);
    }

    // onloadend
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer
    fileInput.onchange = function(e) {
      let file = this.files[0];
      fReader.readAsArrayBuffer(file);
    }
  }
</script>

<br>
ROW: <span id='row'></span>
COL: <span id='col'></span>
<br>
LINE: <span id='line'></span>
<br>
ERROR: <span id='stats'></span>
<br>
ERROR: <span id='error' style='color:red;'></span>
<br>
VARS: <span id='vars'></span>
<br>
INFO:<br><span id='info'></span>
<br>
<br>
<script src='jsconsole.js'>
  //loadScript('jsconsole.js');
</script>
  
<script>
  let vars = {},
      stack = [], // [ [lno, restline] ...]
      line = '',
      lineno = 0,
      caps = true,
      click = true,
      column = false,
      trace = false,
      row = 1,
      col = 2;

  const ESC = 27;

  function boot() {
    stop('noprompt');
    
    // init
    vars = {};
    stack = [];
    line = '';
    lineno = 0;
    caps = true
    click = true
    column = false
    trace = false;
    row = 1;
    col = 0;
    
    showStatus();

    print(`
ORIC EXTENDED BASIC Vl.1
(C) 1983 TANGERINE

373188 BYTES FREE
`);
  }

  // https://osdk.org/index.php?page=articles&ref=ART9.
  // From a memory point of view, TEXT mode requires 1120 bytes for display (28 lines of 40 columns)
  // and 1920 bytes for storing the character set
  // 1120 bytes for the screen (from #BB80 to #BFDF)
  // 1024 bytes for the default character set (from #B400 to #B7FF)
  // 896 bytes for the secondary ("alternate") character set (from #B800 to #BB7F)
  // This makes a total of 3040 bytes.
  
  // So if the first byte of the screen (#BB80), contains the value 65 (ASCII code for the upper case A letter), we know that this block of 6x8 pixels will be filled with graphical information stored at the address #B400+(8*65).

  // TODO: define imgs for each character?
  // then we can 'poke' to change them?

  // TODO: calling twice messes something up
  function TEXT() {
    for(let row=0; row<28; row++) {
      let r = '';
      for(let col=39; col>=0; col--) {
	c = '&nbsp;';
	let id = `r${row}c${col}`;
	r = `<span id='a${id}'><span id='c${id}' class='char'>${c}</span>${r}</span>`;
      }
      dom('screen', r+'</br>', 'ah');
    }
    cache = {};
  }
  // mode: 0 or 1
  function LORES(mode) {
    throw "LORES: Not implemented!";
  }

  // Structurally it is very similar to the TEXT mode, with 40 bytes per line, with each byte representing 6 pixels for a total of 240 pixels in width.
  // The main difference is that each line is only one pixel tall instead of 8, so there are 200 of these.
  // The actual graphical resolution is 240x200, but the screen has an additional area at the bottom containing 3 lines of TEXT mode.

  // From a memory point of view, HIRES mode is much more voracious:
  // 8000 bytes for the HIRES part of the screen (from #A000 to #BF3F)
  // 120 bytes for the TEXT part of the screen screen (from #BF68 to #BFDF)
  // 42 bytes lost between the HIRES and TEXT parts of the screen (from #BF40 to #BF67)
  // 1024 bytes for the default character set (from #9800 to #9BFF)
  // 1024 bytes for the secondary ("alternate") character set (from #9C00 to #9FFF)
  // This makes a total of 10210 bytes.

  // http://twilighte.oric.org/twinew/ula.htm
  function HIRES() {
    implemented_error('HIRES');
    throw "HIRES: Not implemented!";
  }
  
  const color = {
    black:   '#000000', 0: '#000000',
    red:     '#FF0000', 1: '#FF0000',
    green:   '#00FF00', 2: '#00FF00',
    yellow:  '#FFFF00', 3: '#FFFF00',
    blue:    '#0000FF', 4: '#0000FF',
    magnenta:'#FF00FF', 5: '#FF00FF',
    cyan:    '#00FFFF', 6: '#00FFFF',
    white:   '#FFFFFF', 7: '#FFFFFF',
  };
    
  let inverse = n=>7-n;
  
  function domc(id) {
    domc.cache = domc.cache || {};
    let d = domc.cache[id];
    if (!d) {
      d = dom(id);
      domc.cache[id];
    }
    return d;
  }
  
  // this is like equivalent of POKE!
  function screen(row, col, ch) {
    let dc = domc(`cr${row}c${col}`);
    // read screen?
    if (ch === undefined) {
      if (typeof dc.screenchar == 'number')
	return dc.screenchar;
      else
	return dc.screenchar = dc.textContent.charCodeAt(0);
    }
    dc.screenchar = ch;

    let da = domc(`ar${row}c${col}`);

    let t;

    // interpret char/attribute
    let c = ch & 0x7f;
    if (c >= 32) { // ascii
      t = ch & 0x7f;
    } else if (c < 8) { // ink
      let fg = c & 0x07;
      if (c > 127) fg = inverse(fg);
      da.style.color=color[fg];
      t = 32; // blankk it out
    } else if (c < 16) {
      // Character Set modifier
      // 8  Use Standard Charset
      // 9  Use Alternate Charset
      // 10 Use Double Size Standard Charset
      // 11 Use Double Size Alternate Charset
      // 12 Use Blinking Standard Charset
      // 13 Use Blinking Alternate Charset
      // 14 Use Double Size Blinking Standard Charset
      // 15 Use Double Size Blinking Alternate Char
      let alt = c & 1;
      let double = c & 2;
      let blink = c & 4;
      // TODO: alt - complicated (edit font?)
      // https://en.fontke.com/font/10042736/
      // https://github.com/Zigazou/miedit
      // https://github.com/Zigazou/miedit/tree/master/font
      
    } else if (c < 24) { // 16-23 paper
      let bg = c & 0x07;
      if (bg > 127) bg = inverse(bg);
      da.style.backgroundColor=color[bg];
      t = 32; // blankk it out
    } else {
      // TODO: mode switching
      // idea: make screen garbled? lol
      // Video control attributes
      // 24-27 Switch to TEXT mode (60 Hz)
      // 28-31 Switch to HIRES mode (60 Hz)
    }

    if (t == 32)
      dc.innerHTML = '&nbsp;';
    else if (t !== undefined)
      dc.textContent = String.fromCharCode(t);
  }

  function INK(color) {
    // skip status line
    for(let row=1; row<28; row++) {
      screen(row, 1, color);
    }
  }
  function PAPER(color) {
    // skip status line
    for(let row=1; row<28; row++) {
      screen(row, 0, 16+color);
    }
  }

  function exmple_PAPER() {
    return `
l0 FOR I=0 TO 7 
20 INK I 
30 FOR J=0 TO 7 
40 PAPER J 
50 WAIT 50 
60 NEXT J 
70 NEXT I 
80 INK 0 
`;
  }

  function example_PRINT_AT() {
    return `
10 FOR X=2 TO 30 
20 PRINT @X,10;·• WHIZZ2" 
30 NEXT X
`;
  }

  // TODO: ORIC used to have blinking cursor
  // also has 'cursor' varaible controlled by
  let cursor = true;
  let raw = false;
  function cursorToggle(wantOn) {
    if (wantOn === undefined) {
      cursor = !cursor;
    } else if (typeof wantOn === 'string') {
      cursor = (wantOn.toLowerCase() === 'on');
    } else {
      cursor = !!wantOn;
    }

    if (!cursor) cursorHide();
    // don't show cursor here as this run as soon as key presseed leaving traces
  }

  // cursorHide(),cursorShow() - don't call as it's managed by the system functions call cursorToggle() for your intent
  let cursorVisible = false;
  function cursorHide() {
    if (!cursorVisible) return;
    cursorVisible = false;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = '';
    d.style.color = '';
  }
  function cursorShow() {
    if (!cursor || cursorVisible) return;
    cursorVisible = true;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = 'black';
    d.style.color = 'white';
  }
  
  let dirty = 0;
  function princ(c) {
    if (typeof(c) !== 'number')
      alert('princ: only take nubmers: ' +  c);
    dirty++;

    // TODO: how to handle inverse?
    let ch = c & 0x7f;
    if (ch === ESC) return raw = true;
      
    if (raw || ch >= 32) {
      screen(row, col, c);
      col++;
    }
    raw = false;

    if (ch == 10) { row++; col = 2; }

    // backspace
    if (ch == 8) {
      col--;
      if (col < 2) col = 2;
      // TODO: I don't think backspace wraps?
      //if (col < 2) { col = 39; row--; }
      //if (row < 1) { col = 2; row = 1; }
      screen(row, col, 32);
    }

    if (col >= 40) {
      col = 2;
      row++;
    }

    // scroll!
    if (row >= 28) {
      let start = Date.now();
      for(let r=2; r<28; r++) {
	for(let c=0; c<40; c++) {
	  let old = screen(r-1, c);
	  let nw = screen(r,c);
	  if (nw != old)
	    screen(r-1, c, nw);
	}
      }
      // TODO: if not hidden column mode?
      row = 27;
      for(let c=2; c<40; c++) {
	screen(row, c, 32);
      }
      dom('info', 'scroll time='+(Date.now()-start), 'lp');
    }
  }

  // 20LETSEL=0 => 20 LET SEL = 0
  // TODO: 63999 max
  //  
  // integer -32767 to 32768
  // A%
  // A$

  // DIM varname(exp, ...)
  function DIM(n, ...dims) {
    let v = 0.0;
    if (n.match(/^\w+\%/)) v = 0;
    if (n.match(/^\w+\$/)) v = '';
    
    function gen(dim, ...dims) {
      if (!dim) return v;
      return [...Array(dim)]
	.map(_=>gen(...dims));
    }
    
    vars[n] = gen(...dims);
  }

  function LET(n) {
    let v = this;
    v = v.replace(/^\s*LET\s*\S+\s*=\s*/, '');
    if (trace) print('LET: ' + v);
    let r = EVAL(v);
    if (r === undefined) return;

    if (n.endsWith('%')) r = Math.floor(r);
    if (n.endsWith('$')) r = ''+r;

    // indexing (interpolate using fixpoint!)
    let lastn = n;
    while (lastn != (n = n.replace(
      /\[([^\[\]]*)\]/g, (_,i)=>'['+EVAL(i)+']'))) {
      if (trace) print('IX: ' + n);
      lastn = n;
    }

    // set
    if (trace) print('SET: ' + n);
    let path = n.replace(/[\[\]]/g, ' ').trim()
	.split(/\s+/g);
    if (trace) print('PATH: ' + JSON.stringify(path));
    let nv = vars;
    let x;
    let lastx = path.shift();
    while ((x = path.shift()) !== undefined) {
      if (trace) print('LOOP lastx: ' + lastx);
      if (trace) print('LOOP x: ' + x);
      nv = nv[lastx];
      lastx = x;
    }
    if (trace) print('SET: ' + (nv == vars) + ' ' + lastx);
    nv[lastx] = r;
  }

  function EVAL(x) {
    try {
      if (trace) print('VARS: ' + JSON.stringify(vars));
      // pow!
      x = x.replace(/\^/g, '**');
      if (trace) print('EXP: ' + x);
      // TOOD: not correct comparisons
      // as ORIC returns 0/-1 for false/true
      if (x.match(/(<|=|>)/))
	return implemented_error('comparisons');
      let r = (function(ATMOSexp){
	// fast cheat!
	with (vars) {
	  return eval(ATMOSexp);
	}
      })(x);
      if (trace) print('-->: ' + r);
      return r;
    } catch(e) {
      if (!trace) print('EVAL: ' + x);
      eval_error('' + e);
      //stop();
      throw e;
    }
  }
  
  function val(n) {
    //n = n.substring(0, 2);
    return vars[n];
  }
  
  // Also CTRL-L
  function CLS() {
    let start = Date.now();
    // TODO: does it scroll colors?
    // don't touch mode-line
    for(let row=1; row<28; row++) {
      for(let col=2; col<40; col++) {
	screen(row, col, 32);
      }
    }
    row = 1; col = 2; raw = false;
    //dom('error', 'CLS time ' + (Date.now()-start));
  }

  // 20 INPUT"ENTER SALE PRICE";SELL
  function INPUT(prompt, v) {
  }

  // #FFFFF 
  // PRINT "FOO"BAR"
  // PRINT "4*3="; 4*3
  // PRINT "FOO";"BAR" => FOOBAR
  // ?35 == PRINT 35
  // PRINT 1;2 => <spc>1<spc><spc>2<spc>
  // 40 PRINT"THE CODE FOR "A$"="ASC(A$)
  // PRINT "foo",
  // PRINT "bar"    > fooo       bar 
  // 20 PRINT @X,10;·• WHIZZ2" 
  function print(txt, nonewline) {
    if (typeof txt == 'number')
      txt = ' ' + txt + ' ';
    txt = '' + txt;
    for(let i=0; i<txt.length; i++)
      princ(txt.charCodeAt(i));
    if (!nonewline) princ(10);
  }

  function tab(n) {
    while ((col-2) % 8 !== 0)
      princ(32);
  }
  
  function PRINT() {
    let line = this;
    line = line.replace(/^PRINT\s*/, '');
    line = line.trim();

    let exp = '', mode = 'normal', par = '';
    let nonewline = false;
    for(let i=0; i<line.length; i++) {
      let c = line[i];
      if (trace) print('PRINT.c: ' + c);

      function finish(ev) {
	if (exp.length)
	  print(ev?EVAL(exp):exp, true)
	exp = '';
	if (c === ',') tab();
      }
      
      switch(mode) {
      case 'normal': {
	switch(c) {
	case ',':
	case ';': 
	case ' ': finish(true); break;
	case '\\': return unexpected_error('\\');
	case '"': finish(true); mode = 'string'; par += '"'; break;
	case '(': mode = 'expr'; par += ')'; break;
	case '[': mode = 'expr'; par += ']'; break;
	default: exp += c;
	}
	break;
      }
      case 'string': {
	if (c=='"') {
	  if (exp.length)
	    print(exp, true);
	  exp = '';
	  mode = 'normal';
	} else {
	  exp += c;
	}
	break;
      }
	// TOOD: too simple
      case 'expr': {
	if (par)
	  if (')]"'.indexOf(c) >= 0) {
	    let e = par[par.length-1];
	    if (e !== c)
	      return unmatched_paren_error(e, c);
	    else
	      par = par.substring(0, par.length-1);
	  }
	
	switch(c) {
	case '\\': return unexpected_error('\\');
	case ';': if (par) return unexpected_error(';');
	  
	case '(': par += ')'; break;
	case '[': par += ']'; break;
	case '"': par += '"'; break;
	  
	case ',':
	case ' ': {
	  if (exp.length && !par.length) {
	    print(EVAL(exp), true);
	    exp = ''
	    mode = 'normal';
	  }
	  if (c === ',') tab();
	  break;
	}
	default: exp += c;
	}
	break;
      }
      }
      if (c !== ' ') nonewline = false;
      if (c === ';') nonewline = true;
    }

    // cleanup
    if (exp.length) {
      // TODO: missing " ?
      if (mode === 'string')
	print(exp, true);
      else
	print(EVAL(exp), true)
    }
    if (!nonewline)
      princ(10);
  }

  function syntax_error(cmd) {
    print('?SYNTAX ERROR: ' + cmd);
  }

  function implemented_error(s) {
    print('?NOT IMPLEMENTED ERROR: ' + s);
    throw 'Not implemented';
  }
  
  function unexpected_error(s) {
    print('?UNEXPECTED ERROR: ' + s);
  }

  function unmatched_error(e, g) {
    print('?MATCHING ERROR, expected: ' + e + ' got: ' +g);
  }

  function eval_error(e) {
    print('?EVAL ERROR (' + e +')');
  }
  
  // TODO: not original?
  function cont_error() {
    print('?CAN\'T CONTINUE');
  }

  function illegal_quantity_error() {
    print('?ILLEGAL QUANTITY ERROR');
  }
  
  // TODO: Basic Lines max 80 chars bell at 79?

  // LIST -100
  // LIST 100-
  // LIST 100-200

  // TODO: sorted?
  let lines = {

    1: 'PRINT "HELLO!"',
    2: 'END',
    
    7: 'LET A=0',
    10: 'PRINT "HELLO"',
    10: 'PRINT ".";',
    12: 'LET A=A+1',
    15: 'GOSUB 100',
    20: 'GOTO 9',
    100: 'PRINT A;',
    110: 'RETURN',
  };

  function running() {
    return !!RUN.interval;
  }
  
  function LIST(n) {
    line = '';
    lineno = 0;
    RUN.interval = setInterval(_=>{

      for(let i=0; i>=0; i--) {
      nextline();
      if (!line)
	stop();
      else
	print(lineno + ' ' + line);
      }
      
    }, 1);
  }

  function saveline(lno, line) {
    if (!lno) return;
    if (trace) print('saveline.lno: ' + lno);
    if (trace) print('saveline.line: ' + line);

    let l = line.replace(/^\d+\s*/, '');
    if (trace) print('saveline.l: ' + l);

    // store instruction
    lines[lno] = l;
  }
  
  function EDIT(lno) {
    lno = lno || lineno;
    let line = lines[lno]
    // TODO: error?
    if (!line) return;

    print(lno + ' ' + line);
    cursorMove('u');
  }
  
  function RUN(lno) {
    // init
    lineno = (+lno || 0) - 1;
    line = '';
    stack = [];
    vars = {}
    
    cont();
  }
  
  function END() {
    stop('noprompt');
  }
  
  function nextline() {
    // crazy linear search for next!
    // you could goto any number
    // it just find the next numerically
    line = '';
    while (!line && lineno < 65536) {
      lineno++;
      // TODO: these aren't guaranteed to be in order? only when for-in!!!
      line = lines[lineno];
    }
    if (line === undefined) line = '';
  }

  function cont() {
    RUN.interval = setInterval(_=>{
      let start = Date.now();
      do {
	nextline();
	if (line && trace) print(lineno + ' ' + line)
	if (!run(line)) stop();
      } while (Date.now() - start < 20);
    }, 1);
  }
  
  function CONT() {
    if (!CONT.lineno)
      return cont_error();

    lineno = CONT.lineno;
    line = CONT.line;
    delete CONT.lineno;
    delete CONT.line;

    cont();
  }
  function CONTINUE() { CONT(); }
  
  function ON_GOTO() { }

  function GOSUB(lno) {
    stack.push([lineno, line]);
    lineno = lno-1;
    line = '';
  }
  function RETURN() {
    [lineno, line] = stack.pop();
  }    

  function IF_THEN_ELSE(e, t, e) {
    let line = this;
    
  }
  
  function REPEAT() {}
  function UNTIL() {}

  function stop(noprompt) {
    print('STOPPED!');
    let wasrunning = running();
    if (col > 2) princ(10);
    if (wasrunning) {
      clearInterval(RUN.interval);
      delete RUN.interval;
      if (!noprompt) prompt();
    }
    line = '';
    return wasrunning;
  }
  
  function GOTO(lno) {
    lineno = lno-1;
  }

  function ctrlC() {
    cursorHide();
    let lno = lineno;
    let l = line;
    if (stop('noprompt')) {
      print('?INTERUPTED AT LINE ' + lineno)
      CONT.lineno = lno;
      CONT.line = l;
    }
    cursorShow();
  }
  
  // WAIT 100 = 1s
  function WAIT(decaseconds) {
  }
  
  function example_VAT() {
    return `
10 REM *VAT Calculation* 
20 INPUT"ENTER SALE PRICE";SELL 
30 LET VAT=0. 15*SELL 
40 LET PRICE=SELL+VAT
50 PRINT "TOTAL=";PRICE 
60 'Round agan for next calculation
70 WAIT 500:CLS:GOTO 20
`;
  }

  function  example_NAME() {
    return `
10 A$="0RIC" 
120 LET Al$="BASI·C" 
130 LET LAST$="LESSON" 
140 INPUT"ENTER YOUR NAME,PLEASE";NAME$ 
150 CLS:PRINT A$;" ";Al$;" ";LAST$ 
160 PRINT "FOR ";NAME$
`;
  }

  function example_KEY() {
    return `
10 PRINT"PRESS A KEY" 
20 GET A$ 
30 PRINT"YOU PRESSED "A$ 
40 PRINT"THE CODE FOR "A$"="ASC(A$) 
50 GOTO 10
`;
  }

  function example_DEF() {
    return`
5 REM*Define Function M to convert feet 
to metres 
10 DEF FNM(FEET)=FEET*0.3048 
20 INPUT"HOW MANY FEET";X 
30 M=FNM(X) 
40 PRINT X;"FEET EQUAL";M;" METRES"
`;
}

  function example_FOR() {
    return `
10 FOR L=l TO 5:PRINT L*L:NEXT L 

10 FOR L=10 TO 5 STEP-l:PRINT L*L:NEXT 

10 CLS 
20 FOR LOOP=0 TO 25 
30 PRINT CHR$(65+LOOP)+CHRS(97+LOOP); 
40 NEXT LOOP 
`;
  }

  function example_READ_DATA() {
    return `
10 REM*READ o.nd DATA* 
20 FOR 0=0 TO 6 
30 READ D$ 
40 PR1NT D$ 
50 NEXT 
60 REM . . . lots more program 
70 ' 
2000 DATA MONDAY,TUESDAY,WEDNESDAY,THUR 
SDAY 
2010 REM ... more program in between 
3000 DATA FRIDAY, SATURDAY,SUNDAY 
4000 REM .. co.n do it 0.90.in 
4010 RESTORE 
4020 FOR K=l TO 7 
4030 READ DAY$:PRINT DAY$:NEXT
`;
  }

  function example_DIM() {
    return `
10 INPUT"HOW MANY NAMES" ;N% 
20 DIM NAME$(N%):DIM AGE(N%)
30 CLS:SLJM=0 
40 FOR K=1 TO N%
50 PRINT "ENTER NAME t'-10. "K 
60 INPUT NAME$[K]
70 PRINT NAME$[K]"'S AGE ?" 
80 INPUT AGE[K] :SLJM=SLJM+AGE[K]
80 CLS 
100 NEXT K 
110 FOR K=N% TO 1 STEP -1 
120 PRINT :PR1NT NAME$[K]" JS";
130 NEXT K
`;
  }
  
  function example_MULTIDIM() {
    return `
10 DIM NXC10,3) 
20 CLS 
30 FOR K=l TO 10 
40 ~OR J=l TO 3 
50 NxCK,JJ=K"J 
60 PRINT NxCK,JJ 
70 NEXT J 
80 PRINT 
90 NEXT K
`;
  }

  function example_BUBBLESORT() {
    return `
5 REM*NUMERIC BUBBLE SORT** 
10 CLS:LET J=15 'Number of items 
20 DIM NUMCJJ'ATray foT numbeTs 
30 'Example numbers generated here" 
40 FOR K=0 TO J 
50 LET NUMCKJ=RNDC1J*1000 
60 PRINT NUMCKJ 
70 NEXT K 
99 ' 
100 REM*SORT*ROUTINE* 
101 ' 
110 FOR M=l TO CJ-lJ 
120 FOR N=M TO J 
125 REM If correct ordeT 
already,then skip 
130 IF NUMCMJ<NUMCNJ THEN 170 
135 REM Incorrect order,so swap 
140 TEMP=NUMCMJ 
150 NUMCMJ=NUMCNJ 
160 NUMCNJ=TEMP 
170 NEXT N 
180 NEXT M 
189 ' 
190 REM**ENDSORT** 
191 ' 
200 REM *Print sorted list* 
210 CLS:PRINT ''SORTED LIST:" 
220 FOR K::::JTO J 
230 PRINT NUMCKJ 
240 NEXT K 
`;
  }

  // loop is completed, the address is removed, and a subsequent NEXT will 
  // activate a jump to the address now on the top of the pile. The stack can only 
  // hold 10 addresses, and more than 10 loops will give an ?OUT OF MEMOR
  
  function READ() {}
  function DATA() {}
  function RESTOR() {}
  
  function FOR_TO_STEP() {}
  function NEXT() {}

  // GET K$
  function GET() {}
  function READ() {}
  function DATA() {}

  function ASC() {}

  function CHR$() {}

  function STR$() {}

  // evaluated first, before any other calculations are worked out. 
  //The other string function for numeric conversion is HEX$. This returns 
  // the string form of the hexadecimal number equivalent to the argument. For 
  // example, HEX$C4I8) returns #IA2. Since hexadecimal numbers can only be 
  // integers between 0 and 65535, any numbers outside that range will give a 
  // ?ILLEGAL QUANTITY ERROR, and any non-integer values will be auto-
  // matically rounded.

  function HEX$() {}

  function LENGTH(s) { return s.length; }
  function LEFT$(s, n) {}
  function RIGHT$(s, n) {}
  function MID$(s, a, b) {}
  
  function VAL() {}
  
  function INT() {}
  
  function PING() {}
  

  // REM comment
  // ' commment
  function REM() {}

  // MATH
  // + - * / ^
  
  // Oric BASIC has the following built-in numeric functions: 
  ABS = Math.abs;
  ATN = Math.atan;
  COS = Math.cos;
  EXP = Math.exp;
  INT = Math.floor;
  LN = Math.ln;
  LOG = Math.ln10;
  const PI = Math.PI;
  SGN = n=>(n>0)?+1:(n<0)?-1:0;
  SIN = Math.sin;
  SQR = Math.sqrt;
  TAN = Math.tan;
  function RND(n) {
    if (!n) return Math.random();
    return Math.floor(n * Math.random());
  }
  function RANDOMIZE() {}

  // tested by means of conditional operators: 
  // Equal to 
  // <> Not equal to 
  // > Greater than 
  // < Less than 
  // >= Greater than or equal to 
  // < = Less than or equal to 
  // These operate much as you would expect for numeric values. Two things 
  // need to be remembered, however. The fir

  // 10 DEF FNMCFEETJ=FEET*0.3048 
  function DEFFN(n, exp) {}

  function AND() {}
  function OR() {}
  function NOT() {}

  function example_ON_GOTO() {
    return `
10 l NPUT" ENTER 1 .. 2 OR 3_, PLEASE' ' ;N 
20 ON N GOTO 150,200,300 
140 RP1 
159 PRINT "LINE 150 FROM N=J";GClTO 10 
190 REM 
200 PRINT "LINE 200 FROM N=2":GOTO 10 
290 REM 
300 PRINT "LINE 300 FROM N=3" :GOTO 10
`;
  }

  function TAB() {}
  function PEEK() {}
  function POKE() {}

  function CSAVE() {}

  function CLOAD() {}
  function STORE() {}
  function RECALL() {}
  
  function example_TAB() {
    return `
10 FOR 1=0 TO 5 
20 PRINT TABCIJ; "HELLO" 
30 NEXT I 
HELLO 
HELLO 
 HELLO 
  HELLO 
   HELLO 
    HELLO
`;
  }
  
  // sounds
  // https://bulba.untergrund.net/emulator_e.htm
  // The PLAY command allows you to mix tones and gives access to eight preset envelope shapes.
  function PLAY() {}
  // After using MUSIC and SOUND to set channel and select the tones and noise you want, you use PLAY to mix the channels, select an envelope and control the duration of the final sound. In this way, quite complex sounds can be built up even considering the limitations of the single voice and the pre-set envelopes. The three main sound commands can be used in programs written in
  function MUSIC() {}
  function SOUND() {}

  function ZAP() {}
  function PING() {}
  function SHOOT() {} // "snare-drum"
  function EXPLODE() {}


</script>

<script>
  function rand(n) {
    return Math.floor(Math.random()*n);
  }
  
  TEXT();
  CLS();

  run('boot');

  let lastnow = Date.now();
  let lastrun = 0;
  setInterval(_=>{
    dom('line', line);
    dom('row', row);
    dom('col', col);
    dom('vars', JSON.stringify(vars));
    
    let now = Date.now();
    dom('stats', 'Statements: '+run.count+
	' sps= ' + Math.floor(1000*(run.count-lastrun)/(now-lastnow)));
    
    lastnow = now;
    lastrun = run.count;
  }, 100);
  // clear initial error
  dom('error', '');
  
  function editChar(ch) {
    cursorHide();
    let c = String.fromCharCode(ch);
    // ignore keyboard setting
    if (caps)
      c = c.toUpperCase();
    else
      c = c.toLowerCase();
    line += c;
    princ(c.charCodeAt(0)); // lol
    cursorShow();
  }    

  function editEnter() {
    cursorHide();
    princ(10);
    run(line);
    line = '';
  }

  // basically make other arguments splittable
  function quoteStrings(line) {
    return line.replace(
      /\".?\"/g,
      s=>s.replace(/!/g, '!!')
	.replace(/ /g, '!s!')
	.replace(/:/g, '!c!')
      	.replace(/\(/g, '!po!')
        .replace(/=/g, '!e!')
        .replace(/,/g, '!com!')
    );
  }
  function unquoteStrings(line) {
    return line.replace(
      s=>s.replace(/!c!/g, ':')
	.replace(/!s!/g, ' ')
      	.replace(/!po!/g, '(')
        .replace(/!pc!/g, ')')
        .replace(/!e!/g, '=')
        .replace(/!com!)/g, ',')
	.replace(/!!/g, '!'));
  }

  function prompt(noprompt) {
    if (!noprompt) print('Ready');
    cursorShow();
  }
  // interprets and runs one line
  // returns true if ok
  // END return false
  function run(line) {
    let orig = line;
    if (!line || line === '')
      return cursorShow();

    // NN PRINT ... new line?
    let linedef = line.match(/^(\d+)\s(.*)$/);
    if (linedef) {
      saveline(+linedef[1], linedef[2]);
      return prompt();
    }

    line = line.trim();
    line = quoteStrings(line);

    if (trace) print('LINE: ' + line);
    let many = line.split(':');
    if (trace) print('MANY: ' + many.length);
    // TODO: incorrect, and can't CTRL-C!
    if (many.length > 1) {
      let r= many.map(unquoteStrings)
	  .some(x=>!run_h(x));
      return r;
    }

    let cmd = run_h(line, orig);
    
    // if it's not running in background
    if (!running()) prompt(cmd === 'EDIT');
    return true;
  }
  // internal: takes quotedStrings param
  function run_h(line, orig) {
    run.count++

    // rough parameter extraction
    let a = line.split(/[\s;=\(\),]+\s*/g);
    if (trace) print('------' + a.join(' | '));
    a = a.map(unquoteStrings);
    if (trace) print('------' + a.join(' | '));
    // make numbers great again
    a = a.map(x=>(+x==x?+x:x));
    if (trace) print('------' + a.join(' | '));

    let cmd = a.shift();

    // call function
    let f = window[cmd];
    if (trace) print('LINE: ' + line);
    if (f) {
      try {
	f.apply(orig, a);
      } catch(e) {
	// TOOD: make into error?
	// simplify error handl: just throw strings!
      }
    } else {
      syntax_error(cmd);
    }

    return  cmd;
  }
  run.count = 0;
  
  function editBackspace() {
    cursorHide();
    line = line.substring(0, line.length-1);
    princ(8);
    cursorShow();
  }
  
  function editCancel() {
    cursorHide();
    line = '';
    princ(10);
    cursorShow();
  }

  function editCopy() {
    let c = screen(row, col);
    editChar(c);
  }

  let arrows = {l:37, u:38, r:39, d:40};
  function cursorMove(direction, steps=1) {
    direction = direction.toLowerCase();
    let c = arrows[direction[0]];
    while(steps--)
      editArrow(c);
  }
  function editArrow(ch) {
    cursorHide();
    switch(ch) {
    case 37: col--; break; // left
    case 38: row--; break; // up
    case 39: col++; break; // right
    case 40: row++; break; // down
    }
    // move cursor, wrap around (?)
    // TODO: columns mode?
    if (col < 2) col = 39;
    if (col > 39) col = 2;
    if (row < 0) row = 27;
    if (row > 27) row = 0;
    cursorShow();
  }

  function showStatus() {
    // save ---
    let r = row, c = col;
    row = 0;
    col = 36;

    // make modeline black w white text
    screen(0, 0, 0);
    screen(0, 1, 7);
    
    // CTRL-Q: toggle cursor
    print(caps?'CAPS':'    ', true);

    // TODO: column enable disable CTRL-J
    if (column) {
    } else {
    }

    // --- and restore
    row = r;
    col = c;
  }
  
  dom('exp').addEventListener('keydown', function(e) {
    let c = e.ctrlKey, k = e.key.toLowerCase();
    let s = e.shiftKey, ch = e.code;
    let kc = e.keyCode;
    if (kc==13) editEnter();
    if (kc==8) editBackspace();
    if (c && k=='c') ctrlC();
    if (c && k=='x') editCancel();
    if (c && k=='l') {
      cursorHide();
      CLS();
      cursorShow();
    }
    if (c && k=='a') editCopy();
    if (c && k=='f') click = !click;
    if (c && k=='q') cursorToggle();
    if (c && k=='t') showStatus(caps = !caps);
    if (c && k=='j') showStatus(column = !column);
    if (37 <= kc && kc <= 40) editArrow(kc);

    // my extensions
    if (c && k=='r') window.location.reload();
    if (c && k=='p') trace = !trace;

    if (c) e.preventDefault();
  })

  dom('exp').addEventListener('keypress', function(e) {
    let c = e.ctrlKey, k = e.key; s = e.shiftKey;
    let legc = e.charCode, legk = e.keyCode;
    let ch = e.code;
    //    if (legk > 16) 
    //    alert(`k=${k} legc=${legc} legk=${legk} ch=${ch}`);
    // TODO: use e.code - but it's crap
    // and don't reflect shift
    if (e.keyCode==13) return;
    editChar(legc) // , e.getModifierState("CapsLock"));
  });

  // TODO: this shouldn't be needed,
  // but setting background-color changes
  // layout!
  PAPER(7);
  INK(0);

  window.onerror = function(e) {
    dom('error', ''+e);
  };
  
  if (0) {
    screen(10, 10, 77);
    screen(12, 12, 3);
    screen(14, 14, 16+5);
    PAPER(7);
    INK(5);
  }
  
  if (0)
    setInterval(_=>{
      for(let i=0; i<100; i++)
	screen(rand(28), rand(40), rand(256));
      PAPER(rand(8));
      INK(rand(8));
    }, 0);


  // ORIC BASIC KEYWORDS
  // https://www.defence-force.org/computing/oric/coding/annexe_1/index.htm

  // Note: STR$ indicates a value of 334 for the token. It seems to be
  // hard to put in a byte !
  // NAME	CODE	TYPE
  (function(){
    `
ABS	216	
function
AND	209	
operator
ASC	236	
function
ATN	229	
function
AUTO	199	
parameter
CALL	191	
instruction
CHR$	237	
function
CIRCLE	173	
instruction
CLEAR	189	
instruction
CLOAD	182	
instruction
CLS	148	
instruction
CONT	187	
instruction
COS	226	
function
CSAVE	183	
instruction
CURMOV	171	
instruction
CURSET	170	
instruction
DATA	145	
instruction
DEEK	231	
function
DEF	184	
instruction
DIM	147	
instruction
DOKE	138	
instruction
DRAW	172	
instruction
EDIT	129	
instruction
ELSE	200	
instruction
END	128	
instruction
EXP	225	
function
EXPLODE	164	
instruction
FALSE	240	
constant
FILL	175	
instruction
FN	196	
function
FOR	141	
instruction
FRE	218	
function
GET	190	
function
GO	247
instruction
GOSUB	155	
instruction
GOTO	151	
instruction
GRAB	159	
instruction
HEX$	220	
function
HIMEM	158	
instruction
HIRES	162	
instruction
IF	153	
instruction
INK	178	
instruction
INPUT	146	
instruction
INT	215	
function
KEY$	241	
function
LEFT$	244	
function
LEN	233	
function
LET	150	
instruction
LIST	188	
instruction
LLIST	142	
instruction
LN	224	
function
LOG	232	
function
LORES	137	
instruction
LPRINT	143	
instruction
MID$	146	
function
MUSIC	168	
instruction
NEW	193	
instruction
NEXT	144	
instruction
NOT	202	
operator
ON	180	
instruction
OR	210	
operator
PAPER	177	
instruction
PATTERN	174	
instruction
PEEK	230	
function
PI	238	
constant
PING	166	
instruction
PLAY	169	
instruction
PLOT	135	
instruction
POINT	243	
function
POKE	185	
instruction
POP	134	
instruction
POS	219	
function
PRINT	186	
instruction
PULL	136	
instruction
READ	149	
instruction
RECALL	131	
instruction
RELEASE	160	
instruction
REM	157	
instruction
REPEAT	139	
instruction
RESTORE	154	
instruction
RETURN	156	
instruction
RIGHT$	245	
function
RND	223	
function
RUN	152	
instruction
SCRN	242	
function
SGN	214	
function
SHOOT	163	
instruction
SIN	227	
function
SOUND	167	
instruction
SPC	197	
function
SQR	222	
function
STEP	203	
instruction
STOP	179	
instruction
STORE	130	
instruction
STR$	334	
function
TAB	194	
function
TAN	228	
function
TEXT	161	
instruction
THEN	201	
instruction
TO	195	
instruction
TROFF	133	
instruction
TRON	132	
instruction
TRUE	239	
constant
UNTIL	140	
instruction
USR	217	
function
VAL	235	
function
WAIT	181	
instruction
ZAP	165	
instruction
`.replace(/(\S+)\t(\d+)\t\n(\S+)/g,
	  (_, word, code, what)=>{
	    document.write(`<tt>${word}=${code} is ${what}</tt></br>`);
	  });
  })();


</script>

</body>

</html>
