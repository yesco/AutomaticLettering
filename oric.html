<html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>

<style>
/*default version*/
@font-face {
	font-family: 'oric-atmos';
	src: url('oric-atmos.ttf'); 
	src: 
		local('oric-atmos'),
		local('oric-atmos'),
		url('oric-atmos.ttf') 
		format('truetype');
}
/*container element*/
pre, span, div { font-family: 'oric-atmos', monospace; }
/*span elements inside the container div*/

  span {
      display: inline-block;
      font-size: 1.5rem;
      text-align: left;
      //color: black;
  }
  
  .char {
      width: 0.30rem;
      border: 0px;
      padding-left: 0.25rem;
      //width: 50px;
      //max-width: 50px;
      //overflow: hidden;
  }
  
</style>
  
<script src='misc.js'>
</script>

</head>

<body style='background-color: black; color: white;'>
<div style='width:100%'>
  <img width='20%' src='oric-logo-black-export.svg'/>
  <div style='float:right; width:80%; text-align:center; font-decoration:bold; text-justify:inter-word; font-size:3rem;'>W E B - B A S I C</div>
</div>

</br>

<center>
  <div id='screen' style='width:83%; color: black; font-size: 1.05em; text-align: left;
'></div>
</center>

<br><br>
<input autofocus style='background:black; color:black; border:none;'>
<br>
ROW: <span id='row'></span>
COL: <span id='col'></span>
<br>
LINE: <span id='line'></span>
<br>
ERROR: <span id='error'></span>
<br>
VARS: <span id='vars'></span>

<script>
  loadScript('jsconsole.js');
</script>
  
<script>

  // https://osdk.org/index.php?page=articles&ref=ART9.
  // From a memory point of view, TEXT mode requires 1120 bytes for display (28 lines of 40 columns)
  // and 1920 bytes for storing the character set
  // 1120 bytes for the screen (from #BB80 to #BFDF)
  // 1024 bytes for the default character set (from #B400 to #B7FF)
  // 896 bytes for the secondary ("alternate") character set (from #B800 to #BB7F)
  // This makes a total of 3040 bytes.
  
  // So if the first byte of the screen (#BB80), contains the value 65 (ASCII code for the upper case A letter), we know that this block of 6x8 pixels will be filled with graphical information stored at the address #B400+(8*65).

  // TODO: define imgs for each character?
  // then we can 'poke' to change them?

  function TEXT() {
    for(let row=0; row<28; row++) {
      let r = '';
      for(let col=39; col>=0; col--) {
	c = '&nbsp;';
	let id = `r${row}c${col}`;
	r = `<span id='a${id}'><span id='c${id}' class='char'>${c}</span>${r}</span>`;
      }
      dom('screen', r+'</br>', 'ah');
    }
    cache = {};
  }
  // mode: 0 or 1
  function LORES(mode) {
    throw "LORES: Not implemented!";
  }

  // Structurally it is very similar to the TEXT mode, with 40 bytes per line, with each byte representing 6 pixels for a total of 240 pixels in width.
  // The main difference is that each line is only one pixel tall instead of 8, so there are 200 of these.
  // The actual graphical resolution is 240x200, but the screen has an additional area at the bottom containing 3 lines of TEXT mode.

  // From a memory point of view, HIRES mode is much more voracious:
  // 8000 bytes for the HIRES part of the screen (from #A000 to #BF3F)
  // 120 bytes for the TEXT part of the screen screen (from #BF68 to #BFDF)
  // 42 bytes lost between the HIRES and TEXT parts of the screen (from #BF40 to #BF67)
  // 1024 bytes for the default character set (from #9800 to #9BFF)
  // 1024 bytes for the secondary ("alternate") character set (from #9C00 to #9FFF)
  // This makes a total of 10210 bytes.

  // http://twilighte.oric.org/twinew/ula.htm
  function HIRES() {
    throw "HIRES: Not implemented!";
  }
  
  // VALUE	EFFECT

  // Change Ink (foreground) color
  // 0	Change INK to BLACK
  // 1	Change INK to RED
  // 2	Change INK to GREEN
  // 3	Change INK to YELLOW
  // 4	Change INK to BLUE
  // 5	Change INK to MAGENTA
  // 6	Change INK to CYAN
  // 7	Change INK to WHITE

  // Character Set modifier
  // 8	Use Standard Charset
  // 9	Use Alternate Charset
  // 10	Use Double Size Standard Charset
  // 11	Use Double Size Alternate Charset
  // 12	Use Blinking Standard Charset
  // 13	Use Blinking Alternate Charset
  // 14	Use Double Size Blinking Standard Charset
  // 15	Use Double Size Blinking Alternate Charset

  // Change Paper (background) color
  // 16	Change PAPER to BLACK
  // 17	Change PAPER to RED
  // 18	Change PAPER to GREEN
  // 19	Change PAPER to YELLOW
  // 20	Change PAPER to BLUE
  // 21	Change PAPER to MAGENTA
  // 22	Change PAPER to CYAN
  // 23	Change PAPER to WHITE

  // Video control attributes
  // 24	Switch to TEXT mode (60 Hz)
  // 25
  // 26	Switch to TEXT mode (50 Hz)
  // 27
  // 28	Switch to HIRES mode (60 Hz)
  // 29
  // 30	Switch to HIRES mode (50 Hz)
  // 31
  const color = {
    black:   '#000000', 0: '#000000',
    red:     '#FF0000', 1: '#FF0000',
    green:   '#00FF00', 2: '#00FF00',
    yellow:  '#FFFF00', 3: '#FFFF00',
    blue:    '#0000FF', 4: '#0000FF',
    magnenta:'#FF00FF', 5: '#FF00FF',
    cyan:    '#00FFFF', 6: '#00FFFF',
    white:   '#FFFFFF', 7: '#FFFFFF',
  };
    
  let inverse = n=>7-n;
  
  function domc(id) {
    domc.cache = domc.cache || {};
    let d = domc.cache[id];
    if (!d) {
      d = dom(id);
      domc.cache[id];
    }
    return d;
  }
  
  // this is like equivalent of POKE!
  function screen(row, col, ch) {
    let dc = domc(`cr${row}c${col}`);
    // read screen?
    if (ch === undefined) {
      if (typeof dc.screenchar == 'number')
	return dc.screenchar;
      else
	return dc.screenchar = dc.textContent.charCodeAt(0);
    }
    dc.screenchar = ch;

    let da = domc(`ar${row}c${col}`);

    let t;

    // interpret char/attribute
    let c = ch & 0x7f;
    if (c >= 32) { // ascii
      t = ch & 0x7f;
    } else if (c < 8) { // ink
      let fg = c & 0x07;
      if (c > 127) fg = inverse(fg);
      da.style.color=color[fg];
      t = 32; // blankk it out
    } else if (c < 16) {
      // Character Set modifier
      // 8  Use Standard Charset
      // 9  Use Alternate Charset
      // 10 Use Double Size Standard Charset
      // 11 Use Double Size Alternate Charset
      // 12 Use Blinking Standard Charset
      // 13 Use Blinking Alternate Charset
      // 14 Use Double Size Blinking Standard Charset
      // 15 Use Double Size Blinking Alternate Char
    } else if (c < 24) { // 16-23 paper
      let bg = c & 0x07;
      if (bg > 127) bg = inverse(bg);
      da.style.backgroundColor=color[bg];
      t = 32; // blankk it out
    } else {
      // TODO: mode switching
      // idea: make screen garbled? lol
      // Video control attributes
      // 24-27 Switch to TEXT mode (60 Hz)
      // 28-31 Switch to HIRES mode (60 Hz)
    }

    if (t == 32)
      dc.innerHTML = '&nbsp;';
    else if (t !== undefined)
      dc.textContent = String.fromCharCode(t);
  }

  function INK(color) {
    for(let row=0; row<28; row++) {
      screen(row, 1, color);
    }
  }
  function PAPER(color) {
    for(let row=0; row<28; row++) {
      screen(row, 0, 16+color);
    }
  }

  function exmple_PAPER() {
    return `
l0 FOR I=0 TO 7 
20 INK I 
30 FOR J=0 TO 7 
40 PAPER J 
50 WAIT 50 
60 NEXT J 
70 NEXT I 
80 INK 0 
`;
  }

  function example_PRINT_AT() {
    return `
10 FOR X=2 TO 30 
20 PRINT @X,10;·• WHIZZ2" 
30 NEXT X
`;
  }


  const ESC = 27;
  
  let row = 1, col = 2, raw = false;

  function cursorOff() {
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = '';
    d.style.color = '';
  }

  function cursorOn() {
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = 'black';
    d.style.color = 'white';
  }
  
  let dirty = 0;
  function princ(c) {
    if (typeof(c) !== 'number')
      alert('princ: only take nubmers: ' +  c);
    dirty++;
    // TODO: how to handle inverse?
    let ch = c & 0x7f;
    if (ch === ESC) return raw = true;
      
    if (raw || ch >= 32) {
      screen(row, col, c);
      col++;
    }
    raw = false;

    if (ch == 10) { row++; col = 2; }

    // backspace
    if (ch == 8) {
      col--;
      if (col < 2) col = 2;
      // TODO: I don't think backspace wraps?
      //if (col < 2) { col = 39; row--; }
      //if (row < 1) { col = 2; row = 1; }
      screen(row, col, 32);
    }

    if (col >= 40) {
      col = 2;
      row++;
    }

    // scroll!
    if (row >= 28) {
      let start = Date.now();
      for(let r=2; r<28; r++) {
	for(let c=0; c<40; c++) {
	  screen(r-1, c, screen(r, c));
	}
      }
      // TODO: if not hidden column mode?
      row = 27;
      for(let c=2; c<40; c++) {
	screen(row, c, 32);
      }
      //dom('error', 'scroll time='+(Date.now()-start));
    }
  }

  let vars = {};
  // 20LETSEL=0 => 20 LET SEL = 0
  // TODO: 63999 max
  //  
  // integer -32767 to 32768
  // A%
  // A$

  // DIM varname(exp, ...)
  function DIM(n, ...dims) {
    let v = 0.0;
    if (n.match(/^\w+\%/)) v = 0;
    if (n.match(/^\w+\$/)) v = '';
    
    function gen(dim, ...dims) {
      if (!dim) return v;
      return [...Array(dim)]
	.map(_=>gen(...dims));
    }
    
    vars[n] = gen(...dims);
  }

  function LET(n) {
    let v = this;
    v = v.replace(/^\s*LET\s*\S+\s*=\s*/, '');
    if (trace) print('LET: ' + v);
    let r = EVAL(v);
    if (r === undefined) return;

    if (n.endsWith('%')) r = Math.floor(r);
    if (n.endsWith('$')) r = ''+r;

    // indexing (interpolate using fixpoint!)
    let lastn = n;
    while (lastn != (n = n.replace(
      /\[([^\[\]]*)\]/g, (_,i)=>'['+EVAL(i)+']'))) {
      if (trace) print('IX: ' + n);
      lastn = n;
    }

    // set
    if (trace) print('SET: ' + n);
    let path = n.replace(/[\[\]]/g, ' ').trim()
	.split(/\s+/g);
    if (trace) print('PATH: ' + JSON.stringify(path));
    let nv = vars;
    let x;
    let lastx = path.shift();
    while ((x = path.shift()) !== undefined) {
      if (trace) print('LOOP lastx: ' + lastx);
      if (trace) print('LOOP x: ' + x);
      nv = nv[lastx];
      lastx = x;
    }
    if (trace) print('SET: ' + (nv == vars) + ' ' + lastx);
    nv[lastx] = r;
  }

  function EVAL(x) {
    try {
      if (trace) print('VARS: ' + JSON.stringify(vars));
      // pow!
      x = x.replace(/\^/g, '**');
      if (trace) print('EXP: ' + x);
      let r = (function(ATMOSexp){
	with (vars) {
	  return eval(ATMOSexp);
	}
      })(x);
      if (trace) print('-->: ' + r);
      return r;
    } catch(e) {
      if (!trace) print('EVAL: ' + v);
      eval_error('' + e);
      //stop();
    }
  }
  
  function val(n) {
    //n = n.substring(0, 2);
    return vars[n];
  }
  
  // Also CTRL-L
  function CLS() {
    let start = Date.now();
    // TODO: does it resent colors?
    for(let row=0; row<28; row++) {
      for(let col=2; col<40; col++) {
	screen(row, col, 32);
      }
    }
    row = 1; col = 2; raw = false;
    dom('error', 'CLS time ' + (Date.now()-start));
  }

  // 20 INPUT"ENTER SALE PRICE";SELL
  function INPUT(prompt, v) {
  }

  // #FFFFF 
  // PRINT "FOO"BAR"
  // PRINT "4*3="; 4*3
  // PRINT "FOO";"BAR" => FOOBAR
  // ?35 == PRINT 35
  // PRINT 1;2 => <spc>1<spc><spc>2<spc>
  // 40 PRINT"THE CODE FOR "A$"="ASC(A$)
  // PRINT "foo",
  // PRINT "bar"    > fooo       bar 
  // 20 PRINT @X,10;·• WHIZZ2" 
  function print(txt, nonewline) {
    if (typeof txt == 'number')
      txt = ' ' + txt + ' ';
    txt = '' + txt;
    for(let i=0; i<txt.length; i++)
      princ(txt.charCodeAt(i));
    if (!nonewline) princ(10);
  }

  function tab(n) {
    while ((col-2) % 8 !== 0)
      princ(32);
  }
  
  function PRINT() {
    let line = this;
    line = line.replace(/^PRINT\s*/, '');
    line = line.trim();

    let exp = '', mode = 'normal', par = '';
    let nonewline = false;
    for(let i=0; i<line.length; i++) {
      let c = line[i];
      if (trace) print('PRINT.c: ' + c);

      function finish(ev) {
	if (exp.length)
	  print(ev?EVAL(exp):exp, true)
	exp = '';
	if (c === ',') tab();
      }
      
      switch(mode) {
      case 'normal': {
	switch(c) {
	case ',':
	case ';': 
	case ' ': finish(true); break;
	case '\\': return unexpected_error('\\');
	case '"': finish(true); mode = 'string'; par += '"'; break;
	case '(': mode = 'expr'; par += ')'; break;
	case '[': mode = 'expr'; par += ']'; break;
	default: exp += c;
	}
	break;
      }
      case 'string': {
	if (c=='"') {
	  if (exp.length)
	    print(exp, true);
	  exp = '';
	  mode = 'normal';
	} else {
	  exp += c;
	}
	break;
      }
	// TOOD: too simple
      case 'expr': {
	if (par)
	  if (')]"'.indexOf(c) >= 0) {
	    let e = par[par.length-1];
	    if (e !== c)
	      return unmatched_paren_error(e, c);
	    else
	      par = par.substring(0, par.length-1);
	  }
	
	switch(c) {
	case '\\': return unexpected_error('\\');
	case ';': if (par) return unexpected_error(';');
	  
	case '(': par += ')'; break;
	case '[': par += ']'; break;
	case '"': par += '"'; break;
	  
	case ',':
	case ' ': {
	  if (exp.length && !par.length) {
	    print(EVAL(exp), true);
	    exp = ''
	    mode = 'normal';
	  }
	  if (c === ',') tab();
	  break;
	}
	default: exp += c;
	}
	break;
      }
      }
      if (c !== ' ') nonewline = false;
      if (c === ';') nonewline = true;
    }

    // cleanup
    if (exp.length) {
      // TODO: missing " ?
      if (mode === 'string')
	print(exp, true);
      else
	print(EVAL(exp), true)
    }
    if (!nonewline)
      princ(10);
  }

  function syntax_error() {
    print('?SYNTAX ERROR');
  }

  function unexpected_error(s) {
    print('?UNEXPECTED ERROR: ' + s);
  }

  function unmatched_error(e, g) {
    print('?MATCHING ERROR, expected: ' + e + ' got: ' +g);
  }

  function eval_error(e) {
    print('?EVAL ERROR (' + e +')');
  }
  
  // TODO: not original?
  function cont_error() {
    print('?CAN\'T CONTINUE');
  }

  function illegal_quantity_error() {
    print('?ILLEGAL QUANTITY ERROR');
  }
  
  function boot() {
    let txt = `
ORIC EXTENDED BASIC Vl.1
(C) 1983 TANGERINE
88888 BYTES FREE
`;
    print(txt);
  }

  // TODO: Basic Lines max 80 chars bell at 79?

  // LIST -100
  // LIST 100-
  // LIST 100-200

  // TODO: sorted?
  let lines = {
    2: 'LET A=0',
//    10: 'PRINT "HELLO"',
    //10: 'PRINT ".";',
    12: 'LET A=A+1',
    15: 'GOSUB 100',
    20: 'GOTO 9',
    //100: 'PRINT A;',
    110: 'RETURN',
  };

  function running() {
    return !!RUN.interval;
  }
  
  function LIST() {
    //stop();
    line = '';
//    let lastlineno = 0;
    lineno = 0;
    RUN.interval = setInterval(_=>{

//      lineno = lastlineno;

      for(let i=3; i>=0; i--) {
      nextline();
      if (!line)
	stop();
      else
	print(lineno + ' ' + line);
      }
      
//      lastlineno = lineno;
      // better set it to nothing...
//      lineno = 0;
    }, 1);

    // can't be interrupted!
    //for(let k in lines) { // always ordered!
    //print(k + ' ' + lines[k]);
    //}
  }

  function EDIT(lno) {
    LIST(lno);
  }
  
  let lineno = 0;
  function RUN(lno) {
    // init
    lineno = (+lno || 0) - 1;
    line = '';
    stack = [];
    vars = {}
    
    cont();
  }
  
  function nextline() {
    // crazy linear search for next!
    // you could goto any number
    // it just find the next numerically
    line = '';
    while (!line && lineno < 65536) {
      lineno++;
      // TODO: these aren't guaranteed to be in order? only when for-in!!!
      line = lines[lineno];
    }
    if (line === undefined) line = '';
  }

  function cont() {
    RUN.interval = setInterval(_=>{
      let start = Date.now();
      do {
	nextline();
	if (line && trace) print(lineno + ' ' + line)
	if (!run(line)) stop();
      } while (Date.now() - start < 20);
    }, 1);
  }
  
  function CONT() {
    if (!CONT.lineno)
      return cont_error();

    lineno = CONT.lineno;
    line = CONT.line;
    delete CONT.lineno;
    delete CONT.line;

    cont();
  }
  function CONTINUE() { CONT(); }
  
  function ON_GOTO() { }

  // TODO: currently no limit...
  let stack = []; // [ [lno, restline] ...]
  function GOSUB(lno) {
    stack.push([lineno, line]);
    lineno = lno-1;
    line = '';
  }
  function RETURN() {
    [lineno, line] = stack.pop();
  }    

  function stop(noprompt) {
    let wasrunning = running();
    if (col > 2) princ(10);
    if (wasrunning) {
      clearInterval(RUN.interval);
      delete RUN.interval;
      if (!noprompt) {
	print('READY');
	cursorOn();
      }
    }
    line = '';
    return wasrunning;
  }
  
  function GOTO(lno) {
    lineno = lno-1;
  }

  function ctrlC() {
    cursorOff();
    let lno = lineno;
    let l = line;
    if (stop('noprompt')) {
      print('?INTERUPTED AT LINE ' + lineno)
      CONT.lineno = lno;
      CONT.line = l;
    }
    cursorOn();
  }
  
  // WAIT 100 = 1s
  function WAIT(decaseconds) {
  }
  
  function example_VAT() {
    return `
10 REM *VAT Calculation* 
20 INPUT"ENTER SALE PRICE";SELL 
30 LET VAT=0. 15*SELL 
40 LET PRICE=SELL+VAT
50 PRINT "TOTAL=";PRICE 
60 'Round agan for next calculation
70 WAIT 500:CLS:GOTO 20
`;
  }

  function  example_NAME() {
    return `
10 A$="0RIC" 
120 LET Al$="BASI·C" 
130 LET LAST$="LESSON" 
140 INPUT"ENTER YOUR NAME,PLEASE";NAME$ 
150 CLS:PRINT A$;" ";Al$;" ";LAST$ 
160 PRINT "FOR ";NAME$
`;
  }

  function example_KEY() {
    return `
10 PRINT"PRESS A KEY" 
20 GET A$ 
30 PRINT"YOU PRESSED "A$ 
40 PRINT"THE CODE FOR "A$"="ASC(A$) 
50 GOTO 10
`;
  }

  function example_DEF() {
    return`
5 REM*Define Function M to convert feet 
to metres 
10 DEF FNM(FEET)=FEET*0.3048 
20 INPUT"HOW MANY FEET";X 
30 M=FNM(X) 
40 PRINT X;"FEET EQUAL";M;" METRES"
`;
}

  function example_FOR() {
    return `
10 FOR L=l TO 5:PRINT L*L:NEXT L 

10 FOR L=10 TO 5 STEP-l:PRINT L*L:NEXT 

10 CLS 
20 FOR LOOP=0 TO 25 
30 PRINT CHR$(65+LOOP)+CHRS(97+LOOP); 
40 NEXT LOOP 
`;
  }

  function example_READ_DATA() {
    return `
10 REM*READ o.nd DATA* 
20 FOR 0=0 TO 6 
30 READ D$ 
40 PR1NT D$ 
50 NEXT 
60 REM . . . lots more program 
70 ' 
2000 DATA MONDAY,TUESDAY,WEDNESDAY,THUR 
SDAY 
2010 REM ... more program in between 
3000 DATA FRIDAY, SATURDAY,SUNDAY 
4000 REM .. co.n do it 0.90.in 
4010 RESTORE 
4020 FOR K=l TO 7 
4030 READ DAY$:PRINT DAY$:NEXT
`;
  }

  function example_DIM() {
    return `
10 INPUT"HOW MANY NAMES" ;N% 
20 DIM NAME$(N%):DIM AGE(N%)
30 CLS:SLJM=0 
40 FOR K=1 TO N%
50 PRINT "ENTER NAME t'-10. "K 
60 INPUT NAME$[K]
70 PRINT NAME$[K]"'S AGE ?" 
80 INPUT AGE[K] :SLJM=SLJM+AGE[K]
80 CLS 
100 NEXT K 
110 FOR K=N% TO 1 STEP -1 
120 PRINT :PR1NT NAME$[K]" JS";
130 NEXT K
`;
  }
  
  function example_MULTIDIM() {
    return `
10 DIM NXC10,3) 
20 CLS 
30 FOR K=l TO 10 
40 ~OR J=l TO 3 
50 NxCK,JJ=K"J 
60 PRINT NxCK,JJ 
70 NEXT J 
80 PRINT 
90 NEXT K
`;
  }

  function example_BUBBLESORT() {
    return `
5 REM*NUMERIC BUBBLE SORT** 
10 CLS:LET J=15 'Number of items 
20 DIM NUMCJJ'ATray foT numbeTs 
30 'Example numbers generated here" 
40 FOR K=0 TO J 
50 LET NUMCKJ=RNDC1J*1000 
60 PRINT NUMCKJ 
70 NEXT K 
99 ' 
100 REM*SORT*ROUTINE* 
101 ' 
110 FOR M=l TO CJ-lJ 
120 FOR N=M TO J 
125 REM If correct ordeT 
already,then skip 
130 IF NUMCMJ<NUMCNJ THEN 170 
135 REM Incorrect order,so swap 
140 TEMP=NUMCMJ 
150 NUMCMJ=NUMCNJ 
160 NUMCNJ=TEMP 
170 NEXT N 
180 NEXT M 
189 ' 
190 REM**ENDSORT** 
191 ' 
200 REM *Print sorted list* 
210 CLS:PRINT ''SORTED LIST:" 
220 FOR K::::JTO J 
230 PRINT NUMCKJ 
240 NEXT K 
`;
  }

  // loop is completed, the address is removed, and a subsequent NEXT will 
  // activate a jump to the address now on the top of the pile. The stack can only 
  // hold 10 addresses, and more than 10 loops will give an ?OUT OF MEMOR
  
  function END() {}
  
  function READ() {}
  function DATA() {}
  function RESTOR() {}
  
  function FOR_TO_STEP() {}
  function NEXT() {}

  // GET K$
  function GET() {}
  function READ() {}
  function DATA() {}

  function ASC() {}

  function CHR$() {}

  function STR$() {}

  // evaluated first, before any other calculations are worked out. 
  //The other string function for numeric conversion is HEX$. This returns 
  // the string form of the hexadecimal number equivalent to the argument. For 
  // example, HEX$C4I8) returns #IA2. Since hexadecimal numbers can only be 
  // integers between 0 and 65535, any numbers outside that range will give a 
  // ?ILLEGAL QUANTITY ERROR, and any non-integer values will be auto-
  // matically rounded.

  function HEX$() {}

  function LENGTH(s) { return s.length; }
  function LEFT$(s, n) {}
  function RIGHT$(s, n) {}
  function MID$(s, a, b) {}
  
  function VAL() {}
  
  function INT() {}
  
  function PING() {}
  

  // REM comment
  // ' commment
  function REM() {}

  // MATH
  // + - * / ^
  
  // Oric BASIC has the following built-in numeric functions: 
  ABS = Math.abs;
  ATN = Math.atan;
  COS = Math.cos;
  EXP = Math.exp;
  INT = Math.floor;
  LN = Math.ln;
  LOG = Math.ln10;
  const PI = Math.PI;
  SGN = n=>(n>0)?+1:(n<0)?-1:0;
  SIN = Math.sin;
  SQR = Math.sqrt;
  TAN = Math.tan;
  function RND(n) {
    if (!n) return Math.random();
    return Math.floor(n * Math.random());
  }
  function RANDOMIZE() {}

  // tested by means of conditional operators: 
  // Equal to 
  // <> Not equal to 
  // > Greater than 
  // < Less than 
  // >= Greater than or equal to 
  // < = Less than or equal to 
  // These operate much as you would expect for numeric values. Two things 
  // need to be remembered, however. The fir

  // 10 DEF FNMCFEETJ=FEET*0.3048 
  function DEFFN(n, exp) {}

  function AND() {}
  function OR() {}
  function NOT() {}

  function example_ON_GOTO() {
    return `
10 l NPUT" ENTER 1 .. 2 OR 3_, PLEASE' ' ;N 
20 ON N GOTO 150,200,300 
140 RP1 
159 PRINT "LINE 150 FROM N=J";GClTO 10 
190 REM 
200 PRINT "LINE 200 FROM N=2":GOTO 10 
290 REM 
300 PRINT "LINE 300 FROM N=3" :GOTO 10
`;
  }

  function TAB() {}
  function PEEK() {}
  function POKE() {}

  function CSAVE() {}

  function CLOAD() {}
  function STORE() {}
  function RECALL() {}
  
  function example_TAB() {
    return `
10 FOR 1=0 TO 5 
20 PRINT TABCIJ; "HELLO" 
30 NEXT I 
HELLO 
HELLO 
 HELLO 
  HELLO 
   HELLO 
    HELLO
`;
  }
  function IF_THEN_ELSE(e, t, e) {}
  function REPEAT() {}
  function UNTIL() {}
  
  // sounds
  // https://bulba.untergrund.net/emulator_e.htm
  // The PLAY command allows you to mix tones and gives access to eight preset envelope shapes.
  function PLAY() {}
  // After using MUSIC and SOUND to set channel and select the tones and noise you want, you use PLAY to mix the channels, select an envelope and control the duration of the final sound. In this way, quite complex sounds can be built up even considering the limitations of the single voice and the pre-set envelopes. The three main sound commands can be used in programs written in
  function MUSIC() {}
  function SOUND() {}

  function ZAP() {}
  function PING() {}
  function SHOOT() {} // "snare-drum"
  function EXPLODE() {}


</script>

<script>
  function rand(n) {
    return Math.floor(Math.random()*n);
  }
  
  TEXT();
  CLS();

  boot();
  cursorOn();
  run();

  let line = '';

  let lastnow = Date.now();
  let lastrun = 0;
  setInterval(_=>{
    dom('line', line);
    dom('row', row);
    dom('col', col);
    dom('vars', JSON.stringify(vars));
    
    let now = Date.now();
    dom('error', 'Statements: '+run.count+
	' sps= ' + Math.floor(1000*(run.count-lastrun)/(now-lastnow)));
    
    lastnow = now;
    lastrun = run.count;
  }, 100);
  // clear initial error
  dom('error', '');
  
  function editChar(ch) {
    cursorOff();
    let c = String.fromCharCode(ch);
    // ignore keyboard setting
    if (caps)
      c = c.toUpperCase();
    else
      c = c.toLowerCase();
    line += c;
    princ(c.charCodeAt(0)); // lol
    cursorOn();
  }    

  function editEnter() {
    cursorOff();
    princ(10);
    run(line);
    line = '';
  }

  // basically make other arguments splittable
  function quoteStrings(line) {
    return line.replace(
      /\".?\"/g,
      s=>s.replace(/!/g, '!!')
	.replace(/ /g, '!s!')
	.replace(/:/g, '!c!')
      	.replace(/\(/g, '!po!')
        .replace(/=/g, '!e!')
        .replace(/,/g, '!com!')
    );
  }
  function unquoteStrings(line) {
    return line.replace(
      s=>s.replace(/!c!/g, ':')
	.replace(/!s!/g, ' ')
      	.replace(/!po!/g, '(')
        .replace(/!pc!/g, ')')
        .replace(/!e!/g, '=')
        .replace(/!com!)/g, ',')
	.replace(/!!/g, '!'));
  }

  // interprets and runs one line
  // returns true if ok
  // END return false
  function run(line) {
    run.count++
    if (!line || line === '') return true;
    line = line.trim();
    line = quoteStrings(line);

    if (trace) print('LINE: ' + line);
    let many = line.split(':');
    if (trace) print('MANY: ' + many.length);
    // TODO: incorrect, and can't CTRL-C!
    if (many.length > 1) {
      let r= many.map(unquoteStrings)
	  .some(x=>!run(x));
      return r;
    }

    // rough parameter extraction
    let a = line.split(/[\s;=\(\),]+\s*/g);
    if (trace) print('------' + a.join(' | '));
    a = a.map(unquoteStrings);
    if (trace) print('------' + a.join(' | '));
    // make numbers great again
    a = a.map(x=>(+x==x?+x:x));
    if (trace) print('------' + a.join(' | '));

    let c = a.shift();
    let f = window[c];
    if (trace) print('LINE: ' + line);
    if (f)
      f.apply(line, a);
    else
      syntax_error();

    if (!running()) {
      print('READY');
      cursorOn();
    }
    if (c === 'END') return false;
    return true;
  }
  run.count = 0;
  
  function editBackspace() {
    cursorOff();
    line = line.substring(0, line.length-1);
    princ(8);
    cursorOn();
  }
  
  function editCancel() {
    cursorOff();
    line = '';
    princ(10);
    cursorOn();
  }

  function editCopy() {
    let c = screen(row, col);
    editChar(c);
  }

  function editArrow(ch) {
    cursorOff();
    switch(ch) {
    case 37: col--; break; // left
    case 38: row--; break; // up
    case 39: col++; break; // right
    case 40: row++; break; // down
    }
    // move cursor, wrap around (?)
    // TODO: columns mode?
    if (col < 2) col = 39;
    if (col > 39) col = 2;
    if (row < 0) row = 27;
    if (row > 27) row = 0;
    cursorOn();
  }

  let caps=true, click=true, cursor=true, column=false, trace=false;

  document.addEventListener('keydown', function(e) {
    let c = e.ctrlKey, k = e.key.toLowerCase();
    let s = e.shiftKey, ch = e.code;
    let kc = e.keyCode;
    if (kc==13) editEnter();
    if (kc==8) editBackspace();
    if (c && k=='c') ctrlC();
    if (c && k=='x') editCancel();
    if (c && k=='l') CLS();
    if (c && k=='a') editCopy();
    if (c && k=='f') click = !click;
    if (c && k=='q') cursor = !cursor;
    if (c && k=='t') caps = !caps;
    if (c && k=='j') column = !column;
    if (37 <= kc && kc <= 40) editArrow(kc);

    // my extensions
    if (c && k=='r') window.location.reload();
    if (c && k=='p') trace = !trace;

    if (c) e.preventDefault();
  });

  document.addEventListener('keypress', function(e) {
    let c = e.ctrlKey, k = e.key; s = e.shiftKey;
    let legc = e.charCode, legk = e.keyCode;
    let ch = e.code;
    //    if (legk > 16) 
    //    alert(`k=${k} legc=${legc} legk=${legk} ch=${ch}`);
    // TODO: use e.code - but it's crap
    // and don't reflect shift
    if (e.keyCode==13) return;
    editChar(legc) // , e.getModifierState("CapsLock"));
  });

  // TODO: this shouldn't be needed,
  // but setting background-color changes
  // layout!
  PAPER(7);
  INK(0);

  window.onerror = function(e) {
    dom('error', ''+e);
  };
  
  if (0) {
    screen(10, 10, 77);
    screen(12, 12, 3);
    screen(14, 14, 16+5);
    PAPER(7);
    INK(5);
  }
  
  if (0)
    setInterval(_=>{
      for(let i=0; i<100; i++)
	screen(rand(28), rand(40), rand(256));
      PAPER(rand(8));
      INK(rand(8));
    }, 0);
</script>

</body>

</html>
