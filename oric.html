<!--- https://raw.githack.com/yesco/AutomaticLettering/master/oric.html -->
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>
<script>
  // this gives syntax errors while loading
  // put this as first script
  // then at end we change to capture runtime errors
  window.onerror = (...args)=>{
    // let t = ''+args[0];
    let t = args.toString();
    let b = document.body;
    t = `<div style='background:red;''>${t}</div>`;
    b.insertAdjacentHTML('afterbegin', t);
  };
</script>

<script id='help'>
  function HELP(cmd) {
    if (cmd) {
      // extract DOC string from function!
      let f = window[cmd];
      if (f) {
	let s = f.toString();
	if (trace) print('FUN=' + f.toString());
	s = s.match(/\/\/\s*DOC\s*:?\s*([\s\S]+)/i);
	let doc;
	if (!s) {
	  doc = '- NO DOCS';
	} else {
	  s = s.join('').replace(/\n\s*[^\s\/][\s\S]*$/, '');
	  s = s.replace(/\n\s*\n[\s\S]*/, '');
	  s = ('\n'+s).replace(/\n\s*\/\/\s*/g, '\n');
	  s = s.replace(/^[\n]DOC[\s:]*/, '');
	  doc = s;
	}

	princ(cmd); TAB();

	// indent paragraph!
	let mincol = col;
	for(let i=0; i<doc.length; i++) {
	  let ch = doc.charCodeAt(i)

	  TAB(mincol);
	  if (ch == 10 & col > SCREEN_COLS-1)
	    ;
	  else
	    putc(ch);

	}
	print();

	// related
	let rel = HELP.related.filter(
	  g=>g.match(RegExp(`\\b${cmd}\\b`))
	);
	if (rel)  {
	  print('\nRelated:');
	  rel.forEach(r=>print(r));
	}
	return;
      } else {
	print('?NO SUCH NAME');
      }
    }

    // list names!
    
    function printkeys(msg, k) {
      let num = 0;
      k.forEach(n=>{
	if (cmd && !n.match(cmd)) return;
	princ(n);TAB();
	num++;
      });
      if (num) {
	if (col > 2) print();
	princ(num);
	print('WORDS ' + msg);
      }
    }

    printkeys(
      'MISSING', OKK(/(dummy|missing|impl|UNKN)/i));
    printkeys(
      'DEFINED', OKK(/(const|defined|native|innov)/i));
    //print('Usage: HELP [cmd]');

  }
  // push related words (space separated) on this!
  HELP.related = [];
</script>
<script>
  // -- Simplified testing of types and values
  function tType(t, x, err) {
    if (x === undefined) syntax_error();
    if (typeof x !== t) type_error();
    if (err) quantity_error();
    // okay
  }
  function tStr(s, err) {
    tType('string', s, err);
  }
  function tNum(n, err) {
    tType('number', n, err);
  }
  function tInt(n, err) {
    n = Math.floor(r);
    if (n > 32767 || r < - 32769)
      quantity_error()
    tType('number', n, err);
  }
  function tPos(n, err) {
    tNum(n, err || n < 0);
  }

  function error(msg, data) {
    print();
    princ(msg);
    if (data) { putc(32); princ(data); }
    if (lineno) { princ(' IN LINE'); princ(lineno); }

    stop(true);
    throw msg;
  }

  // NEW?
  function save_error(info) {
    error("?CAN'T SAVE", info);
  }

  function syntax_error(cmd) {
    error('?SYNTAX ERROR: ', cmd);
  }

  // NEW
  function implemented_error(s) {
    error('?NOT IMPLEMENTED ERROR:', s);
  }
  
  // NEW?
  function unexpected_error(s) {
    error('?UNEXPECTED ERROR:', s);
  }

  // NEW?
  function unmatched_error(e, g) {
    error('?MATCHING ERROR, expected:' + e + ' got: ' +g);
  }

  // NEW?
  function eval_error(e) {
    error('?EVAL ERROR:', e);
  }
  
  function return_error() {
    error('?RETURN WITHOUT GOSUB ERROR');
  }
  
  function cont_error() {
    error('?CAN\'T CONTINUE ERROR');
  }

  function quantity_error() {
    error('?ILLEGAL QUANTITY ERROR');
  }

  // when calling some interactive funcs
  // like key$ and get, input
  function direct_error() {
    error('?ILLEGAL DIRECT ERROR');
  }

  function type_error() {
    error('?TYPE MISMATCH ERROR');
  }
  
  function div_error() {
    error('?DIVISION BY ZERO ERROR');
  }
g  
</script>
  
<style>
/*default version*/
@font-face {
	font-family: 'oric-atmos';
	src: url('oric-atmos.ttf'); 
	src: 
		local('oric-atmos'),
		local('oric-atmos'),
		url('oric-atmos.ttf') 
		format('truetype');
}
@font-face {
	font-family: 'neoletters';
	src: url('neoletters.ttf'); 
	src: 
		local('neoletters'),
		local('neoletters'),
		url('neoletters.ttf') 
		format('truetype');
}
/*container element*/
span, div { font-family: 'oric-atmos', monospace; }
/*span elements inside the container div*/

  span {
      //position: absolute;
      display: inline-block;
      /*height: 1px; /* haha you can try! */
  }
  
  .char {
      position: relative;
      width: 0.30rem;
      border: 0px;
      padding-right: 0.25rem;
      max-height: 12px;
  }

  /* TODO: investigate!
  {
       font-size: 12px;
       letter-spacing: 0.015em;
       word-spacing: 0.001em;
  }
 */
  /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform */
  /* we can get double height! but only
     on each char; the problem is the nested
     elements - do it twice and it'll double
     again!

     TODO: I couldn't find a way to translate
     the it and 'clip-y' seems 'overflow-y: hidden isn't working...
 */
  .double {
      width: 0.30rem;
      border: 0px;
      padding-left: 0.25rem;

      //max-height: 45px;
      transform:
	  scale(1, 2)
	       /* translateY(15px); */
      ;
      overflow-x: visible;
      /* overflow-y: hidden; /* doesn't work */
  }

#printer {
    color: blue;
    padding-left: 2rem;
    padding-right: 2rem;
    background: beige;
}
/* TODO: doesn't work on "lines"
#printer:nth-child(2n+0) {
    background: beige;
}
#printer:nth-child(2n+1) {
    color: lightskyblue;
*/
}

</style>
  
<script src='oric-exp.js'>
</script>

<script src='misc.js'>
</script>

<script src='sounds.js'>
</script>

</head>

<body style='background-color: black; color: white;'>
<div style='width:100%'>
  <img width='20%' src='oric-logo-black-export.svg'/>
  <div style='float:right; top:0; width:80%; text-align:center; font-decoration:bold; text-justify:inter-word; font-size:3rem;'>W E B - B A S I C
<sup><a tabindex='-1' target='oricman' style='text-decoration:none; font-size:1.5rem; padding:0.3rem; padding-bottom:0.1rem; color:black; background:white;' href='http://www.defence-force.org/computing/oric/library/lib_manual_oric/files/manual_atmos.pdf'>PDF</a></sup>
<div style='font-size:1rem;'>&copy;jsk@yesco.or
g</div>
  </div>
<span style='transform-origin:left; transform:scale(1.8, 1);'><b>&nbsp;&nbsp;B A S I C</b></span>
</div>

<div id='bits'>
</div>

<!-- seemingly useless span, but need for getting correct width of 'screen'-->
<center><span id='foo'>
<div id='screen' style='color:white; background:black; font-size: 1.5rem; overflow:hidden; xtext-align: left; white-space:nowrap;'>
</div>
</span></center>

<script>
  window.onresize = function(){
    let s = dom('screen');
    
    let w = s.offsetWidth;
    let h = s.offsetHeight;

    let ww = window.outerWidth;
    let wh = window.innerHeight;

    s.style.zoom = Math.min(ww/w, wh/h);
  };
  // call an initial time after first render
  setTimeout(x=>window.onresize(), 1000);
</script>
<!-- id=exp is magical for jsconsole - it returns focus there -->
<div style='display:flex; width:100%;'>
  <input id='exp' autofocus style='flex:1; background:black; color:lightgreen; border:none; width:100; float:right;'>
</div>
<script>
  {
    let s = dom('screen').style;
    let e = dom('exp');

    // not good idea as it scrolls down...
    //dom('screen').onclick =
    //()=>e.focus();

    let sfilter;
    e.onblur = function() {
      sfilter = s.filter;
      // not working?
      s.filter = 'blur(2px)';
    }
    e.onfocus = function() {
      //s.background = '';
      s.filter = sfilter;
    }

    e.onblur();
    // can't force on opera :-(
    // and it's not default
    e.focus();
  }
  
</script>

<!---input id="file" type="file"/-->
<script>
  // inspired by https://stackoverflow.com/questions/16495125/parsing-binary-files-in-client-side-js
  // REFERENCE:
  //  https://developer.mozilla.org/en-US/docs/Web/API/FileReader
  // readAsBinaryString
  function readFile() {
    let fileInput = dom('file');
    let fReader = new FileReader();

    fReader.onload = function(e) {
      /// <-- this contains an ArrayBuffer
      console.log(e.target.result);
    }

    // onloadend
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer
    fileInput.onchange = function(e) {
      let file = this.files[0];
      fReader.readAsArrayBuffer(file);
    }
  }
</script>

<center><b style='color:beige;'>PRINTER (toggle on/off with CTRL-P)</b></center>
<pre id='printer'></pre>
<script>
  {
    let p = dom('printer');
    // select printer output on click!
    p.onclick = ()=>{
      let sel = window.getSelection();
      let range = document.createRange();
      range.selectNodeContents(p);
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }
</script>

<br>
ROW: <span id='row'></span>
COL: <span id='col'></span>
<br>
LINE: <span id='line'></span>
<br>
STATS: <span id='stats'></span>
<br>
ERROR: <span id='error' style='color:red;'></span>
<br>
VARS: <span id='vars'></span>
<br>
INFO:<br><span id='info'></span>
<br>
<br>
<script src='jsconsole.js'>
  //loadScript('jsconsole.js');
</script>
<script>
  DBG('logerr', true);
</script>

<script>
  // Configuration
  let TIMESLICE = 20; // run about X ms

  const SCREEN_COLS = 40, // ORIC: 40
	SCREEN_ROWS = 28, // ORIC: 28
	
	LastOne = 'foo';
  
  

  // Global ORIC ATMOS state
  let vars = {},
      stack = [], // [ [lno, restline] ...]
      line = '',
      lineToDo = [], // queue
      lineno = 0,
      caps = true,
      click = true,
      column = false,
      scoff = 0, // screen off if > 0 (count!)
      printer = undefined,
      trace = false, // debug tracing CTRL-P
      tron = false, // TRON/TROFF
      row = 1,
      col = 2;

  // --- slow down!
  // TODO: set if too much screen updates?
  // hack to make it slower
  // an oric does about 3000stms/s
  // for n==2 CHROMA is about 3s
  // for n==13 PRINT1-1000 16 s
  // TODO: instead, make MUSIC slower?
  let forceUpdate = false,
      forceUpdateLimit = 1024*1024;

  const ESC = 27;

  function boot() {
    stop('noprompt');
    CLS();
    
    
    // init
    vars = {};
    stack = [];
    line = '';
    lineno = 0;
    lineToDo = [];
    caps = true;
    click = true;
    column = false;
    printer = undefined;
    trace = false;
    tron = false;
    forceUpdate = false;
    forceUpdateLimit = 1024*1024;
    
    row = 1;
    col = 2;
    
    // at start only one channel enabled!
    PLAY['con1'] = 1;
    PLAY['con2'] = 0;
    PLAY['con3'] = 0;
    
    // stats
    putc.count = 0;
    putc.scrollcount = 0;

    screen.readcount = 0;
    screen.writecount = 0;

    run.count = 0;
    
    cont.intervalcount = 0;
    cont.millis = 0;

    // action
    showStatus();

    print(`
ORIC EXTENDED BASIC Vl.1
(C) 1983 TANGERINE

372631 BYTES FREE`);
  }

  // TODO: define imgs for each character?
  // then we can 'poke' to change them?

  // TODO: calling twice messes something up
  function TEXT() {
    for(let row=0; row<SCREEN_ROWS; row++) {
      let r = '';
      // lol, let's create one extra as the last character is kind of hidden...
      for(let col=SCREEN_COLS; col>=0; col--) {
	c = '&nbsp;';
	let id = `r${row}c${col}`;
	r = `<span id='a${id}'><span id='c${id}' class='char'>${c}</span>${r}</span>`;
      }
      dom('screen', r+'</br>', 'ah');
    }

    domc.cache = {};
  }
  TEXT.hires = false;
  
  // mode: 0 or 1
  //function LORES(mode) {
  //throw "LORES: Not implemented!";
  //}

  // Structurally it is very similar to the TEXT mode, with 40 bytes per line, with each byte representing 6 pixels for a total of 240 pixels in width.
  // The main difference is that each line is only one pixel tall instead of 8, so there are 200 of these.
  // The actual graphical resolution is 240x200, but the screen has an additional area at the bottom containing 3 lines of TEXT mode.

  // From a memory point of view, HIRES mode is much more voracious:
  // 8000 bytes for the HIRES part of the screen (from #A000 to #BF3F)
  // 120 bytes for the TEXT part of the screen screen (from #BF68 to #BFDF)
  // 42 bytes lost between the HIRES and TEXT parts of the screen (from #BF40 to #BF67)
  // 1024 bytes for the default character set (from #9800 to #9BFF)
  // 1024 bytes for the secondary ("alternate") character set (from #9C00 to #9FFF)
  // This makes a total of 10210 bytes.

  // http://twilighte.oric.org/twinew/ula.htm
  //function HIRES() {
  //implemented_error('HIRES');
  //throw "HIRES: Not implemented!";
  // SCREEN.hires = true;
  //}
  
/*
ince we can POKE any value we like to the screen we can use this to set up a 
High RESolution colour display using all eight colours. The following 
program produces a sinusoidal striation of colour down the screen in this 
manner. 
10 HIRES 
20 FORY=0T0199 
30 S=INTCSINCY/l0J*8J 
40 FORX=0T039 
50 P=#A000+Y*40+X 
60 Q=CS+XJ-INTCCS+XJ/8J*8+16 
70 POKE P,Q 
80 NEXT 
90 NEXT 
By using this method of placing attributes on the HIRES screen we can 
produce more colours from the Orie. We simply mix two different colours 
together on alternate lines and we can make at least 36 different colours. 
The following program demonstrates some of the colours which can be 
achieved. Even more shades can be accessed by overlaying patterns of 
foreground colours on these striped backgrounds! 
t 'COPYRIGHT PAN LTD 
10 PAPER 0: INK 7 
20 HIRES 
30 FOR A=0 TO 7 
40 FOR 8=0 TO 7 
50 FOR 1=8*20 TO 8*20+20 
60 P=#A000+Y*40+A*5 
70 IF INTCY/2)=1/2 THEN Q=l6+A 
=-16+8 
80 POKEP,Q 
90 NEXT 
100 NEXT 
110 NEXT 
ELSE Q 
So far the subject of writing
*/

  HELP.related.push('HIRES TEXT LORES GRAB HIMEM RELEASE');
  HELP.related.push('HIRES CIRCLE CHAR CURMOV CURSET DRAW FILL PATTERN POINT  ');
  HELP.related.push('RUN CLEAR GOTO GOSUB RETURN POP IF THEN ELSE ON FOR TO STEP NEXT REPEAT UNTIL PULL');
  HELP.related.push('RUN STOP CONT GOTO TRON TROFF');
  HELP.related.push('LOAD AUTO CSAVE STORE RECALL NEW DIM CLEAR');
  HELP.related.push('INPUT GET KEY$');
  
  const color = {
    black:   '#000000', 0: '#000000',
    red:     '#FF0000', 1: '#FF0000',
    green:   '#00FF00', 2: '#00FF00',
    yellow:  '#FFFF00', 3: '#FFFF00',
    blue:    '#0000FF', 4: '#0000FF',
    magnenta:'#FF00FF', 5: '#FF00FF',
    cyan:    '#00FFFF', 6: '#00FFFF',
    white:   '#FFFFFF', 7: '#FFFFFF',
  };
    
  let inverse = n=>7-n;
  
  function domc(id) {
    domc.cache = domc.cache || {};
    let d = domc.cache[id];
    if (!d) {
      d = dom(id);
      domc.cache[id];
    }
    return d;
  }
  
  function PLOT(x, y, s) {
    // DOC: X,Y raw-write VALUE to screen
    // If number, use it as charcode.
    if (printer)
      printer(`[ PLOT(${x},${y},"`);

    if (typeof s === 'number')
      s = String.fromCharCode(s);
    
    if (printer) printer(s);

    for(let i=0; i<s.length; i++) {
      screen(y, x, s.charCodeAt(i));
      if (++x >= 40) {
	x = 0; y++;
      }
    }
        
    // not totally "rigth" but it looks better
    if (printer) printer('" ]\n');
  }
      
  function SCRN(x, y) {
    // DOC: Return char/attr at X, Y
    return screen(y, x);
  }
  
  function POS() {
    // DOC: Column position
    return col;
  }
  
  // BRAILLE
  // https://en.m.wikipedia.org/wiki/Braille_Patterns
  // bit-value:
  //  1   8
  //  2  10
  //  4  20
  // 40  80
  let BRAILLE = 2800; // REALLY!?

  // nodejs can't handle it?
  // let braille =⠀"⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟";
	 
	 
  // this is like equivalent of POKE!
  // READ   screen(row, col) => ch
  // WRITE  screen(row, col, ch)
  //   ch <  0   magical pixels
  //   ch <  8   INK
  //   ch < 16   ... blink, ALT, double
  //   ch < 24   PAPER
  //   ch > 31   ASCII
  //   ch >127   ASCII inverted!
  //   ch > 255  Unicode ...
  function screen(row, col, ch, html) {
    let dc = domc(`cr${row}c${col}`);

    // TODO: speedup for read/scroll
    // screen.arr[row, col]
    // other idea: redraw from scratch!
    
    // --- READ screen?
    if (ch === undefined) {
      screen.readcount++;
      if (typeof dc.screenchar == 'number')
	return dc.screenchar;
      else
	return dc.screenchar = dc.textContent.charCodeAt(0);
    }
    screen.writecount++;
    dc.screenchar = ch;

    // hack for testing!
    if (html) {
      dc.innerHTML = html;
      dc.screenchar = ch;
      return
    }
    
    // no write?
    if (scoff) return scoff++;
    
    // --- WRITE!
    
    let da = domc(`ar${row}c${col}`);
    let t;

    // interpret char/attribute
    let c = ch & 0x7f;

    if (ch > 255) { // unicode! lol
      if (ch == 127) {
	// ATMOS font put it in unicode place!
	t = '&copy;';
      } else {
	// pass through, we don't c(h)ar(e)
	t = ch;
      }
    } else if (c >= 32) { // ascii
      // TODO: implement inverse!
      // remove high-bit as it means inverse
      t = ch & 0x7f; 
    } else if (ch < 0) { // bits...
      t =  BRAILLE - ch; // so it get's "added"
    } else if (c < 8) { // ink
      let fg = c & 0x07;
      if (c > 127) fg = inverse(fg);
      da.style.color=color[fg];
      t = 32; // blankk it out
    } else if (c < 16) {
      // Character Set modifier
      // 8  Use Standard Charset
      // 9  Use Alternate Charset
      // 10 Use Double Size Standard Charset
      // 11 Use Double Size Alternate Charset
      // 12 Use Blinking Standard Charset
      // 13 Use Blinking Alternate Charset
      // 14 Use Double Size Blinking Standard Charset
      // 15 Use Double Size Blinking Alternate Char
      let alt = c & 1;
      let double = c & 2;
      let blink = c & 4;
      // TODO: alt - complicated (edit font?)
      // https://en.fontke.com/font/10042736/
      // https://github.com/Zigazou/miedit
      // https://github.com/Zigazou/miedit/tree/master/font
      
    } else if (c < 24) { // 16-23 paper
      let bg = c & 0x07;
      if (bg > 127) bg = inverse(bg);
      da.style.backgroundColor=color[bg];
      t = 32; // blankk it out
    } else {
      // TODO: mode switching
      // idea: make screen garbled? lol
      // Video control attributes
      // 24-27 Switch to TEXT mode (60 Hz)
      // 28-31 Switch to HIRES mode (60 Hz)
    }

    if (t == 32) {
      dc.innerHTML = '&nbsp;';
    } else if (t !== undefined) {
      dc.textContent = String.fromCharCode(t);
    }

    // get out if set colors
    if (c < 32) return;
    
    // reset any attribute set previously
    da.style.color='';
    da.style.backgroundColor='';
  }
  screen.readcount = 0;
  screen.writecount = 0;

  function INK(color) {
    INK.color = color;
    // skip status line
    for(let row=1; row<SCREEN_ROWS; row++) {
      screen(row, 1, color);
    }
  }
  function PAPER(color) {
    PAPER.color = color;
    // skip status line
    for(let row=1; row<SCREEN_ROWS; row++) {
      screen(row, 0, 16+color);
    }
  }

  function exmple_PAPER() {
    return `
l0 FOR I=0 TO 7 
20 INK I 
30 FOR J=0 TO 7 
40 PAPER J 
50 WAIT 50 
60 NEXT J 
70 NEXT I 
80 INK 0 
`;
  }

  function example_PRINTAT() {
    return `
10 FOR X=2 TO 30 
20 PRINT @X,10;·• WHIZZ2" 
30 NEXT X
`;
  }

  function printerToggle() {
    if (printer) return printer = undefined;

    let p = dom('printer');

    printer = function(c) {
      // TODO: print@, plot, (screen?
      if (typeof c === 'number') {
	if (c >= 32 || c === 10)
	  c = String.fromCharCode(c);
	else if (c === 4) c = '[ TOGGLE DOUBLE LINE ]';
	else if (c === 6) c = '[ TOGGLE KEYCLICK ]';
	else if (c === 7) c = '[ BELL ]';
	else if (c === 8) c = '[ BACKSPACE ]';
	else if (c === 9) c = '[ RIGHT ]';
	else if (c === 12) c = '\n[ CLEAR SCREEN ]\n';
	else if (c === 13) c = '[ CR ]';
	else if (c === 14) c = '[ CLEAR LINE ]';
	else if (c === 15) c = '[ DISABLE SCREEN ]';
	else if (c === 17) c = '[ TOGGLE CURSOR ]';
	else if (c === 19) c = '[ TOGGLE SCREEN ]';
	else if (c === 20) c = '[ TOGGLE CAPS ]';
	else if (c === 27) c = '[ ESC ]';
	else
	  c = '[ CHAR: #' + c.toString(16) + ' (' + c + ') ]';
      }
      p.append(c);
    }
    return true;
  }
  
  // TODO: ORIC used to have blinking cursor
  // also has 'cursor' varaible controlled by
  let cursor = true;
  let raw = false;
  function cursorToggle(wantOn) {
    if (wantOn === undefined) {
      cursor = !cursor;
    } else if (typeof wantOn === 'string') {
      cursor = (wantOn.toLowerCase() === 'on');
    } else {
      cursor = !!wantOn;
    }

    if (!cursor) cursorHide();
    // don't show cursor here as this run as soon as key presseed leaving traces
    return cursor;
  }

  // cursorHide(),cursorShow() - don't call as it's managed by the system functions call cursorToggle() for your intent
  let cursorVisible = false;
  function cursorHide() {
    if (!cursorVisible) return;
    cursorVisible = false;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = '';
    d.style.color = '';
  }
  function cursorShow() {
    // TODO: right place? lol
    dom('exp').value = line;
    
    if (!cursor || cursorVisible) return;
    cursorVisible = true;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = 'black';
    d.style.color = 'white';
  }
  
/*
Codes0-31 
CODE CHARACTER Control Code 
0 Null 
1 Copy CTRL-A 
2 
3 Break	 CTRL-C 
4 Double line printing CTRL-D (TODO: jsk)
5 
6 Keyclick CTRL-F 
7 Bell (PING) CTRL-G  (TODO: jsk)
8 Backspace (Cursor left) CTRL-H  (TODO: jsk)
9 Cursor right CTRL-I  (TODO: jsk)
10 Line feed (Cursor down) CTRL-J  (TODO: jsk)
11 Cursor up CTRL-K  (TODO: jsk)
12 Clear screen CTRL-L  (TODO: jsk)
13 RETURN CTRL-M (beginning of line) (TODO: jsk)
14 Clear line CTRL-N  (TODO: jsk)
15 Disable screen CTRL-0  (TODO: jsk)
16 
17 Cursor CTRL-Q  (TODO: jsk)
18 
19 Screen CTRL-S  (TODO: jsk)
20 Caps (upper case) CTRL-T  (TODO: jsk)
21 
22 
23 
24 Cancel line CTRL-X 
25 
26 
27 ESC (Escape) (TODO: jsk)
28 
29 
30 
31 
32 Space
*/
  function putc(c) {
    if (typeof(c) !== 'number')
      alert('putc: only take nubmers: ' +  c);
    putc.count++;

    // TODO: if scoff should we printer?
    if (printer) printer(c);
    
    if (scoff) return scoff++;
    
    // TODO: how to handle inverse?
    let ch = c & 0x7f;
    if (ch === ESC) return raw = true;

    if (raw || ch >= 32) {
      screen(row, col, c);
      col++;
      raw = false;
      if (raw) alert('c===' + c);
      c = ch = undefined;
    }

    if (ch == 10) { row++; col = 2; }

    // backspace
    if (ch == 8) {
      col--;
      if (col < 2) col = 2;
      // TODO: I don't think backspace wraps?
      //if (col < 2) { col = 39; row--; }
      //if (row < 1) { col = 2; row = 1; }
      screen(row, col, 32);
    }

    // TODO: should be SCREEN_COLS????
    if (col >= SCREEN_COLS) { row++; col = 2; }

    // scroll!
    if (row >= SCREEN_ROWS) {
      putc.scrollcount++;
      let start = Date.now();
      for(let r=2; r<SCREEN_ROWS; r++) {
	for(let c=0; c<SCREEN_COLS; c++) {
	  let old = screen(r-1, c);
	  let nw = screen(r,c);
	  if (nw != old)
	    screen(r-1, c, nw);
	}
      }
      // TODO: if not hidden column mode?
      row = 27;
      for(let c=2; c<SCREEN_COLS; c++) {
	screen(row, c, 32);
      }
      //dom('info', 'scroll time='+(Date.now()-start), 'lp');
    }
  }
  putc.count = 0;
  putc.scrollcount = 0;

  // 20LETSEL=0 => 20 LET SEL = 0
  // TODO: 63999 max
  //  
  // integer -32767 to 32768
  // A%
  // A$

  // DIM varname(exp, ...)
  // TEST:
  //  Q(9)=3
  //  Q(10)=4
  //  Q(11)=5 => ?BAD SUBSCRIPT ERROR
  //  Q(0)=77
  //  Q(-1)=44 => ?ILLEGAL QUANTITY ERROR
  
  // TODO: fix
  // TODO: maybe let an array be a function! __Arr(3,4) evaluate to the value, or if LET an LVALUE
  // TODO: how to see in an exppression it's
  // an variable and not function call?
  function DIM(n, ...dims) {
    // DOC: Dimension an multidimensional array DIM A$(1:st dim, 2:nd dim, ...)
    // All elements set to detault value.
    // ORIC: Any array index 0..10 is 'predefined'
    // New: Any index can be set once dimensioned, it's automatically extended (with nulls!)
    // Bug: Not capture index out of bounds
    // Bug: There is no diff between array varaibles and others with same name...
    // ...and so PRINT will happily print the array
    let v = 0.0;
    if (n.match(/^\w+\%/)) v = 0;
    if (n.match(/^\w+\$/)) v = '';
    
    function gen(dim, ...dims) {
      if (!dim) return v;
      return [...Array(dim)]
	.map(_=>gen(...dims));
    }
    
    vars[n] = gen(...dims);
  }

  // TEST:
  //   LET IF=2 => ?Syntax...
  //   LET THE=3 => ok
  //   LET THENN=4 => ?Syntax...
  function LET(n) {
    let v = this;
    v = v.replace(/^\s*LET\s*\S+\s*=\s*/, '');
    if (trace) print('LET: ' + v);
    let r = EVAL(v);
    if (r === undefined) return;

    // make sure type fit
    if (n.endsWith('%')) {
      tInt(r);
      r = INT(r);
    }
    if (n.endsWith('$')) r = ''+r;

    // indexing (interpolate using fixpoint!)
    let lastn = n;
    while (lastn != (n = n.replace(
      /\[([^\[\]]*)\]/g, (_,i)=>'['+EVAL(i)+']'))) {
      if (trace) print('IX: ' + n);
      lastn = n;
    }

    // okay, have value, try to set it
    if (trace) print('SET: ' + n);

    // array A(3,4)=77 complicates things...
    // TOOO: make a ref('A$', val)
    // or replace A$ with a function
    // ARRAY_A$
    let path = n.replace(/[\[\]]/g, ' ').trim()
	.split(/\s+/g);
    if (trace) print('PATH: ' + JSON.stringify(path));
    let nv = vars;
    let x;
    let lastx = path.shift();
    while ((x = path.shift()) !== undefined) {
      if (trace) print('LOOP lastx: ' + lastx);
      if (trace) print('LOOP x: ' + x);
      nv = nv[lastx];
      lastx = x;
    }
    if (trace) print('SET: ' + (nv == vars) + ' ' + lastx);
    nv[lastx] = r;
  }

  function EVAL(x) {
    try {
      if (trace) print('VARS: ' + JSON.stringify(vars));
      // pow!
      x = x.replace(/\^/g, '**');
      if (trace) print('EXP: >' + x + '<');
      // TOOD: not correct comparisons
      // as ORIC returns 0/-1 for false/true
      if (x.match(/(<|=|>)/))
	return implemented_error('comparisons');
      let r = (function(ATMOSexp){
	// fast cheat!
	with (vars) {
	  return eval(ATMOSexp);
	}
      })(x);
      if (trace) print('-->: ' + r);

      // check illegal values
      if (r === Number.NEGATIVE_INFINITY ||
	  r === Number.POSITIVE_INFINITY)
	div_error();
      if (Number.isNaN(r))
	type_error();
      if (r === undefined) // ???
	type_error();

      // TODO: overflow wraparound?
      
      // should we allow extensions?
      if (typeof r === 'object')
	type_error();

      return r;
    } catch(e) {
      console.log('?EVAL: ' + x);
      console.log('ERR=', e);
      //eval_error('' + e);
      //stop();
      throw e;
    }
  }
  
  function val(n) {
    //n = n.substring(0, 2);
    return vars[n];
  }
  
  // Also CTRL-L
  // TODO: manual says it'll clear screen
  // AND: set it to current INK/PAPER!!!?
  function CLS() {
    let start = Date.now();
    // TODO: does it scroll colors?
    // don't touch mode-line
    for(let row=1; row<SCREEN_ROWS; row++) {
      for(let col=2; col<SCREEN_COLS; col++) {
	screen(row, col, 32);
      }
    }
    row = 1; col = 2; raw = false;
    //dom('error', 'CLS time ' + (Date.now()-start));
  }

  // 20 INPUT"ENTER SALE PRICE";SELL
  function INPUT(prompt, v) {
  }

  function princ(txt) {
    return print(txt, 'nonewline');
  }
  function print(txt, nonewline) {
    if (txt === undefined) return putc(10);

    // for numbers ORIC makes SURE it fits
    // without line breaks!
    if (typeof txt == 'number') {
      txt = ' ' + txt + ' ';
      if (col + txt.length > SCREEN_COLS) // ?
	putc(10);
    } else {
      txt = '' + txt;
    }
    
    // make sure we have text
    for(let i=0; i<txt.length; i++)
      putc(txt.charCodeAt(i));
    if (!nonewline) putc(10);
  }

  function TAB(pos) {
    // DOC: Move cursor to POS
    // New: If no arg move to next column
    // New: -POS is using custom tabwidth POS
    // New: "3" means use 3 cols (=INT(-40/3))
    
    // positive number
    if (+pos===pos && +pos > 0) {
      while(col < pos)putc(32);
      return '';
    }

    // use columns
    if (typeof pos === 'string')
      pos = -INT(SCREEN_COLS/(+pos));
    let width = (pos < 0) ? -pos : 8;
    while((col-2) % width !== 0)
      putc(32);
    
    // return '' as I think it's used in PRINT
    return '';
  }
  
  
  // #FFFFF 
  // PRINT "FOO"BAR"
  // PRINT "4*3="; 4*3
  // PRINT "FOO";"BAR" => FOOBAR
  // ?35 == PRINT 35
  // PRINT 1;2 => <spc>1<spc><spc>2<spc>
  // 40 PRINT"THE CODE FOR "A$"="ASC(A$)
  // PRINT "foo",
  // PRINT "bar"    > fooo       bar 
  // 20 PRINT @X,10;·• WHIZZ2" 
  // TEST: PRINT 1 2 3+6 =>  123  6
  // TEST: PRINT 1 2 3, 4 5, FOO, FOO& =>
  //   123     45   3
  //   ?SYNTAX ERROR
  // TEST: LET A=1 2 3 : PRINT A => 123
  // TEST: A=77 : AA=6 : A$="FOO"
  //   TEST: PRINT A A => 6
  //   TEST: PRINT 7A => 7  77
  //   TEST: PRINT 9AA4 5, 99 => 9  6   99
  //   TEST: PRINT 3A$6 =>  3 FOO 6
  //   PRINT 3A$77AA(3)5A$A =>
  //     3 FOO 77 0 5 FOO 77
  //   ?A$7A$AA => FOO 7 FOO 6
  //   ?A$3+4*10^2A => FOO 403  77
  //   PRINT A A => 6
  //   PRINT AA => 6
  //   PRINT A => 77
  //   ? A A+7 => 13
  // TEST: LET A B = 7 5
  //   PRINT AB =>  75
  //   PRINT AB 5 =>  75
  //   PRINT AB C => 75
  // TODO: PRINTAT
  //  20 PRINT @X,10;·• WHIZZ2"

  // TODO: print ctrl-codes perform action!
  function PRINT() {
    let line = this;
    line = line.replace(/^L*PRINT\s*/, '');
    line = line.trim();

    let exp = '', mode = 'normal', par = '';
    let nonewline = false;
    for(let i=0; i<line.length; i++) {
      let c = line[i];
      if (trace) print('PRINT.c: ' + c);

      function finish(ev) {
	if (exp.length && !exp.match(/^\s*$/))
	  princ(ev?EVAL(exp):exp);
	exp = '';
	if (c === ',') TAB();
      }
      
      switch(mode) {
      case 'normal': {
	switch(c) {
	case ',':
	case ';': 
	case ' ': finish(true); break;
	case '\\': return unexpected_error('\\');
	case '"': finish(true); mode = 'string'; par += '"'; break;
	case '(': exp += c; mode = 'expr'; par += ')'; break;
	case '[': exp += c; mode = 'expr'; par += ']'; break;
	default: exp += c;
	}
	break;
      }
      case 'string': {
	if (c=='"') {
	  if (exp.length)
	    princ(exp)
	  exp = '';
	  mode = 'normal';
	} else {
	  exp += c;
	}
	break;
      }
	// TOOD: too simple
      case 'expr': {
	if (par)
	  if (')]"'.indexOf(c) >= 0) {
	    let e = par[par.length-1];
	    if (e !== c)
	      return unmatched_paren_error(e, c);
	    else
	      par = par.substring(0, par.length-1);
	  }
	
	switch(c) {
	case '\\': return unexpected_error('\\');
  
	case '(': par += ')'; break;
	case '[': par += ']'; break;
	case '"': par += '"'; break;
	  
	case ';':
	  if (par) return unexpected_error(';');
	  // else! fallthrough
 	case ',':
	case ' ': {
	  if (exp.length && !par.length) {
	    princ(EVAL(exp))
	    exp = ''
	    mode = 'normal';
	  }
	  if (c === ',') TAB();
	  break;
	}
	default: exp += c;
	}
	break;
      }
      }
      if (c !== ' ') nonewline = false;
      if (c === ';') nonewline = true;
    }

    // cleanup
    if (exp.length) {
      // TODO: missing " ?
      if (mode === 'string')
	princ(exp);
      else
	princ(EVAL(exp));
    }
    if (!nonewline)
      putc(10);
  }

  HELP.related.push('LIST LLIST EDIT CLOAD CSAVE');
  HELP.related.push('TEXT PRINT LPRINT CLS INK PAPER SCRN PLOT POS TAB SPC');
  /*
LPRINT, LLIST...

LPRINT BASIC Token: 143
Format: LPRINT A$

This command works exactly the same as a PRINT statement except that it is used to send the print items to a printer. However, it is not possible to use an LPRINT@ statement. Used vvith the control codes listed in Appendix 1, LPRINT can be used to regulate the output to a variety of printers. It is possible to alter the line length of the printer output by using POKE #256,i where i is the required line length. 

  Related keywords: CHR$, LLIST, PRINT
  */
  function LLIST() {
    // DOC: List program to printer

    // save state
    let psave = printer, ssave = scoff;

    // turn on printer, and screeen off!
    if (!printer) printerToggle();
    scoff = 1;

    // essense of LIST
    {
      line = '';
      lineno = -1;
      print();
      nextline();
      while (line) {
	princ(lineno);
	print(line);
	nextline();
      }
      print();
      lineno = 0;
      line = '';
    }

    // restore
    printer = psave;
    scoff = ssave;
  }

  // TODO: same complicated parsing as PRINT...
  function LPRINT(...args) {
    // DOC: Prints to the printer
    // TODO: doen't handle TAB()

    // save state
    let psave = printer, ssave = scoff;

    // turn on printer, and screeen off!
    if (!printer) printerToggle();
    scoff = 1;

    // cheat
    // TODO: keep track of col?
    PRINT.apply(this, args);

    // restore
    printer = psave;
    scoff = ssave;
  }


  // TODO: Basic Lines max 80 chars bell at 79?

  // LIST -100
  // LIST 100-
  // LIST 100-200

  // TODO: sorted?
  let lines = {
    //1: 'PRINT "HELLO!"',
    //2: 'END',
    
    10: 'LET A=0',
    20: 'PRINT A;',
    30: 'LET A=A+1',
    40: 'GOTO 20',
  };

  ylines = {
    5: 'LET E=1000',
    10: 'FOR I=0 TO E',
    15: 'PRINT I',
    20: 'NEXT',
  };
  
  xlines = {
    10: 'LET I=0',
    20: 'LET P=0',
    30: 'INK I',
    40: 'PAPER P',
    50: 'LET P=P+1',
//    50: 
  };
  
  function running() {
    return !!RUN.interval;
  }
  
  // TODO: like list but formats the code...
  // prettyprint
  // function PP()  {
  //
  //}

  function LIST(n) {
    line = '';
    lineno = -1;
    print();
    
    RUN.interval = setInterval(_=>{
      for(let i=0; i>=0; i--) {
	nextline();
	if (!line) {
	  lineno = 0;
	  line = '';
	  stop();
	} else {
	  princ(lineno);
	  print(line);
	}
      }
    }, 0);
  }

  function saveline(lno, line) {
    if (trace) print('saveline.lno: ' + lno);
    if (trace) print('saveline.line: ' + line);

    // we remove one initial space
    // which means saving need to add one..
    let l = line.replace(/^\s/, '');
    if (trace) print('saveline.l: ' + l);

    // ? expansion! (short hand for PRINT)
    // TODO: another day!
    //line.replace(/^(([^"]*)(|"[^"]"))$/g,
    // what does the function get?

    // TODO: REM ?5 not expanded
    // BUT: ' ?5 IS!
    // NOT: ' sdfsdf "foo ?5 sdf" ISN'T!!!

    // store line (or remove)
    if (l.match(/^\s*$/))
      delete lines[lno];
    else
      lines[lno] = l;
      
  }
  
  function EDIT(lno) {
    // DOC: Print, move cursor to LINENO
    // New: Just EDIT if STOP:ped
    // New: Line keeps spaces!
    lno = lno || lineno;
    let line = lines[lno]
    // TODO: error?
    if (!line) return;

    print(lno + ' ' + line);
    cursorMove('u');
  }
  
  function TRON() {
    tron = true;
  }
  function TROFF() {
    tron = false;
  }


  function CLEAR() {
    // DOC: Clears variables
    lineno = 0;
    line = '';
    stack = [];
    lineTodo = [];
    vars = {}
  }

  function RUN(lno) {
    // DOC: Runs program (from LINE)
    // END, STOP, or CTRL-C interrupts
    // Continue with CONT or GOTO num
    CLEAR();
    GOTO(lno || 0);
  }
  
  // TODO: On ORIC you can CONT after END!
  function END() {
    stop('noprompt');
  }
  
  function nextline() {
    // crazy linear search for next!
    // you could goto any number
    // it just find the next numerically
    line = '';
    while (!line && lineno < 65536) {
      lineno++;
      // TODO: these aren't guaranteed to be in order? only when for-in!!!
      line = lines[lineno];
    }
    if (line === undefined) line = '';
  }

  function cont() {
    if (running()) return;
    
    RUN.interval = setInterval(_=>{
      cont.intervalcount++;
      let start = Date.now();
      let millis;
      let n = 0;
      forceUpdate = false;
      do {
	nextline();
	if (line && trace) print(lineno + ' ' + line)
	if (tron) princ('[ '+lineno+']');
	if (!run(line)) stop();
	millis = Date.now() - start;

	forceUpdate = (n++ > forceUpdateLimit);
      } while (!forceUpdate && millis  < TIMESLICE);
      cont.millis += millis;
    }, 1);
  }
  cont.intervalcount = 0;
  cont.millis = 0;
  
  // TODO: if program edited?
  function CONT() {
    if (!CONT.lineno)
      return cont_error();

    lineno = CONT.lineno;
    line = CONT.line;
    delete CONT.lineno;
    delete CONT.line;

    cont();
  }

  function GOSUB(lno) {
    stack.push(['RETURN', lineno, line]);
    lineno = lno-1;
    line = '';
  }
  function RETURN() {
    let ret = stack.pop();
    if (!ret) return_error();
    if (ret[0] !== 'RETURN')
      return return_error();
    [ret, lineno, line] = ret;
  }    

  // use same stack as GOSUB as they need to be matched! (you can't GOSUB and there NEXT)
  function FOR() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('FOR.init: ' + init);
    print('FOR.to: ' + to);
    print('FOR.step: ' + step);

    let v = init.match(/^(\w+)\s*=/);
    if (!v) syntax_error('');
    ('LET ' + init).LET();

    // TODO: this is when I realize
    // that doing it on the fly isn't going
    // to work very well,
    // HMMM,why was that again? lol
    // FOR-NEXT, GOSUB-RETURN and
    // and something about
    // FIE : FOR : BAR
    // FUM : NEXT : FOO
    //
    // FIE : STOP : BAR
    //
    // PRINT 11 : STOP : PRINT 22 : END
    // CONT -> 22
    // CONT ater END ok! haha
    //
    // notice: the loop is run at least once!
    //   and it'll do one step...
    // ?NEXT WITHOUT FOR ERROR IN LINE...
  }

  function TO() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('TO.to: ' + to);
    print('TO.step: ' + step);

    to = EVAL(to); // once or every time?
    step = EVAL(step); // once or every time?
    if (variable <= to)
      stack.push([lineno, `TO ${to} STEP ${step}`]);
  }

  function NEXT() {
    // TODO: ...
    // cheat for now
    return RETURN(); 
  }

  // TEST:
  //  IF 1 THEN ?1 ELSE ?2 => 1
  //  IF 0 THEN ?1 ELSE ?2 => 2
  //  IF1THENIF1THEN?1ELSE?2ELSE?3 => 1
  //  IF1THENIF0THEN?1ELSE?2ELSE?3 => 2
  //  IF0THENIF0THEN?1ELSE?2ELSE?3 =>>
  //  IF0THENIF1THEN?1ELSE?2ELSE?3 =>>
  

  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  // IF 1 THEN ?2 : ?3 ELSE ?4 : ?5 : ?6
  //   => 2 3 5 6
  // IF "" THEN ?1 ELSE ?2 => 2
  // IF ("") THEN ?1 ELSE ?2 => ?FORMULA COMPL
  // IF "A" THEN ?1 ELSE ?2 => 1
  // IF ("A") THEN ?1 ELSE ?2 => 1
  
  let traceif = 0;
  function IF(e) {
    if (traceif) print("IF.hello");
    let line = this;
    while (line.match(/(IF|THEN|ELSE)/)) {
      if (traceif) print('IF: ' + line);
      line = line.trim();

      // we're (maybe) in the THEN
      // - skip the first statement after ELSE
      // continue with the rest!
      if (line.match(/^ELSE/)) {
	if (traceif) print('ELSE: ' + line);
	// remove anything before ':'
	//   (':' inside "string" ok)
	line = line.replace(
	  /^[^:"]*("[^"]*"[^:"]*)\s*/,
	  '');

	if (traceif) print('ELSE.replace: ' + line);

	// if just a single statement no ':'
	if (line.length && line[0] != ':')
	  return;

	// we've skipped the ELSE part
	// IF 1 THEN ?3:?4 ELSE ?5:?6:?7=>3467
	// how to go to "run"?

	// TODO: make cont()/nextline()
	//   use queue to pull next thing?

	lineToDo.unshift(line);
	return;
      }
      
      let exp, expr;
      line = line.replace(
	/^IF\s*(.*?)\s*THEN\s*/,
	(_, e)=>{
	  exp = e;
	  // string constant, strange!
	  if (exp.startsWith('"')) {
	    // "" => false
	    // "A" => true
	    expr = (exp !== '""')?-1:0;
	  } else if (exp.match(/^[A-Z]\w*\$/)) {
	    // any string variale => true
	    expr = -1;
	  } else { // ok, let's guess number?
	    expr = EVAL(exp);
	  }
	  return '';
	});

      if (traceif) print('------------');
      if (traceif) print('IF.left: >' + line);
      if (traceif) print('IF.exp: ' + exp);
      if (traceif) print('IF.expr: ' + expr);

      // did we get it?
      if (exp === undefined || expr === undefined)
	syntax_error();

      // not true => ELSE
      if (!expr) {
	if (traceif) print('IF.false ' + expr);
	// TOOD: this cheats: "foo ELSE ..."
	let t = line.indexOf('THEN');
	let e = line.indexOf('ELSE');

	if (traceif) print('IF.false t=' + t + ' e=' + e);

	// no ELSE - we're done!
	if (e < 0) return;

	// TODO: check, for loop in THEN?
	// and can it have ELSE inside? LOL
	// see gphotos: IF-FOR-ELSE!!!
	// seems
	// IF THEN ?1:FORI=0:IF THEN ELSE:NEXT:?77 ELSE <never reached> - so it's OK!

	// have more THEN - ELSE=not ours!
	if (t >= 0) return;

	// skip to after ELSE and do rest
	line = line.substring(e+4);
	
	let g = line.match(/^\s*(\d+)\s*/);
	if (g) return GOTO(+g)
      }

      line = line.trim();

      // if true - just continue!
      // TODO: this doesn't work for nested...
      line = line.replace(
	/^\s*(.*?)\s*(ELSE.*)\s*$/,
	(_, th, el)=>{
	  if (+th == th)
	    GOTO(+th);
	  else
	    run(th);
	  return ''
	});
      // but keep in mind that when
      // reach 'ELSE ?3:?4:?5' skip to
      // ?4 ...
    }
    // remaining to run!
    // TODO: ok, false for ?35 ELSE ?35:?36
    run(line);
  }
  
  function REPEAT() {}
  function UNTIL() {}

  function stop(noprompt) {
    //print('STOPPED!');
    let wasrunning = running();
    if (col > 2) print();
    if (wasrunning) {
      clearInterval(RUN.interval);
      delete RUN.interval;
      if (!noprompt) prompt();
    }
    line = '';
    return wasrunning;
  }
  
  function GOTO(lno) {
    tPos(lno);
    // DOC: Goto given LINENO
    // New: if no line, search next
    lineno = lno-1;

    cont();
  }

  // -- dummies
  function REM() {
    // DOC: REMMARK nice days, isn't?
  }
  // haha thought it was autonum?
  function AUTO() {
    // DOC: CSAVE "fnme", AUTO autoruns!
  }
  // CALL DEEK (#FFFC) ' HARD RESET
  // CALL DEEK (#FFFA2 ' WARM RESTART
  function CALL() {
    error("?WHO'RE YOU GONNA CALL? STEVE?");
  }
  function USR() {
    error('USSR NOT ANSWERING. TRY LATER!');
  }
  
  function FRE() { return FRE.size; }
  FRE.size = 393737; // Atmos 38737;
  // LOL
  function GRAB() { FRE.size *= 2; }
  function HIMEM() { FRE.size *= 2; }
  function RELEASE() { FRE.size *= 2; }
  
  function STOP() {
    cursorHide();
    let lno = lineno;
    let l = line;
    if (stop('noprompt')) {
      if (col>2) print();
      princ(' BREAK IN   '+lineno);
      CONT.lineno = lno;
      CONT.line = l;
    }
    prompt();
    cursorShow();
  }
  
  // WAIT 100 = 1s
  function WAIT(decaseconds) {
  }
  
  function example_VAT() {
    return `
10 REM *VAT Calculation* 
20 INPUT"ENTER SALE PRICE";SELL 
30 LET VAT=0. 15*SELL 
40 LET PRICE=SELL+VAT
50 PRINT "TOTAL=";PRICE 
60 'Round agan for next calculation
70 WAIT 500:CLS:GOTO 20
`;
  }

  function  example_NAME() {
    return `
10 A$="0RIC" 
120 LET Al$="BASI·C" 
130 LET LAST$="LESSON" 
140 INPUT"ENTER YOUR NAME,PLEASE";NAME$ 
150 CLS:PRINT A$;" ";Al$;" ";LAST$ 
160 PRINT "FOR ";NAME$
`;
  }

  function example_KEY() {
    return `
10 PRINT"PRESS A KEY" 
20 GET A$ 
30 PRINT"YOU PRESSED "A$ 
40 PRINT"THE CODE FOR "A$"="ASC(A$) 
50 GOTO 10
`;
  }

  function example_DEF() {
    return`
5 REM*Define Function M to convert feet 
to metres 
10 DEF FNM(FEET)=FEET*0.3048 
20 INPUT"HOW MANY FEET";X 
30 M=FNM(X) 
40 PRINT X;"FEET EQUAL";M;" METRES"
`;
}

  function example_FOR() {
    return `
10 FOR L=l TO 5:PRINT L*L:NEXT L 

10 FOR L=10 TO 5 STEP-l:PRINT L*L:NEXT 

10 CLS 
20 FOR LOOP=0 TO 25 
30 PRINT CHR$(65+LOOP)+CHRS(97+LOOP); 
40 NEXT LOOP 
`;
  }

  function example_READDATA() {
    return `
10 REM*READ o.nd DATA* 
20 FOR 0=0 TO 6 
30 READ D$ 
40 PR1NT D$ 
50 NEXT 
60 REM . . . lots more program 
70 ' 
2000 DATA MONDAY,TUESDAY,WEDNESDAY,THUR 
SDAY 
2010 REM ... more program in between 
3000 DATA FRIDAY, SATURDAY,SUNDAY 
4000 REM .. co.n do it 0.90.in 
4010 RESTORE 
4020 FOR K=l TO 7 
4030 READ DAY$:PRINT DAY$:NEXT
`;
  }

  function example_DIM() {
    return `
10 INPUT"HOW MANY NAMES" ;N% 
20 DIM NAME$(N%):DIM AGE(N%)
30 CLS:SLJM=0 
40 FOR K=1 TO N%
50 PRINT "ENTER NAME t'-10. "K 
60 INPUT NAME$[K]
70 PRINT NAME$[K]"'S AGE ?" 
80 INPUT AGE[K] :SLJM=SLJM+AGE[K]
80 CLS 
100 NEXT K 
110 FOR K=N% TO 1 STEP -1 
120 PRINT :PR1NT NAME$[K]" JS";
130 NEXT K
`;
  }
  
  function example_2DIM() {
    return `
10 DIM NXC10,3) 
20 CLS 
30 FOR K=l TO 10 
40 ~OR J=l TO 3 
50 NxCK,JJ=K"J 
60 PRINT NxCK,JJ 
70 NEXT J 
80 PRINT 
90 NEXT K
`;
  }

  function example_BUBBLESORT() {
    return `
5 REM*NUMERIC BUBBLE SORT** 
10 CLS:LET J=15 'Number of items 
20 DIM NUMCJJ'ATray foT numbeTs 
30 'Example numbers generated here" 
40 FOR K=0 TO J 
50 LET NUMCKJ=RNDC1J*1000 
60 PRINT NUMCKJ 
70 NEXT K 
99 ' 
100 REM*SORT*ROUTINE* 
101 ' 
110 FOR M=l TO CJ-lJ 
120 FOR N=M TO J 
125 REM If correct ordeT 
already,then skip 
130 IF NUMCMJ<NUMCNJ THEN 170 
135 REM Incorrect order,so swap 
140 TEMP=NUMCMJ 
150 NUMCMJ=NUMCNJ 
160 NUMCNJ=TEMP 
170 NEXT N 
180 NEXT M 
189 ' 
190 REM**ENDSORT** 
191 ' 
200 REM *Print sorted list* 
210 CLS:PRINT ''SORTED LIST:" 
220 FOR K::::JTO J 
230 PRINT NUMCKJ 
240 NEXT K 
`;
  }

  // loop is completed, the address is removed, and a subsequent NEXT will 
  // activate a jump to the address now on the top of the pile. The stack can only 
  // hold 10 addresses, and more than 10 loops will give an ?OUT OF MEMOR
  
  function READ() {}
  function DATA() {}
  function RESTORE() {}
  
  // GET K$
  function GET() {}
  function READ() {}
  function DATA() {}

  function ASC(s) {
    // DOC: get ascii number from string
    tString(s, s === '');
    return s.charCodeAt(0);
  }

  function CHR$(n) {
    // DOC: get char from ascii number
    tNum(n, n < 0 || n > 255);
    // TODO: cheat with allo unicode?
    return String.fromCharCode(n);
  }

  function STR$(n) {
    // DOC: make a string from a number
    tNum(n);
    return (n < 0 ? '' : ' ') + n.toString();
  }

  function HEX$(n) {
    // DOC: return #HEX for number
    // Curiosity: return #0 for string
    if (typeof n !== 'number') return '#0';
    tNum(n, n < 0 || n > 65535);
    return '#' + INT(n).toString(16).toUpperCase();
  }  

  function LEN(s) {
    tStr(s);
    return s.length; }

  function LEFT$(s, len) {
    // DOC: From S return LEN first chars.
    tStr(s); tPos(len);
    return  s.substring(0, len);
  }    
  function RIGHT$(s, len) {
    // DOC: From S return LEN last chars.
    tStr(s); tPos(len);
    return  s.substr(-len);
  }

  function MID$(s, pos, len) {
    // DOC: From S from POS get LEN chars
    tStr(s); tPos(pos); tPos(len);
    return s.substr(s, from, len);
  }

  function SPC(n) {
    tPos(n);
    return ' '.repeat(n);
  }
  
    
  function VAL(s) {
    // Oric: doesn't even need to terminate "string in PRINT, but in VAL("FOO   have to...
    
  }    
  
  // REM comment
  // ' commment
  function REM() {}

  // ---------------- MATH
  // NOTE: All math (even I%+1) is performed
  // using floating numbers, only when LET
  // is the quantity checked
  //
  // + - * / ^
  //   / == div_error()... check...
  
  // Oric BASIC has the following built-in numeric functions: 

  HELP.related.push('ABS INT'); {
    ABS = Math.abs;
    function INT(n) {
      // DOC: Removes the decimals
      // (it may not fit into I%)
      tNum(n);
      return Math.floor(n);
    }
    SGN = n=>(n>0)?+1:(n<0)?-1:0;
  }

  HELP.related.push('EXP LN LOG ^'); {
    EXP = Math.exp;
    LN = Math.ln;
    LOG = Math.ln10;
  }

  HELP.related.push('PI SIN COS ATN TAN'); {
    ATN = Math.atan;
    COS = Math.cos;
    PI = Math.PI;
    HELP.PI = `
// DOC: Mathematical pi
`;
    SIN = Math.sin;
    TAN = Math.tan;
  }

  HELP.related.push('TRUE FALSE AND OR NOT'); {
    TRUE = -1;
    HELP.TRUE = `
// DOC: True value
// (actually -1 == all bits set!)
`;

    FALSE = 0;
    HELP.FALSE = `
// DOC: False value
// (actually 0 == all bits zero!)
`;

    function AND(a, b) {
      // DOC:And two expressions
      // (bitwise 'and' 2 values)
      // Related: AND OR NOT TRUE FALSE
      return a & b;
    }
    function OR(a, b) {
      // DOC: Or of two expressions
      // (bitwise 'or' 2 values)
      // Related: AND OR NOT TRUE FALSE
      return a | b;
    }
    function NOT() {
      // DOC: Not and expression
      // negate all bits (0 <=> -1)
      // Related: AND OR NOT TRUE FALSE
      return -(a+1);
    }
  }

  SQR = Math.sqrt;

  // TODO: neg seeds!
  // TODO: find original algrithm
  function RND(n) {
    // DOC: RND(0) - random number [0, 1[
    // TOOD:
    // RND(-N) always starts same sequence
    tNum(n);
    if (n < 0)
      error('?RND(-SEED) not implemented');
    //if (!n)
    return Math.random();
    //return Math.floor(n * Math.random());
    // Too bad it's not there... lol
  }

  // tested by means of conditional operators: 
  // Equal to 
  // <> Not equal to 
  // > Greater than 
  // < Less than 
  // >= Greater than or equal to 
  // < = Less than or equal to 
  // These operate much as you would expect for numeric values. Two things 
  // need to be remembered, however. The fir

  // 10 DEF FNMCFEETJ=FEET*0.3048 
  //function DEFFN(n, exp) {}

  function example_ONGOTO() {
    return `
10 l NPUT" ENTER 1 .. 2 OR 3_, PLEASE' ' ;N 
20 ON N GOTO 150,200,300 
140 RP1 
159 PRINT "LINE 150 FROM N=J";GClTO 10 
190 REM 
200 PRINT "LINE 200 FROM N=2":GOTO 10 
290 REM 
300 PRINT "LINE 300 FROM N=3" :GOTO 10
`;
  }

  // https://osdk.org/index.php?page=articles&ref=ART9.
  
  // So if the first byte of the screen (#BB80), contains the value 65 (ASCII code for the upper case A letter), we know that this block of 6x8 pixels will be filled with graphical information stored at the address #B400+(8*65).

/* special addresses:
some may be considere "simulated"

--- KEYS
$17 Set to 1 if CTRL C pressed, otherwise 0. 
$35-$84 Input buffer. (79 bytes) 
$208 Key address if pressed — #38 if no key pressed. 
$209 Key status, 
 #38 - Default, 
 #A2 - CONTROL, 
 #A4 - Left SHIFT, 
 #A5 - FUNCTION (Atmos only), 
 #A7 - Right SHIFT. 
$20A Saved key column for repeat. 
$20C Bit 7 is set if CAPS is on otherwise clear. 
$20D 
$20E Repeat counter for keyboard. 
$20F 
$210 Temporary store of row of key being tested for repeat. 
$211 Temporary store of keyboard row during strobe routine. 

--- TEXT
$12,$13 Address of text cursor. 
$2E CTRL O flag. 0 if output to screen enabled.$30 Cursor position for Basic printout. 
$31 Screen line width. 
$32 8 - multiple line width. 
$21F 0 - LORES, 1 - HIRES. 
$23B-$23D Jump to GET KEY routine (V1.1). 
$23E-$240 Jump to SEND BYTE TO PRINTER (V1.1). 
$241-$243 Jump to PRINT TO STATUS LINE (V1.l). 
$24E Keyboard initial repeat deiay (V1.l). 
$24F Keyboard successive repeat delay (V1.1). 
$250 
$251 Cursor enabie in CTRL routines (Vl.l).
$256 Printer width (Vl.l). 
$257 Screen width (Vl.l). 
$258 Printer cursor position (V1.1). 
$259 Screen cursor position (V1.1). 
$265 Current cursor state indicator, 0 - off, 1 — on. 
$266,$267 
$268 Cursor row number, (status line is row 0).
$269 Cursor column position. 
$26A Flag byte. 
 Bit Flag function when bit is set to 1. 
 0 Cursor on. 
 1 Printout to screen enabled. 
 2 Unused. 
 3 Disable keyciick. 
 4 Previous printed character was ESC 
 5 Protect columns 0 and 1 of screen. 
 6 Double height characters. 
 7 Unused. 
$26B Paper colour (+16). 
$26C Ink colour. 
$26D,$26E Start address of screen memory. 
$26F Number of text lines available on screen (V1.0). 
$270 Cursor on/off flag. 
$271 Cursor invert flag. 
$272,$273 Keyboard timer. 
$274,$275 Cursor timer. 
$278,$279 Address of second line on screen (V1.1). 
$27A,$27B Address of first line on screen (V1.1). 
$27C,$27D Number of characters normally used in screen scrolling, 
26 x 40 – 1,040 or #410 (V1.1). 
$27E Number of rows of text available (V1.1). 
$2C0 Screen status, 0=GRAB, 2=TEXT and 3=HIRES.

--- HIRES
$10,$11 Address of hires cursor. 
$A6,$A7 Himem. 
$212 Holds FB code in hires commands. 
$213 Pattern data for hires screen. 
$214 Temporary copy of pattern byte for drawing lines. 
$215 Holds position of pixel in byte corresponding to position of 
cursor on hires screen. 
$216,$217 Temporary store of hires X and Y cursor positions. 
$218 Temporary store for content of $215. 
$219 Hires cursor — X coordinate. 
$21A Hires cursor — Y coordinate. 
$21F 0 - LORES, 1 - HIRES. 
$2C0 Screen status, 0=GRAB, 2=TEXT and 3=HIRES.$2C1,$2C2 Char set start address in HIRES mode (V1.1). 
$2C3 Cursor movement in hires, 0 = Absolute, 1 = 
$2DF Latest key from keyboard. Bit 7 set if valid. 
$2E0 Non zero if error in Sound / Graphics routines. 
$2F1 Bit 7 set to 1 if printer enabled. 
$2F2 Bit 7 is EDIT flag, set to 1 when on. 
$2F4 TRACE flag, set if bit 7 is set. 

--- PROGRAM
$A8,$A9 Current line number, top byte is #FF if in command mode. 
$AA,$AB Previous line number. 
$AC,$AD Last line start address. 
$AE,$AF Temporary copy of line number. 
      
$B4,$B5 Last variable name accessed. 
$B6,$B7 Address of last variable value accessed
$E9,$EA Position pointer in program. 
$252 ELSE pending flag, 1 - on, 0-off (Vl.l). 
$253-$255 
$2F5,$2F6 Indirect jump for '!' routine. 
$2FB-$2FD Jump to '&' routine. 


--- HARDWARE
$220 0 - 48K Oric, 1 - 16K Oric. 
$228-$22A Jump to IRQ routine (V1.0). 
$22B-$22D Jump to NMI routine (V1.0). 
$244-$246 Jump to IRQ routine (Vl.l). 
$247-$249 Jump to NMI routine (Vl.l). 
$24A—$24C RTI instruction which can be intercepted by a jump (Vl.l). 
$230 RTI instruction (V1.0). 

$21—$23 Jump location for USR command. 

--- INTERNAL
      
$18,$19 Tokenising pointer. 
$1A—$1C Jump location to print 'Ready'. 

$C3—$C5 Jump location to evaluate numeric functions. $C5 also used as a 
temporary store of the rounding byte for mathematical operations. 

$E2—$F2 Routine to step through program to find next non space char. See 
$EC9C of disassembly. 

$20B Not used but gets written over by routine that sets $208 - $20A. 

$238-$23A Jump to PRINT CHARACTER on screen (V1.1).
$24D Tape speed, 0 - fast, 1 - slow (Vl.l). 

$261,$262 Indirect jump for CTRL character routine.
$263,$264 Temporary storage. 
$276,$277 Spare counter — also used by WAIT (and printer in V1.0). 
*/

  example_TIMER =`
9 REM *** PRINTS THE CURRENT TIMER IN HECTOSECONDS
10 LET D=DEEK(630)
20 PRINT D
30 STOP
`;

  HELP.related.push('PEEK POKE DEEK DOKE SCRN'); {
    // LOCAL VARS USED FOR PEEK/DEEK etc 

    const SCREEN = 0x0BB80;
    const SCREEN_LEN = SCREEN_ROWS * SCREEN_COLS;
    //const SCREEN_LEN = 1120;
    const CHARS = 0xB400;
    const CHARS_LEN = 1024;
    const ALTS = 0xB800;
    const ALTS_LEN = 896;

    const HIRES = 0xA000;
    const HIRES_LEN = 8000;
    const HIRES_TEXT = 0xBF68;
    const HIRES_TEXT_LEN = 120;

    // TODO: charset moves?
    const HIRES_CHARS = 0x9800;
    const HIRES_CHARS_LEN = 1024;
    const HIRES_ALTS = 0x9C00;
    const HIRES_ALTS_LEN = 1024;    
    
    function PEEK(a, v) { // LOL
      tPos(a);
      print(`PEEK ${a} ${v} ${HEX$(a)}`);

      if (a === 0x276) return DEEK(0x276) % 256;
      if (a === 0x277) return INT(DEEK(0x276) / 256);

      // DOC: Read memory byte at ADDR
      // Simulator: only screen memory value!
      if (SCREEN.hires)
	error('?PEEK/POKE not defined for HIRES mode');
	
      if (a >= SCREEN &&
	  a <= SCREEN + SCREEN_LEN) {
	let o = a - SCREEN;
	print(`PEEK in screen o = ${o}`);
	// TODO: this may overlap! LOL
	let row = INT(o / SCREEN_COLS);
	print(`PEEK in screen row = ${row}`);
	let col = o % SCREEN_COLS;
	print(`PEEK: row=${row} col=${col}`);
	let x = screen(row, col, v);
	print(`PEEK: => ${x}`);
	return  x;
      }

      // easter egg!
      return PEEK(
	(a % SCREEN_LEN) + SCREEN, v);

      error('?PEEK/POKE not defined for this address');
    }
    function POKE(a, v) {
      tPos(a); tPos(v, v < 256);

      if (a === 0x276) return deek276 = (deek276 & 0xff00) + v;
      if (a === 0x276) return deek276 = (deek276 & 0x00ff) + v*256;
      // DOC: Set memory ADDR byte to VAL
      // Simulator: only screen access!
      PEEK(a, v); // LOL
    }

    let deek276 = 0;
    function DEEK(a, v) {
      tPos(a);
      // timer hs (10ms)
      if (a === 0x276) {
	// reset?
	if (typeof v === 'number')
	  doke276 = v;
	return 0x10000 - INT(
	  Date.now()/10 - deek276)
	  % 0x10000;
      }
      
      return 256*PEEK(a+1) + PEEK(a);
    }

    function DOKE(a, v) {
      tPos(a); tPos(v, v < 655356);
      if (a === 0x276) return DEEK(a, v);
      POKE(a, v % 256);
      POKE(a+1, INT(v / 256));
    }
  }
  
  /* (ASCII A) which is (in decimal) 46600. Try the following program which POKES new values into these locations and then PRINTS an A. The A should appear as an italic A because we have now redefined the way Orie draws an A. Try switching to HIRES mode and use CHAR to place an A on the screen to prove that the characters have been copied down correctly.*/
  
  // jsk: Just got an IDEA!
  // 1. whenever poked in letter 'X'
  //    (chardef area)
  //    - record it
  // 2. when "done" (subjective)
  //    - creata an svg put in
  //      SPRITE[hex(chardef)] = svg
  //      CHAR2SPRITE['X'] = hex(chardef)
  // 3. in screen replace every 'X'
  //
  // gif: will work
  // svg symbol: can they be redefined?

  example_CHARDEF = `
10 FOR A=0 TO 7 
20 READ B 
30 POKE 46600+A,B 
40 NEXT 
50 DATA 14,17, 17,17,62,34,34,0 
`;

  function NEW() {
    stop(true);
    lines = {};
  }
  
  // TODO: load basic from any URL!
  // CLOAD "filename" [,S] 
  // CLOAD "" [,S] - search/list
  // CLOAD "filename", J [,S] - join! 
  // CLOAD "filename", V [,S] - verify
  function CLOAD(name, info) {
    // DOC: Loads a file "NAME"
    // New: Without arguments lists examples
    // New: With 'CLOAD D' shows names with 'D'
    if (!name) name = '';
    
    let origline = this;
    function load(src) {
      if (!src) return;
      NEW();
      let name = beautyname(names[0]);
      print('Program ' + name + ' loading...');
      let n = 0;
      ('\n'+src).replace(
	/\n\s*(\d+)(.*)/g,
	(_, lno, l)=>{
	  saveline(+lno, l);
	  if (trace) { princ(+lno); print(l); }
	  n++;
	});
      princ(n); print('lines loaded');
      if (origline.match(/,\s*AUTO/)) RUN();
      return true;
    }
    
    // get names from window
    let names = Object.keys(window)
	.filter(n=>n.startsWith('example'));
    // add names from localstorage
    names = names.concat(lssearch('CSAVE:'));

    // filter matches
    if (name) {
      if (name.match(/^".*"/))
	names = names.filter(
	  n=>n.match(RegExp(
	    `^CSAVE:${name.replace(/"/g,'')}\$`)));
      else
	names = names.filter(n=>n.match(name));
    }

    // names are now "ugly" use this to show
    function beautyname(n) {
      return n
	.replace(/^example_+/, '')
	.replace(/^CSAVE:(.*)/, '"$1"');
    }
      
    // to load (instead of list, require match  to be proper prefix)
    if (trace) { print("NAMES:"); print(names); }
    
    if (names.length == 1
	&& names[0].match(RegExp(`^(?:example_*|CSAVE:)${name}`))) {
      let src;
      
      // try load from examplesNAME...
      src = window[names[0]];
      if (src) {
	// ok, it's not a string?
	if (typeof src === 'function') try {
	  src = src();
	} catch(e) {}
      }

      // try localStorage
      if (!src)
	src = lsget(names[0]);

      if (load(src)) return;
    }

    // all else (and no return is:)
    if (name)
      print('?CLOAD NAME ERRROR');

    // list'em
    print("Matching names:");
    print();
    names
      .map(beautyname)
      .forEach(n=>(princ(n), TAB("3")));
    print();
  }
  
  // For the HIRES screen: 
  // CSAVE"filename" ,A40960,E48000 ( 48K Orie)
  // CSAVE"filename" ,A8192,EIS232 (16K Orie)
  // For the TEXT and LORES screens: 
  // CSAVE"filename" ,A48000,E49119 ( 48K Orie)
  // CSA VE"filename" ,Al5232,El635 l (16K Oriek) 
  // The start Address and End address will accept either decim
  function CSAVE(name, opt) {
    // DOC: Save program lines
    // foo - in localStorage
    // TODO: Implement AUTO
    // TODO: "foo.tap" - download
    // TOOD: load/save memory (screens)
    if (!name) name = '';
    if (opt) return save_error('USING '+opt);
    name = name.replace(/"/g, '');
    if (name.match(/^\w+/)) {
      let src = Object.keys(lines)
	  .map(lno=>`${lno} ${lines[lno]}\n`)
	  .join('');
      let lns = src.match(/\n/g).length;
      if (trace) print(src);
      lsput('CSAVE:' + name, src);
      princ(lns); 
      print('lines saved in ' + name);
    } else {
      save_error('BAD NAME: '+name);
    }
  }

  function STORE() {}
  function RECALL() {}
  
  function example_TAB() {
    return `
10 FOR 1=0 TO 5 
20 PRINT TAB(I); "HELLO" 
30 NEXT I 
HELLO 
HELLO 
 HELLO 
  HELLO 
   HELLO 
    HELLO
`;
  }
  
  // sounds
  // https://bulba.untergrund.net/emulator_e.htm
  // The PLAY command allows you to mix tones and gives access to eight preset envelope shapes.
  // After using MUSIC and SOUND to set channel and select the tones and noise you want, you use PLAY to mix the channels, select an envelope and control the duration of the final sound. In this way, quite complex sounds can be built up even considering the limitations of the single voice and the pre-set envelopes. The three main sound commands can be used in programs written in
  /* 
PLAY BASIC Token: 169
Format: PLAY t, s, e, d

t=tone channel 0-7 (bit value 111)
s=sound channel 0-7 (bit value 111)
e=envelope 0-7
d=duration 0-32767

This is one of the Oric's rather complex sound commands which, once you get used to them, offer a music/sound potential well in advance of the machine's competitors. However, the commands are a little difficult to grasp, particularly if you're not musically minded, so it is well worth spending some time working your way through Chapter 7. For the present we will restrict ourselves to clarifying the format of the command. 
Your Orie is endowed with three sound/tone channels and PLAY is the command which determines the combination of these channels. In terms of the command format at the top of the page, t (tone) ands (sound) determine which channels are activated (0--7). The effects of the combination of channels is really only comprehensible· after a little experimentation, but the following chart will be of some use for future reference.

The column on the left represents the value oft or s, whilst the righthand column tells you which combination of channels are activated by this value. 

channel combination
0 no channels I
1 2 2 3 1and2 4 3 s 1and3 6 2and3 7 1, 2 and 3 


*/
  example_CHORD = `
90 REM*** CHORD *** 
99 PLAY 7,0,0,0 
100 MUSIC 1,4,1,5 
110 MUSIC 2,4,5,5 
120 MUSIC3,4,8,S 
140 STOP
`;
  
  example_ANDROID = `
5 REM *** ANDROIDS *** 
10 A=l 
50 REPEAT 
60 LET A=A+l 
90 READ X,Y 
100 PLAY 3,0,0,0 
110 MUSIC 1,1,X,6 
120 MUSIC 2,4,Y,5 
140 WA1T 15 
150 UNTIL A=193 
160 RESTORE
170 GOT0 10 
1000 DATAl, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8,8, 1,8,8,8, 1,8,8,8,3,6, 10,5,3,3, 10,3 
1010 DATA 1, 10, 8, 10, 1, 10, 8 , 10, 1, 8, 8, 8, 1 ,8,8,8,1,8,8,8,1,8,8,8 
1020 DATA 3,3, 10,5,3,6, 10,6, 1, 10,8, 10, 1 ,10,s,10
1030 DATA 1,8,8,8,1,8,8,8,1,8,8,8,1,8,8,8,3,3, 10,5,3,3, 10,3 
1040 DATA 1,1,8,1,·1,1,8,l,l,l,8,l,l,l,8 , 1, 1, 1,8, 1, 1, 1,8, 1, 1, 1,8, 1, 1, 1,8, 1 
1050 DATAl,8,8,8, 1,8,8,8, 1,8,8,8, 1,8,8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 3, 6, 10, 5, 3, 3, 10, 3 
1060 DATA 1, 10, 8, 10, 1, 10, 8, 10, 1, 8, 8, 8, 1 ,8,8,8, 1,8,8,8, 1,8,8,8 
1070 DATA 3, 3, 10, 5, 3, 6, 10, 6, 1, 10, 8, 10, 1 ,10,8,10 
1080 DATA 1,8,8,8,1,8,8,8,l,8,8,8,l,8,8 
,8,3,3, 10,5,3,3, 10,3 
1085 DATA 1,1,8,l,1,l,8,l,l,l,8,l,l,l,8,1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 8, 1 
1090 DATA 3, 3, 10, 3, 3, 3, 10, 3, 5, 5, 12, 5,5,5,12,5 
2000 DATA 6,6,1,6,6,6,1,6,1,l,8,1,1,l,8,1 
2010 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2020 DATA 6,6,1,6,6,6,1,6,1,1,8,1,1,1,8,1 
2030 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2040 DATA 6,6,1,6,6,6,1,6,1,1,8,1,1,1,8,l 
2050 DATA 3,3,10,3,3,3,10,3,5,5,12,5,5,5,12,5 
2060 DATA 6,6,1,6,6,6,1,6,8,8,~,8,8,8,3,8
`;
  function PLAY(channels, noise, envelope, duration) {
    // DOC: "shape" of the sound:
    // CHANNELS 0-7 : 1 (1st) + 2 (2nd) + 4 (3rd)
    // ENVELOPE 0--7 shape, see below
    // DURATION 0--32767
    // _ banjo  : env 1, dur 1000
    // _ machine: env 6, dur 19
    
    // Tip: PLAY 0,0,0,0 'OFF
    // Note: MUSIC C,3,4,0 '0 = Use envelope
    // Envelopes (firist shape same length)
    // 1 |\             "slow-die"
    // 2 /|             "slow-start"
    // 3 |\    |\|\ ... "saw"
    // 4 /\    /\/\ ... "sine"
    // 5 |\|~  ~~~~ ... 
    // 6 /|    /|/| ... "saw"
    // 7 /     ~~~~ ... "slow-start"
    
    // TODO: noise! channels > 
    // channels noise envelope duration

    // PLAY 0,... ' all off
    if (!channels)
      return sounds('0v0 1v0 2v0 3v0');

    let c = 1;
    for (let b=1; b<8; b*=2) {
      let e = channels & b;
      PLAY['con'+c] = e;

      // If enabled start saved stuff
      if (e) 
	sounds(PLAY['c'+c] || '');
      else
	sounds(`${c} v0`);
      i++;
    }
  }

  example_PLAY = `
l REM ***PLAY***
5 CLS
10 CLS:PRINT:PRJNT
20 INPLUT"ENTER NUMBER (0-7) FDR SOUND SHAPE"; E
30 IF E<0 DR E>7 THEN 20
40 INPUT "ENTER A NUMBER (0-65535) FOR DURATION"; O
50 PRINT "THIS IS SOUND ENVELOPE "; E; " WITH A "; O; " DURATION"
60 SOUND 1, 1500, 0
70 PLAY l, 0, E, D
80 PRJNT "PRESS ANY KEY TO STOP PLAY"
90 GET A$: GOT0 5
`;

  // on Xiaomi A4 note+ it plays 3s
  // original oric about 6s
  example_CHROMANG = `
10 REM CHROMATIC (WITHOUT FOR)
20 LET I=0
25 PLAY 1,0,0,0
30 LET O=INT(I/12)
35 IF O-6 THEN 40 ELSE GOTO 100
40 LET N=INT(I-O*12)+1
45 MUSIC 1,O,N,2
50 PRINT O, N
60 LET I=I+1
70 GOTO 30
100 PLAY 0,0,0,0
  `;
  
  example_CHROMATIC = `
l REM *** CHROMATIC SCALE *** 
5 CLS 
10 PAPER 5 
20 FOR 0=0 TO 6 
30 FOR N=l TO 12 
40 MUSIC 1,0,N,10 
50 WAIT 30 
60 NEXT N 
70 NEXT 0 
75 END 
`;

  example_KEYBOARD =`
10 REM *** KEYBOARD ***
11 PRINT "0 1 2 .. - = /"
20 GET A$
30 A=VAL(A$)
40 IF A$="- " THEN A=11
50 IF A$="=" THEN A=12
60 IF A$="/" THEN PLAY 0,0,0,0: STOP
70 IF A=0 THEN A=10
80 MUSIC 1, 3, A, 8
85 WAIT 20: PLAY 0,0,0,0
90 GOTO 20 
`;
  
  HELP.related.push('SOUND MUSIC PLAY');
  
  function MUSIC(c, o, n, v) {
    // DOC:Make music using:
    // CHANNEL 1--3
    // OCTAVE 0--7
    // NOTE 1--12 see below
    // VOLUME 0--15
    // Imagine a piano keyboard:
    // _   2   4       7  9   11
    // | |C# |D# | | |F# |G# |A# | |
    // | |   |   | | |   |   |   | |
    // | \-------/ | \-----------/ |
    // |   |   |   |   |   |   |   |
    // | C | D | E | F | G | A | H |
    // \---------------------------/
    // _ 1   3   5   6   8  10  12
    tPos(c, c < 1 || c > 3);
    tPos(o, o > 6);
    tPos(o, n < 1 || n > 12);
    tPos(v, v > 15);
    v = INT(100 * v / 15) / 100;
    // we need to save it for PLAY
    let seq = PLAY['c'+c] =
	`${c} o${o} n${n} v${v}`
    // only play if channel enabled with PLAY
    if (PLAY['con'+c]) sounds(seq);
  }

  example_WAVES = `
l80 REM*** WAUES *** 
181 REM page 106
200 PLAY 0, 1.•0,0 
205 Z=NT(RND(1)*20)
210 FOR I=0 TO 31
220 SOUND 4,I,7 
230 WAIT Z
240 NEXT I 
250 GOT0 205
`;
  
  function SOUND(c, p, v) {
    // DOC: Make pitch (X/freq) and noise
    // CHAN:1--3 + 4 (noise!)
    // PITCH: 0--65536 X/freq
    tPos(c, c > 7);
    tPos(p, p < 65536);
    tPos(v, v > 15);
    if (c > 3)
      implemented_error("SOUND: doesn't support noise yet!");
    v = INT(100 * v / 15) / 100;
    const MAGIC = 30800;
    let f = INT(MAGIC / p);

    // we need to save it for PLAY
    let seq = PLAY['c'+c] =
	`${chan} v${vol} f${f}`;
    // only play if channel enabled with PLAY
    if (PLAY['con'+c]) sounds(seq);
  }

  HELP.related.push('PING ZAP EXPLODE SHOOT SOUND');

  function ZAP() {
    sounds('[oric_zap]');
    // TODO: wait as long as it takess to
    // play like he original..
  }
  function PING() {
    sounds('[oric_ping]');
    // thisone doessn't block
  }
  function SHOOT() {} // "snare-drum"
  function EXPLODE() {}


</script>

<script>
  function rand(n) {
    return Math.floor(Math.random()*n);
  }
  
  TEXT();
  CLS();

  boot(); //run('boot'); prints prommpt
  prompt();

/*
var svgns = "http://www.w3.org/2000/svg";
for (var x = 0; x < 5000; x += 50) {
    for (var y = 0; y < 3000; y += 50) {
        var rect = document.createElementNS(svgns, 'rect');
        rect.setAttributeNS(null, 'x', x);
        rect.setAttributeNS(null, 'y', y);
        rect.setAttributeNS(null, 'height', '50');
        rect.setAttributeNS(null, 'width', '50');
        rect.setAttributeNS(null, 'fill', '#'+Math.round(0xffffff * Math.random()).toString(16));
        document.getElementById('svgOne').appendChild(rect);
    }
}

  */

  // TODO: remove svg experiments!
  if (0) {
  screen(
    1,5,'A', charA=`
<div style='top:1.55px; position:absolute; max-width:10px; max-height:142px; overflow:visible; zoom:1;'>
<svg viewBox="0 0 6 8" xmlns="http://www.w3.org/2000/svg" style='background:white'
xmax-width:10px; xmax-height:10px;'
width='10px' height='12px'>
  <use xlink:href='#A'>
</svg>
<div>
`);
  screen(1,2,'A', charA);
  screen(2,2,'A', charA); screen(2,3,'A', charA)
  screen(3,2,'A', charA);
  }  
  // js: create rect
  // - https://stackoverflow.com/questions/32985564/how-to-style-manipulate-contents-of-svg-use-element
  
  if (0)  window.onerror = function(message, url, line, col, errorObj) {
    dom('error', `WINDOW.ERROR:
message  : ${message}
url      : ${url}
line     : ${line}
col      : ${col}
errorObj : ${errorObj}
`);
  }

  let lastrun = 0;
  setInterval(_=>{
    dom('line', line);
    dom('row', row);
    dom('col', col);
    dom('vars', JSON.stringify(vars));
    
    dom('stats', 'Statements: '+run.count+
	' sps= ' + Math.floor(1000*(run.count-lastrun)/(cont.millis)) +
	' scoff= ' + scoff);
    lastrun = run.count;
    
  }, 100);
  // clear initial error
  dom('error', '');
  
  function clickSound(special) {
    editChar.n = ((editChar.n || 0) + 1)%20;
    let named = special ?
	'[oric_okey]' : '[oric_key]';
    if (click) {
      sounds('' + (editChar.n+3) + named);
      // compatible keysound, turn off vol of 1
      sounds('1v0');
    }
  }

  function editChar(ch) {
    clickSound();
    cursorHide();
    let c = String.fromCharCode(ch);
    // ignore keyboard setting
    if (caps)
      c = c.toUpperCase();
    else
      c = c.toLowerCase();
    line += c;
    putc(c.charCodeAt(0)); // lol

    cursorShow();
  }    

  function editEnter() {
    cursorHide(); // turned on by run/stop
    print();
    // TODO: right place? lol
    // (we hide it in case of error)
    dom('exp').value = line;
    
    run(line);
    line = '';
  }

  // basically make other arguments splittable
  function quoteStrings(line) {
    return line.replace(
      /\".?\"/g,
      s=>s.replace(/!/g, '!!')
	.replace(/ /g, '!s!')
	.replace(/'/g, '!q!')
	.replace(/:/g, '!c!')
      	.replace(/\(/g, '!po!')
        .replace(/=/g, '!e!')
        .replace(/,/g, '!com!')
    );
  }
  function unquoteStrings(line) {
    return line.replace(
      s=>s.replace(/!c!/g, ':')
	.replace(/!s!/g, ' ')
      	.replace(/!po!/g, '(')
        .replace(/!pc!/g, ')')
        .replace(/!e!/g, '=')
        .replace(/!q!)/g, "'")
        .replace(/!com!)/g, ',')
	.replace(/!!/g, '!'));
  }

  function prompt(noprompt) {
    if (!noprompt) {
      // why was added? because break?
      //if (col > 2)
      print();
      print('Ready');
    }
    cursorShow();
  }

  // reads from line variable
  function nextExp(line) {
    let r;
    r = tokenizer(line, ORIC_TOKENZ);
    if (trace) {
      print('======== TOKENS =========');
      print(JSON.stringify(r));
    }
    if (0)
    while(line) {
      //r = parseExp(line, ORIC_TOKENZ);
      
      if (trace) {
	print();
	princ('-------------TOKEN:');
	print(JSON.stringify(r));
	princ('x.RES ');
	print(JSON.stringify(r.res));
	princ('x.REV ');
	print(JSON.stringify(r.rev));
	princ('x.TOK ');
	print(JSON.stringify(r.tok));
      }
      line = r[1];
    }
    return;
  }

  // interprets and runs one line
  // returns true if ok
  // END return false
  function run(line) {
    nextExp(line);
    
    line = line.trim();

    // remove leading ':' (used for indent!)
    line = line.replace(/^[\s:]*/, '');

    // TODO: remove ll cursorShow from here...
    
    // fast comments
    // TODO: inncorrect REM is a statement...
    //   PRINT 33 : REM foo
    //   PRINT 33 ' foo
    if (line.match(/^(REM|')/))
      return (cursorShow(), 'REM');
	
    if (!line || line === '')
      return (cursorShow(), '');

    // NN PRINT ... new line?
    // New: retains initial spacing! lola
    let linedef = line.match(/^\s*(\d+)(.*)$/);
    if (linedef) {
      saveline(+linedef[1], linedef[2]);
      return (cursorShow(), 'EDIT');
    }

    line = line.trim();
    let orig = line;

    // ok, we have command  to execute
    line = quoteStrings(line);

    // TODO: incorrect as F!
    // if (1) THEN ?3:?4 ELSE ?5 : ?6 : ?7
    //   ORIC => 3 4 6 7
    if (trace) print('LINE: ' + line);
    if (0) {
      let many = line.split(':');
      if (trace) print('MANY: ' + many.length);
      // TODO: incorrect, and can't CTRL-C!
      if (many.length > 1) {
	let r= many.map(unquoteStrings)
	    .some(x=>!run_h(x));
	return r;
      }
    }

    let cmd = run_h(line, orig);
    
    // if it's not running in background
    if (!running()) prompt(cmd === 'EDIT');
    return true;
  }
  // internal: takes quotedStrings param
  function run_h(line, orig) {
    run.count++

    // rough parameter extraction
    let a = line.split(/[\s;=\(\),]+\s*/g);
    if (trace) print('------' + a.join(' | '));
    a = a.map(unquoteStrings);
    if (trace) print('------' + a.join(' | '));

    // hehe - crap!
    if (!orig.match(/^(LPRINT|PRINT|LET|INPUT|FOR|HELP|DIM|CLOAD|CSAVE|REM|IF|REPEAT|WHILE|UNTIL|NEXT|GET)/)) {
      if (trace) print('---EVAL---' + a.join(' | '));
      a = a.map((x,i)=>!i?x:EVAL(x));
    }

    // make numbers great again
    a = a.map(x=>(+x==x?+x:x));
    if (trace) print('--num---' + a.join(' | '));

    let cmd = a.shift();

    // call function
    let f = window[cmd];
    if (trace) print('LINE: ' + line);
    if (f) {
      try {
	// TODO if f.len !+ a.length => ?SYN
	// problem is with ...args count=0
	f.apply(orig, a);
      } catch(e) {
	// TOOD: make into error?
	// simplify error handl: just throw strings!
      }
    } else {
      stop(true);
      try { syntax_error(cmd); } catch(e) {}
      return;
    }

    return  cmd;
  }
  run.count = 0;
  
  function editBackspace() {
    cursorHide();
    line = line.substring(0, line.length-1);
    putc(8);
    cursorShow();
  }
  
  function editCancel() {
    line = ''; 
    cursorHide();
    princ('\\');
    print();
    cursorShow();
  }

  function editCopy() {
    let c = screen(row, col);
    editChar(c);
  }

  let arrows = {l:37, u:38, r:39, d:40};
  function cursorMove(direction, steps=1) {
    direction = direction.toLowerCase();
    let c = arrows[direction[0]];
    while(steps--)
      editArrow(c);
  }

  function editExt(k, kc, a, s, c, e) {
    try{
    cursorHide();
    //if (!k.match(/[0-9a-z]/)) return;
    //alert(`editExt: '${k}' ${kc} ${a?'a':''} ${s?'s':''} ${c?'c':''}`);

    switch(k) {
    case 'h':
    case '/': // unsifted ? lol
    case '?': 
      clearline(0);
      PLOT(0,0,'COLOR:CTRL- ALT- 0 \21'+'1\0\22'+'2 \23'+'3\7\24'+'4 \25'+'5\0\26'+'6 \27'+'7\0');
      break;



      // fg: CTRL-# bg: ALT-#
    case (k.match(/\d/)?k:false):
      putc(ESC);
      k = kc-48 + (a?16:0);
      putc(k);
      break;
    }
    //alert('EDITEXT: '+k + ' kc='+kc);
    cursorShow();
    } catch(err){alert(
      'ERROR: ' + err +
	`\neditExt: '${k}' ${kc} ${a?'a':''} ${s?'s':''} ${c?'c':''}`);}

  }
  
  function editArrow(ch) {
    cursorHide();
    switch(ch) {
    case 37: col--; break; // left
    case 38: row--; break; // up
    case 39: col++; break; // right
    case 40: row++; break; // down
    }
    // move cursor, wrap around (?)
    // TODO: columns mode?
    if (col < 2) col = 39;
    if (col > 39) col = 2;
    if (row < 0) row = 27;
    if (row > 27) row = 0;
    cursorShow();
  }

  function clearline(r) {
    PLOT(
      0,
      typeof r==='number'?r:row,
      SPC(40));
  }

  function showStatus() {
    function update(col, status, msg) {
      if (col < 0) col += SCREEN_COLS;
      PLOT(col, 0,
	   status ? msg : SPC(msg.length));
    }

    // difficult to update if OFF!
    // (lol we update even if off :-)
    // (ctrl-o on ORIC stopps updates)
    let saved = scoff; scoff = 0;
    
    clearline(0);
    
    // CTRL-Q: toggle cursor
    update(-4, caps, 'CAPS');

    // CTRL-P: toggle printer
    update(-4 -2 -7, printer, 'PRINTER');
    
    // CTRL-S: toggle screen (centered)
    update(Math.floor(SCREEN_COLS-10)/2,
	     saved, 'SCREEN OFF');

    // TODO: column enable disable CTRL-J
    if (column) {
    } else {
    }

    // restore, no write to screen
    scoff = saved;
  }
  
  dom('exp').addEventListener('keydown', function(e) {
    let c=e.ctrlKey,a=e.altKey,s=e.shiftKey;
    let k = e.key.toLowerCase();
    let ch = e.code;
    let kc = e.keyCode;

    if ((c && !a && !s && k !== 'control')
	|| kc==13 || kc==8
	|| (37<=kc && kc<=40))
      clickSound(true);

    // editing
    if (kc==13) editEnter();
    if (kc==8) editBackspace();
    if (37<=kc && kc<=40) editArrow(kc);
    
    // my extensions
    if ((c || a) && k.length==1)
      editExt(k, kc, a, s, c, e);
    if (c && k=='r') window.location.reload();
    if (c && a && k=='p') trace = !trace;

    // ALT-
    if (a) {
      

      return;
    }
    // WARNING: NO ALT (below here)
    
    // CTRL-
    if (!c) return;
    
    if (c && k=='h') editBackspace();
    if (c && k=='c') STOP();
    if (c && k=='x') editCancel();
    if (c && k=='l') {
      cursorHide();
      CLS();
      cursorShow();
    }
    if (k=='a') editCopy();
    if (k=='f') click = !click;
    if (k=='q') cursorToggle();
    if (k=='p') showStatus(printerToggle());
    if (k=='t') showStatus(caps = !caps);
    if (k=='s') showStatus(scoff=scoff?0:1);
    if (k=='f') clickToggle();
    if (k=='d') doubleToggle();
    if (k=='g') bell();

    if (k=='j') showStatus(column = !column);

    //if (c) e.preventDefault();
  })

  dom('exp').addEventListener('keypress', function(e) {
    let c = e.ctrlKey, k = e.key; s = e.shiftKey;
    let legc = e.charCode, legk = e.keyCode;
    let ch = e.code;
    //    if (legk > 16) 
    //    alert(`k=${k} legc=${legc} legk=${legk} ch=${ch}`);
    // TODO: use e.code - but it's crap
    // and don't reflect shift
    if (e.keyCode==13) return;
    editChar(legc) // , e.getModifierState("CapsLock"));
    // hmmm, doesn't work?
    //if (c) e.preventDefault();
  });

  // TODO: this shouldn't be needed,
  // but setting background-color changes
  // layout!
  PAPER(7);
  INK(0);

  if (0) window.onerror = function(e) {
    dom('error', ''+e);
  };
  
  if (0) {
    screen(10, 10, 77);
    screen(12, 12, 3);
    screen(14, 14, 16+5);
    PAPER(7);
    INK(5);
  }
  
  if (0)
    setInterval(_=>{
      for(let i=0; i<100; i++)
	screen(
	  rand(SCREEN_ROWS),
	  rand(SCREEN_COLS),
	  rand(256));
      PAPER(rand(8));
      INK(rand(8));
    }, 0);


  // ORIC BASIC KEYWORDS
  // https://www.defence-force.org/computing/oric/coding/annexe_1/index.htm

  // Note: STR$ indicates a value of 334 for the token. It seems to be
  // hard to put in a byte !
  // NAME	CODE	TYPE
  function OricKeywords(cb) {
    `
ABS	216	
function
AND	209	
operator
ASC	236	
function
ATN	229	
function
AUTO	199	
parameter
CALL	191	
instruction
CHR$	237	
function
CIRCLE	173	
instruction
CLEAR	189	
instruction
CLOAD	182	
instruction
CLS	148	
instruction
CONT	187	
instruction
COS	226	
function
CSAVE	183	
instruction
CURMOV	171	
instruction
CURSET	170	
instruction
DATA	145	
instruction
DEEK	231	
function
DEF	184	
instruction
DIM	147	
instruction
DOKE	138	
instruction
DRAW	172	
instruction
EDIT	129	
instruction
ELSE	200	
instruction
END	128	
instruction
EXP	225	
function
EXPLODE	164	
instruction
FALSE	240	
constant
FILL	175	
instruction
FN	196	
function
FOR	141	
instruction
FRE	218	
function
GET	190	
function
GO	247
instruction
GOSUB	155	
instruction
GOTO	151	
instruction
GRAB	159	
instruction
HEX$	220	
function
HIMEM	158	
instruction
HIRES	162	
instruction
IF	153	
instruction
INK	178	
instruction
INPUT	146	
instruction
INT	215	
function
KEY$	241	
function
LEFT$	244	
function
LEN	233	
function
LET	150	
instruction
LIST	188	
instruction
LLIST	142	
instruction
LN	224	
function
LOG	232	
function
LORES	137	
instruction
LPRINT	143	
instruction
MID$	146	
function
MUSIC	168	
instruction
NEW	193	
instruction
NEXT	144	
instruction
NOT	202	
operator
ON	180	
instruction
OR	210	
operator
PAPER	177	
instruction
PATTERN	174	
instruction
PEEK	230	
function
PI	238	
constant
PING	166	
instruction
PLAY	169	
instruction
PLOT	135	
instruction
POINT	243	
function
POKE	185	
instruction
POP	134	
instruction
POS	219	
function
PRINT	186	
instruction
PULL	136	
instruction
READ	149	
instruction
RECALL	131	
instruction
RELEASE	160	
instruction
REM	157	
instruction
REPEAT	139	
instruction
RESTORE	154	
instruction
RETURN	156	
instruction
RIGHT$	245	
function
RND	223	
function
RUN	152	
instruction
SCRN	242	
function
SGN	214	
function
SHOOT	163	
instruction
SIN	227	
function
SOUND	167	
instruction
SPC	197	
function
SQR	222	
function
STEP	203	
instruction
STOP	179	
instruction
STORE	130	
instruction
STR$	334	
function
TAB	194	
function
TAN	228	
function
TEXT	161	
instruction
THEN	201	
instruction
TO	195	
instruction
TROFF	133	
instruction
TRON	132	
instruction
TRUE	239	
constant
UNTIL	140	
instruction
USR	217	
function
VAL	235	
function
WAIT	181	
instruction
ZAP	165	
instruction
`.replace(/(\S+)\t(\d+)\t\n(\S+)/g,
	  (_, word, code, what)=>
	  cb(word, code, what));
  }

  OricKeywords.name2code = {};
  OricKeywords.code2name = {};
  OricKeywords.type = {};

  OricKeywords.defined = [];
  OricKeywords.status = {};
  OricKeywords.missing = [];
  OricKeywords.innovated = [];
  
  OricKeywords((name, code, type)=>{
    OricKeywords.name2code[name] = code;
    OricKeywords.code2name[code] = name;
    OricKeywords.type[name] = type;
    OricKeywords.type[code] = type;
  });

  // deduce shit
  OricKeywords.missing = new Set();
  for(let k in OricKeywords.name2code) {
    OricKeywords.missing.add(k);
    // assume mssing till removed
    OricKeywords.status[k] = 'missing';
  }
  for(let k in window) {
    // Oric functions are all uppercase!
    
    if (k.toUpperCase() == k) {
      OricKeywords.missing.delete(k);
      OricKeywords.status[k] = 'window';
      
      OricKeywords.defined.push(k);

      let s = '';
      let f = window[k];
      if (typeof f === 'function')
	s += 'function';
      else
	s += 'const?';
      //if !f) continue; // || !f.toString) continue;
      if (typeof f == 'function') {
	f = f.toString();
	f = f.replace(/^function \w+/);
	if (f.length < 20) s += ',named,dummy';
	if (f.match(/implemented/)) s += ',not implemented';
	if (f.match(/(if|while|return|for|=)/)) s += ',DEFINED';
	if (f.match(/native code/)) s += ',native';
      }

      // NEW?
      if (OricKeywords.name2code[k])
	OricKeywords.missing.delete(k);
      else {
	s += ',NEW';
	OricKeywords.innovated.push(k);
      }

      if (s == '') s = 'UNKNOWN';
      
      dom('info', `== ${k} - - ${s}`, 'a');
      OricKeywords.status[k] = s;
    } else{
      //dom('info', `!! ${k}`, 'a');
    }
  }
  // make array out of set!
  OricKeywords.missing = [...OricKeywords.missing];

  dom('info',
      'INNOVATED - '+OricKeywords.innovated.join('\nINNOVATED - '),
      'a');
  dom('info',
      'MISSING - '+OricKeywords.missing.join('\nMISSING - '),
      'a');
  dom('info',
      Object.keys(OricKeywords.status).map(
	k=>`STATUS - - ${k} - - ${OricKeywords.status[k]}\n`).join(''),
      'a');

  function OKK(s) {
    return Object.keys(OricKeywords.status)
      .filter(
	k=>!!OricKeywords.status[k].match(s));
  }
  function OKC(s) {
    return OKK(s).length;
  }
  dom('info',
      '\nORIC ATMOS BASIC SIMULATOR STATUS'+
      '\n================================='+
      '\nMissing: '+OricKeywords.missing.length+
      '\nDefined: '+OKC(/defined/i)+
      '\nNative: '+OKC('native')+
      '\nNamed: '+OKC('named')+
      '\nNotImpl: '+OKC('impl')+
      '\nInnovated: '+OricKeywords.innovated.length+
      '\n----------------',
      'p');

  // create the missing funcs to throw error
  OricKeywords.missing.forEach(
    n=>window[n]=()=>implemented_error(n));

  // remove non-basic names... not extensions
  'DBG,OKK,OKC,TEMPORARY,PERSISTENT,EVAL,HTML,STORE'.split(',').map(
    n=>{
      delete OricKeywords.status[n];
    });

  // TODO: move? maybe move symbols out to oric-exp?
  var ORIC_TOKENZ = ',' +
      Object.keys(OricKeywords.name2code).join(',') + ',';

</script>

<!--
<!--



l REM***MUSIC***
10 FOR 0=0 T0 6
20 FOR N=l T0 12
30 MUSIC l,O,N,10
40 PLAY 3,0,7,0
50 WAIT 30 
60 NEXT N
70 NEXT O
80 PLAY 0,0,0,0
90 EXPLODE

  -->

<script>
</script>

<script>
  // place this at end to log runtime errors at end!
  // this will catch any runtime errors
  // syntax errors excluded (see above)
  window.onerror = (...args)=>{
    let t = args.toString();
    // let t = ''+args[0];
    let b = document.body;
    t = `<div style='color:red;background:white;'>E:${t}</div>`;
    b.insertAdjacentHTML('afterend', t);
    return false;
  };
</script>

</body>

</html>

