<html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>

<script>
  // -- Simplified testing of types and values
  function tType(t, x, err) {
    if (x === undefined) syntax_error();
    if (typeof x !== t) type_error();
    if (err) quantity_error();
    // okay
  }
  function tStr(s, err) {
    tType('string', s, err);
  }
  function tNum(n, err) {
    tType('number', n, err);
  }
  function tPos(n, err) {
    tNum(n, err || n < 0);
  }

  function error(msg, data) {
    print();
    princ(msg);
    if (data) { putc(32); princ(data); }
    if (lineno) { princ(' IN LINE'); princ(lineno); }

    stop(true);
    throw msg;
  }

  // NEW?
  function save_error(info) {
    error("?CAN'T SAVE", info);
  }

  function syntax_error(cmd) {
    error('?SYNTAX ERROR: ', cmd);
  }

  // NEW
  function implemented_error(s) {
    error('?NOT IMPLEMENTED ERROR:', s);
  }
  
  // NEW?
  function unexpected_error(s) {
    error('?UNEXPECTED ERROR:', s);
  }

  // NEW?
  function unmatched_error(e, g) {
    error('?MATCHING ERROR, expected:' + e + ' got: ' +g);
  }

  // NEW?
  function eval_error(e) {
    error('?EVAL ERROR:', e);
  }
  
  function return_error() {
    error('?RETURN WITHOUT GOSUB ERROR');
  }
  
  function cont_error() {
    error('?CAN\'T CONTINUE ERROR');
  }

  function quantity_error() {
    error('?ILLEGAL QUANTITY ERROR');
  }

  function type_error() {
    error('?TYPE MISMATCH ERROR');
  }
  
  function div_error() {
    error('?DIVISION BY ZERO ERROR');
  }
g  
</script>
  
<style>
/*default version*/
@font-face {
	font-family: 'oric-atmos';
	src: url('oric-atmos.ttf'); 
	src: 
		local('oric-atmos'),
		local('oric-atmos'),
		url('oric-atmos.ttf') 
		format('truetype');
}
@font-face {
	font-family: 'neoletters';
	src: url('neoletters.ttf'); 
	src: 
		local('neoletters'),
		local('neoletters'),
		url('neoletters.ttf') 
		format('truetype');
}
/*container element*/
span, div { font-family: 'oric-atmos', monospace; }
/*span elements inside the container div*/

  span {
      display: inline-block;
      /*height: 1px; /* haha you can try! */
  }
  
  .char {
      width: 0.30rem;
      border: 0px;
      padding-right: 0.25rem;
  }

  /* TODO: investigate!
  {
       font-size: 12px;
       letter-spacing: 0.015em;
       word-spacing: 0.001em;
  }
 */
  /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform */
  /* we can get double height! but only
     on each char; the problem is the nested
     elements - do it twice and it'll double
     again!

     TODO: I couldn't find a way to translate
     the it and 'clip-y' seems 'overflow-y: hidden isn't working...
 */
  .double {
      width: 0.30rem;
      border: 0px;
      padding-left: 0.25rem;

      //max-height: 45px;
      transform:
	  scale(1, 2)
	       /* translateY(15px); */
      ;
      overflow-x: visible;
      /* overflow-y: hidden; /* doesn't work */
  }
</style>
  
<script src='misc.js'>
</script>

</head>

<body style='background-color: black; color: white;'>
<div style='width:100%'>
  <img width='20%' src='oric-logo-black-export.svg'/>
  <div style='float:right; top:0; width:80%; text-align:center; font-decoration:bold; text-justify:inter-word; font-size:3rem;'>W E B - B A S I C
<div style='font-size:1rem;'>jsk@yesco.org</div>
  </div>
<span style='transform-origin:left; transform:scale(1.8, 1);'><b>&nbsp;&nbsp;B A S I C</b></span>
</div>

<!-- seemingly useless span, but need for getting correct width of 'screen'-->
<center><span id='foo'>
<div id='screen' style='color:black; font-size: 1.5rem; overflow:hidden; xtext-align: left; white-space:nowrap;'>
</div>
</span></center>

<script>
  window.onresize = function(){
    let s = dom('screen');
    
    let w = s.offsetWidth;
    let h = s.offsetHeight;

    let ww = window.outerWidth;
    let wh = window.innerHeight;

    s.style.zoom = Math.min(ww/w, wh/h);
  };
  // call an initial time after first render
  setTimeout(x=>window.onresize(), 1000);
</script>

<br><br>
<!-- id=exp is magical for jsconsole - it returns focus there -->
<div style='display:flex; width:100%;'>
  <input id='exp' autofocus style='flex:1; xbackground:black; color:black; border:none; width:100; float:right;'>
</div>
<!---input id="file" type="file"/-->
<script>
  // inspired by https://stackoverflow.com/questions/16495125/parsing-binary-files-in-client-side-js
  // REFERENCE:
  //  https://developer.mozilla.org/en-US/docs/Web/API/FileReader
  // readAsBinaryString
  function readFile() {
    let fileInput = dom('file');
    let fReader = new FileReader();

    fReader.onload = function(e) {
      /// <-- this contains an ArrayBuffer
      console.log(e.target.result);
    }

    // onloadend
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString
    // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer
    fileInput.onchange = function(e) {
      let file = this.files[0];
      fReader.readAsArrayBuffer(file);
    }
  }
</script>

<br>
ROW: <span id='row'></span>
COL: <span id='col'></span>
<br>
LINE: <span id='line'></span>
<br>
STATS: <span id='stats'></span>
<br>
ERROR: <span id='error' style='color:red;'></span>
<br>
VARS: <span id='vars'></span>
<br>
INFO:<br><span id='info'></span>
<br>
<br>
<script src='jsconsole.js'>
  //loadScript('jsconsole.js');
</script>
  
<script>
  // Configuration
  let TIMESLICE = 20; // run about X ms

  const COLWIDTH = 40, // ORIC: 40
	ROWHEIGHT = 28, // ORIC: 28
	
	LastOne = 'foo';
  
  

  // Global ORIC ATMOS state
  let vars = {},
      stack = [], // [ [lno, restline] ...]
      line = '',
      lineToDo = [], // queue
      lineno = 0,
      caps = true,
      click = true,
      column = false,
      scrn = true,
      trace = false, // debug tracing CTRL-P
      tron = false, // TRON/TROFF
      forceUpdate = false,
      row = 1,
      col = 2;

  const ESC = 27;

  function boot() {
    stop('noprompt');
    CLS();
    
    // init
    vars = {};
    stack = [];
    line = '';
    lineno = 0;
    lineToDo = [];
    caps = true
    click = true
    column = false
    trace = false;
    tron = false;
    forceUpdate = false,
    
    row = 1;
    col = 2;
    
    // stats
    putc.count = 0;
    putc.scrollcount = 0;

    screen.readcount = 0;
    screen.writecount = 0;

    run.count = 0;
    
    cont.intervalcount = 0;
    cont.millis = 0;

    // action
    showStatus();

    print(`
ORIC EXTENDED BASIC Vl.1
(C) 1983 TANGERINE

373188 BYTES FREE`);
  }

  // https://osdk.org/index.php?page=articles&ref=ART9.
  // From a memory point of view, TEXT mode requires 1120 bytes for display (ROWHEIGHT lines of 40 columns)
  // and 1920 bytes for storing the character set
  // 1120 bytes for the screen (from #BB80 to #BFDF)
  // 1024 bytes for the default character set (from #B400 to #B7FF)
  // 896 bytes for the secondary ("alternate") character set (from #B800 to #BB7F)
  // This makes a total of 3040 bytes.
  
  // So if the first byte of the screen (#BB80), contains the value 65 (ASCII code for the upper case A letter), we know that this block of 6x8 pixels will be filled with graphical information stored at the address #B400+(8*65).

  // TODO: define imgs for each character?
  // then we can 'poke' to change them?

  // TODO: calling twice messes something up
  function TEXT() {
    for(let row=0; row<ROWHEIGHT; row++) {
      let r = '';
      // lol, let's create one extra as the last character is kind of hidden...
      for(let col=COLWIDTH; col>=0; col--) {
	c = '&nbsp;';
	let id = `r${row}c${col}`;
	r = `<span id='a${id}'><span id='c${id}' class='char'>${c}</span>${r}</span>`;
      }
      dom('screen', r+'</br>', 'ah');
    }
    cache = {};
  }
  // mode: 0 or 1
  //function LORES(mode) {
  //throw "LORES: Not implemented!";
  //}

  // Structurally it is very similar to the TEXT mode, with 40 bytes per line, with each byte representing 6 pixels for a total of 240 pixels in width.
  // The main difference is that each line is only one pixel tall instead of 8, so there are 200 of these.
  // The actual graphical resolution is 240x200, but the screen has an additional area at the bottom containing 3 lines of TEXT mode.

  // From a memory point of view, HIRES mode is much more voracious:
  // 8000 bytes for the HIRES part of the screen (from #A000 to #BF3F)
  // 120 bytes for the TEXT part of the screen screen (from #BF68 to #BFDF)
  // 42 bytes lost between the HIRES and TEXT parts of the screen (from #BF40 to #BF67)
  // 1024 bytes for the default character set (from #9800 to #9BFF)
  // 1024 bytes for the secondary ("alternate") character set (from #9C00 to #9FFF)
  // This makes a total of 10210 bytes.

  // http://twilighte.oric.org/twinew/ula.htm
  //function HIRES() {
  //implemented_error('HIRES');
  //throw "HIRES: Not implemented!";
  //}
  
  const color = {
    black:   '#000000', 0: '#000000',
    red:     '#FF0000', 1: '#FF0000',
    green:   '#00FF00', 2: '#00FF00',
    yellow:  '#FFFF00', 3: '#FFFF00',
    blue:    '#0000FF', 4: '#0000FF',
    magnenta:'#FF00FF', 5: '#FF00FF',
    cyan:    '#00FFFF', 6: '#00FFFF',
    white:   '#FFFFFF', 7: '#FFFFFF',
  };
    
  let inverse = n=>7-n;
  
  function domc(id) {
    domc.cache = domc.cache || {};
    let d = domc.cache[id];
    if (!d) {
      d = dom(id);
      domc.cache[id];
    }
    return d;
  }
  
  function PLOT(x, y, sORn) {
    // DOC: X,Y puts a string or raw attribute
    if (typeof sORn === 'string') {
      let r = row, c = col;
      row = y; col = x;
      prin(sORn);
      row = r; col = c;
    } else {
      screen(y, x, sORn);
    }
  }
      
  function SCRN(x, y) {
    // DOC: Return char/attr at X, Y
    return screen(y, x);
  }
  
  function POS() {
    // DOC: Column position
    return col;
  }
  
  // BRAILLE
  // https://en.m.wikipedia.org/wiki/Braille_Patterns
  // bit-value:
  //  1   8
  //  2  10
  //  4  20
  // 40  80
  let BRAILLE = 2800; // REALLY!?

  // nodejs can't handle it?
  // let braille =⠀"⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟";
	 
	 
  // this is like equivalent of POKE!
  // READ   screen(row, col) => ch
  // WRITE  screen(row, col, ch)
  //   ch <  0   magical pixels
  //   ch <  8   INK
  //   ch < 16   ... blink, ALT, double
  //   ch < 24   PAPER
  //   ch > 31   ASCII
  //   ch >127   ASCII inverted!
  //   ch > 255  Unicode ...
  function screen(row, col, ch) {
    let dc = domc(`cr${row}c${col}`);
    // read screen?
    if (ch === undefined) {
      screen.readcount++;
      if (typeof dc.screenchar == 'number')
	return dc.screenchar;
      else
	return dc.screenchar = dc.textContent.charCodeAt(0);
    }
    screen.writecount++;
    dc.screenchar = ch;

    let da = domc(`ar${row}c${col}`);

    let t;

    // interpret char/attribute
    let c = ch & 0x7f;

    if (ch > 255) { // unicode! lol
      // pass through, we don't c(h)ar(e)
      t = ch;
    } else if (c >= 32) { // ascii
      // TODO: implement inverse!
      // remove high-bit as it means inverse
      t = ch & 0x7f; 
    } else if (ch < 0) { // bits...
      t =  BRAILLE - ch; // so it get's "added"
    } else if (c < 8) { // ink
      let fg = c & 0x07;
      if (c > 127) fg = inverse(fg);
      da.style.color=color[fg];
      t = 32; // blankk it out
    } else if (c < 16) {
      // Character Set modifier
      // 8  Use Standard Charset
      // 9  Use Alternate Charset
      // 10 Use Double Size Standard Charset
      // 11 Use Double Size Alternate Charset
      // 12 Use Blinking Standard Charset
      // 13 Use Blinking Alternate Charset
      // 14 Use Double Size Blinking Standard Charset
      // 15 Use Double Size Blinking Alternate Char
      let alt = c & 1;
      let double = c & 2;
      let blink = c & 4;
      // TODO: alt - complicated (edit font?)
      // https://en.fontke.com/font/10042736/
      // https://github.com/Zigazou/miedit
      // https://github.com/Zigazou/miedit/tree/master/font
      
    } else if (c < 24) { // 16-23 paper
      let bg = c & 0x07;
      if (bg > 127) bg = inverse(bg);
      da.style.backgroundColor=color[bg];
      t = 32; // blankk it out
    } else {
      // TODO: mode switching
      // idea: make screen garbled? lol
      // Video control attributes
      // 24-27 Switch to TEXT mode (60 Hz)
      // 28-31 Switch to HIRES mode (60 Hz)
    }

    if (t == 32)
      dc.innerHTML = '&nbsp;';
    else if (t !== undefined)
      dc.textContent = String.fromCharCode(t);
  }
  screen.readcount = 0;
  screen.writecount = 0;

  function INK(color) {
    // skip status line
    for(let row=1; row<ROWHEIGHT; row++) {
      screen(row, 1, color);
    }
  }
  function PAPER(color) {
    // skip status line
    for(let row=1; row<ROWHEIGHT; row++) {
      screen(row, 0, 16+color);
    }
  }

  function exmple_PAPER() {
    return `
l0 FOR I=0 TO 7 
20 INK I 
30 FOR J=0 TO 7 
40 PAPER J 
50 WAIT 50 
60 NEXT J 
70 NEXT I 
80 INK 0 
`;
  }

  function example_PRINTAT() {
    return `
10 FOR X=2 TO 30 
20 PRINT @X,10;·• WHIZZ2" 
30 NEXT X
`;
  }

  // TODO: ORIC used to have blinking cursor
  // also has 'cursor' varaible controlled by
  let cursor = true;
  let raw = false;
  function cursorToggle(wantOn) {
    if (wantOn === undefined) {
      cursor = !cursor;
    } else if (typeof wantOn === 'string') {
      cursor = (wantOn.toLowerCase() === 'on');
    } else {
      cursor = !!wantOn;
    }

    if (!cursor) cursorHide();
    // don't show cursor here as this run as soon as key presseed leaving traces
  }

  // cursorHide(),cursorShow() - don't call as it's managed by the system functions call cursorToggle() for your intent
  let cursorVisible = false;
  function cursorHide() {
    if (!cursorVisible) return;
    cursorVisible = false;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = '';
    d.style.color = '';
  }
  function cursorShow() {
    // TODO: right place? lol
    dom('exp').value = line;
    
    if (!cursor || cursorVisible) return;
    cursorVisible = true;
    let d = domc(`cr${row}c${col}`);
    // TODO: implement real inverse
    // here we don't know actual color!
    d.style.backgroundColor = 'black';
    d.style.color = 'white';
  }
  
  function putc(c) {
    if (typeof(c) !== 'number')
      alert('putc: only take nubmers: ' +  c);
    putc.count++;
    
    // TODO: how to handle inverse?
    let ch = c & 0x7f;
    if (ch === ESC) return raw = true;
      
    if (raw || ch >= 32) {
      screen(row, col, c);
      col++;
    }
    raw = false;

    if (ch == 10) { row++; col = 2; }

    // backspace
    if (ch == 8) {
      col--;
      if (col < 2) col = 2;
      // TODO: I don't think backspace wraps?
      //if (col < 2) { col = 39; row--; }
      //if (row < 1) { col = 2; row = 1; }
      screen(row, col, 32);
    }

    // TODO: should be COLWIDTH????
    if (col >= COLWIDTH) { row++; col = 2; }

    // scroll!
    if (row >= ROWHEIGHT) {
      putc.scrollcount++;
      let start = Date.now();
      for(let r=2; r<ROWHEIGHT; r++) {
	for(let c=0; c<COLWIDTH; c++) {
	  let old = screen(r-1, c);
	  let nw = screen(r,c);
	  if (nw != old)
	    screen(r-1, c, nw);
	}
      }
      // TODO: if not hidden column mode?
      row = 27;
      for(let c=2; c<COLWIDTH; c++) {
	screen(row, c, 32);
      }
      //dom('info', 'scroll time='+(Date.now()-start), 'lp');
    }
  }
  putc.count = 0;
  putc.scrollcount = 0;

  // 20LETSEL=0 => 20 LET SEL = 0
  // TODO: 63999 max
  //  
  // integer -32767 to 32768
  // A%
  // A$

  // DIM varname(exp, ...)
  // TEST:
  //  Q(9)=3
  //  Q(10)=4
  //  Q(11)=5 => ?BAD SUBSCRIPT ERROR
  //  Q(0)=77
  //  Q(-1)=44 => ?ILLEGAL QUANTITY ERROR
  
  // TODO: fix
  // TODO: maybe let an array be a function! __Arr(3,4) evaluate to the value, or if LET an LVALUE
  // TODO: how to see in an exppression it's
  // an variable and not function call?
  function DIM(n, ...dims) {
    // DOC: Dimension an multidimensional array DIM A$(1:st dim, 2:nd dim, ...)
    // All elements set to detault value.
    // ORIC: Any array index 0..10 is 'predefined'
    // New: Any index can be set once dimensioned, it's automatically extended (with nulls!)
    // Bug: Not capture index out of bounds
    // Bug: There is no diff between array varaibles and others with same name...
    // ...and so PRINT will happily print the array
    let v = 0.0;
    if (n.match(/^\w+\%/)) v = 0;
    if (n.match(/^\w+\$/)) v = '';
    
    function gen(dim, ...dims) {
      if (!dim) return v;
      return [...Array(dim)]
	.map(_=>gen(...dims));
    }
    
    vars[n] = gen(...dims);
  }

  // TEST:
  //   LET IF=2 => ?Syntax...
  //   LET THE=3 => ok
  //   LET THENN=4 => ?Syntax...
  function LET(n) {
    let v = this;
    v = v.replace(/^\s*LET\s*\S+\s*=\s*/, '');
    if (trace) print('LET: ' + v);
    let r = EVAL(v);
    if (r === undefined) return;

    if (n.endsWith('%')) r = Math.floor(r);
    if (n.endsWith('$')) r = ''+r;

    // indexing (interpolate using fixpoint!)
    let lastn = n;
    while (lastn != (n = n.replace(
      /\[([^\[\]]*)\]/g, (_,i)=>'['+EVAL(i)+']'))) {
      if (trace) print('IX: ' + n);
      lastn = n;
    }

    // set
    if (trace) print('SET: ' + n);
    let path = n.replace(/[\[\]]/g, ' ').trim()
	.split(/\s+/g);
    if (trace) print('PATH: ' + JSON.stringify(path));
    let nv = vars;
    let x;
    let lastx = path.shift();
    while ((x = path.shift()) !== undefined) {
      if (trace) print('LOOP lastx: ' + lastx);
      if (trace) print('LOOP x: ' + x);
      nv = nv[lastx];
      lastx = x;
    }
    if (trace) print('SET: ' + (nv == vars) + ' ' + lastx);
    nv[lastx] = r;
  }

  function EVAL(x) {
    try {
      if (trace) print('VARS: ' + JSON.stringify(vars));
      // pow!
      x = x.replace(/\^/g, '**');
      if (trace) print('EXP: ' + x);
      // TOOD: not correct comparisons
      // as ORIC returns 0/-1 for false/true
      if (x.match(/(<|=|>)/))
	return implemented_error('comparisons');
      let r = (function(ATMOSexp){
	// fast cheat!
	with (vars) {
	  return eval(ATMOSexp);
	}
      })(x);
      if (trace) print('-->: ' + r);
      return r;
    } catch(e) {
      console.log('?EVAL: ' + x);
      //eval_error('' + e);
      //stop();
      throw e;
    }
  }
  
  function val(n) {
    //n = n.substring(0, 2);
    return vars[n];
  }
  
  // Also CTRL-L
  function CLS() {
    let start = Date.now();
    // TODO: does it scroll colors?
    // don't touch mode-line
    for(let row=1; row<ROWHEIGHT; row++) {
      for(let col=2; col<COLWIDTH; col++) {
	screen(row, col, 32);
      }
    }
    row = 1; col = 2; raw = false;
    //dom('error', 'CLS time ' + (Date.now()-start));
  }

  // 20 INPUT"ENTER SALE PRICE";SELL
  function INPUT(prompt, v) {
  }

  function princ(txt) {
    return print(txt, 'nonewline');
  }
  function print(txt, nonewline) {
    if (txt === undefined) return putc(10);

    // for numbers ORIC makes SURE it fits
    // without line breaks!
    if (typeof txt == 'number') {
      txt = ' ' + txt + ' ';
      if (col + txt.length > COLWIDTH) // ?
	putc(10);
    } else {
      txt = '' + txt;
    }
    
    // make sure we have text
    for(let i=0; i<txt.length; i++)
      putc(txt.charCodeAt(i));
    if (!nonewline) putc(10);
  }

  function TAB(pos) {
    // DOC: Move cursor to POS
    // New: If no arg move to next column
    // New: -POS is using custom tabwidth POS
    // New: "3" means use 3 cols (=INT(-40/3))
    if (typeof pos === 'string') pos = -INT(COLWIDTH/3);
    let width = (pos < 0) ? -pos : 8;
    while ((col-2) % width !== 0)
      putc(32);
    
    // return '' as I think it's used in PRINT
    return '';
  }
  
  function HELP(cmd) {
    if (cmd) {
      // extract DOC string from function!
      let f = window[cmd];
      if (f) {
	let s = f.toString();
	if (trace) print('FUN=' + f.toString());
	s = s.match(/\/\/\s*DOC\s*:?\s*([\s\S]+)/i);
	let doc;
	if (!s) {
	  doc = '- NO DOCS';
	} else {
	  s = s.join('').replace(/\n\s*[^\s\/][\s\S]*$/, '');
	  s = s.replace(/\n\s*\n[\s\S]*/, '');
	  s = ('\n'+s).replace(/\n\s*\/\/\s*/g, '\n');
	  s = s.replace(/^[\n]DOC[\s:]*/, '');
	  doc = s;
	}

	princ(cmd); TAB();

	// indent paragraph!
	let mincol = col;
	for(let i=0; i<doc.length; i++) {
	  let ch = doc.charCodeAt(i)
	  let c = col;
	  if (col < mincol) TAB();
	  putc(ch);
	  if (ch === 10 || col > COLWIDTH-2) {
	    //alert('NEWLINE: col='+col+' row='+row);
	    //princ('[' + c + ']');
	    TAB(); col++;
	  }
	}
	print();
	return;
      } else {
	print('?NO SUCH NAME');
      }
    }

    // list names!
    
    function printkeys(msg, k) {
      let num = 0;
      k.forEach(n=>{
	if (cmd && !n.match(cmd)) return;
	princ(n);TAB();
	num++;
      });
      if (num) {
	if (col > 2) print();
	princ(num);
	print('WORDS ' + msg);
      }
    }

    printkeys(
      'MISSING', OKK(/(dummy|missing|impl|UNKN)/i));
    printkeys(
      'DEFINED', OKK(/(const|defined|native|innov)/i));

    print('Usage: HELP [cmd]');

  }

  
  // #FFFFF 
  // PRINT "FOO"BAR"
  // PRINT "4*3="; 4*3
  // PRINT "FOO";"BAR" => FOOBAR
  // ?35 == PRINT 35
  // PRINT 1;2 => <spc>1<spc><spc>2<spc>
  // 40 PRINT"THE CODE FOR "A$"="ASC(A$)
  // PRINT "foo",
  // PRINT "bar"    > fooo       bar 
  // 20 PRINT @X,10;·• WHIZZ2" 
  // TEST: PRINT 1 2 3+6 =>  123  6
  // TEST: PRINT 1 2 3, 4 5, FOO, FOO& =>
  //   123     45   3
  //   ?SYNTAX ERROR
  // TEST: LET A=1 2 3 : PRINT A => 123
  // TEST: A=77 : AA=6 : A$="FOO"
  //   TEST: PRINT A A => 6
  //   TEST: PRINT 7A => 7  77
  //   TEST: PRINT 9AA4 5, 99 => 9  6   99
  //   TEST: PRINT 3A$6 =>  3 FOO 6
  //   PRINT 3A$77AA(3)5A$A =>
  //     3 FOO 77 0 5 FOO 77
  //   ?A$7A$AA => FOO 7 FOO 6
  //   ?A$3+4*10^2A => FOO 403  77
  //   PRINT A A => 6
  //   PRINT AA => 6
  //   PRINT A => 77
  //   ? A A+7 => 13
  // TEST: LET A B = 7 5
  //   PRINT AB =>  75
  //   PRINT AB 5 =>  75
  //   PRINT AB C => 75
  // TODO: PRINTAT
  //  20 PRINT @X,10;·• WHIZZ2"
  function PRINT() {
    let line = this;
    line = line.replace(/^PRINT\s*/, '');
    line = line.trim();

    let exp = '', mode = 'normal', par = '';
    let nonewline = false;
    for(let i=0; i<line.length; i++) {
      let c = line[i];
      if (trace) print('PRINT.c: ' + c);

      function finish(ev) {
	if (exp.length)
	  princ(ev?EVAL(exp):exp);
	exp = '';
	if (c === ',') TAB();
      }
      
      switch(mode) {
      case 'normal': {
	switch(c) {
	case ',':
	case ';': 
	case ' ': finish(true); break;
	case '\\': return unexpected_error('\\');
	case '"': finish(true); mode = 'string'; par += '"'; break;
	case '(': exp += c; mode = 'expr'; par += ')'; break;
	case '[': exp += c; mode = 'expr'; par += ']'; break;
	default: exp += c;
	}
	break;
      }
      case 'string': {
	if (c=='"') {
	  if (exp.length)
	    princ(exp)
	  exp = '';
	  mode = 'normal';
	} else {
	  exp += c;
	}
	break;
      }
	// TOOD: too simple
      case 'expr': {
	if (par)
	  if (')]"'.indexOf(c) >= 0) {
	    let e = par[par.length-1];
	    if (e !== c)
	      return unmatched_paren_error(e, c);
	    else
	      par = par.substring(0, par.length-1);
	  }
	
	switch(c) {
	case '\\': return unexpected_error('\\');
	case ';': if (par) return unexpected_error(';');
	  
	case '(': par += ')'; break;
	case '[': par += ']'; break;
	case '"': par += '"'; break;
	  
	case ',':
	case ' ': {
	  if (exp.length && !par.length) {
	    princ(EVAL(exp))
	    exp = ''
	    mode = 'normal';
	  }
	  if (c === ',') TAB();
	  break;
	}
	default: exp += c;
	}
	break;
      }
      }
      if (c !== ' ') nonewline = false;
      if (c === ';') nonewline = true;
    }

    // cleanup
    if (exp.length) {
      // TODO: missing " ?
      if (mode === 'string')
	princ(exp);
      else
	princ(EVAL(exp));
    }
    if (!nonewline)
      putc(10);
  }

  // TODO: Basic Lines max 80 chars bell at 79?

  // LIST -100
  // LIST 100-
  // LIST 100-200

  // TODO: sorted?
  let lines = {
    //1: 'PRINT "HELLO!"',
    //2: 'END',
    
    10: 'LET A=0',
    20: 'PRINT A;',
    30: 'LET A=A+1',
    40: 'GOTO 20',
  };

  ylines = {
    5: 'LET E=1000',
    10: 'FOR I=0 TO E',
    15: 'PRINT I',
    20: 'NEXT',
  };
  
  xlines = {
    10: 'LET I=0',
    20: 'LET P=0',
    30: 'INK I',
    40: 'PAPER P',
    50: 'LET P=P+1',
//    50: 
  };
  
  function running() {
    return !!RUN.interval;
  }
  
  // TODO: like list but formats the code...
  // prettyprint
  // function PP()  {
  //
  //}

  function LIST(n) {
    line = '';
    lineno = -1;
    print();
    
    RUN.interval = setInterval(_=>{
      for(let i=0; i>=0; i--) {
	nextline();
	if (!line) {
	  lineno = 0;
	  line = '';
	  print(); // TODO: not best place
	  stop();
	} else {
	  princ(lineno);
	  print(line);
	}
      }
    }, 0);
  }

  function saveline(lno, line) {
    if (trace) print('saveline.lno: ' + lno);
    if (trace) print('saveline.line: ' + line);

    // we remove one initial space
    // which means saving need to add one..
    let l = line.replace(/^\s/, '');
    if (trace) print('saveline.l: ' + l);

    // ? expansion! (short hand for PRINT)
    // TODO: another day!
    //line.replace(/^(([^"]*)(|"[^"]"))$/g,
    // what does the function get?

    // TODO: REM ?5 not expanded
    // BUT: ' ?5 IS!
    // NOT: ' sdfsdf "foo ?5 sdf" ISN'T!!!

    // store line (or remove)
    if (l.match(/^\s*$/))
      delete lines[lno];
    else
      lines[lno] = l;
      
  }
  
  function EDIT(lno) {
    // DOC: Print, move cursor to LINENO
    // New: Just EDIT if STOP:ped
    // New: Line keeps spaces!
    lno = lno || lineno;
    let line = lines[lno]
    // TODO: error?
    if (!line) return;

    print(lno + ' ' + line);
    cursorMove('u');
  }
  
  function TRON() {
    tron = true;
  }
  function TROFF() {
    tron = false;
  }


  function CLEAR() {
    // DOC: Clears variables
    lineno = 0;
    line = '';
    stack = [];
    lineTodo = [];
    vars = {}
  }

  function RUN(lno) {
    // DOC: Runs program (from LINE)
    // END, STOP, or CTRL-C interrupts
    // Continue with CONT or GOTO num
    CLEAR();
    GOTO(0);
  }
  
  // TODO: On ORIC you can CONT after END!
  function END() {
    stop('noprompt');
  }
  
  function nextline() {
    // crazy linear search for next!
    // you could goto any number
    // it just find the next numerically
    line = '';
    while (!line && lineno < 65536) {
      lineno++;
      // TODO: these aren't guaranteed to be in order? only when for-in!!!
      line = lines[lineno];
    }
    if (line === undefined) line = '';
  }

  function cont() {
    if (running()) return;
    
    RUN.interval = setInterval(_=>{
      cont.intervalcount++;
      let start = Date.now();
      let millis;
      do {
	nextline();
	if (line && trace) print(lineno + ' ' + line)
	if (tron) princ('[ '+lineno+']');
	if (!run(line)) stop();
	millis = Date.now() - start;
      } while (!forceUpdate && millis  < TIMESLICE);
      cont.millis += millis;
    }, 1);
  }
  cont.intervalcount = 0;
  cont.millis = 0;
  
  // TODO: if program edited?
  function CONT() {
    if (!CONT.lineno)
      return cont_error();

    lineno = CONT.lineno;
    line = CONT.line;
    delete CONT.lineno;
    delete CONT.line;

    cont();
  }
  function ON_GOTO() { }

  function GOSUB(lno) {
    stack.push(['RETURN', lineno, line]);
    lineno = lno-1;
    line = '';
  }
  function RETURN() {
    let ret = stack.pop();
    if (!ret) return_error();
    if (ret[0] !== 'RETURN')
      return return_error();
    [ret, lineno, line] = ret;
  }    

  // use same stack as GOSUB as they need to be matched! (you can't GOSUB and there NEXT)
  function FOR() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('FOR.init: ' + init);
    print('FOR.to: ' + to);
    print('FOR.step: ' + step);

    let v = init.match(/^(\w+)\s*=/);
    if (!v) syntax_error('');
    ('LET ' + init).LET();

    // TODO: this is when I realize
    // that doing it on the fly isn't going
    // to work very well,
    // HMMM,why was that again? lol
    // FOR-NEXT, GOSUB-RETURN and
    // and something about
    // FIE : FOR : BAR
    // FUM : NEXT : FOO
    //
    // FIE : STOP : BAR
    //
    // PRINT 11 : STOP : PRINT 22 : END
    // CONT -> 22
    // CONT ater END ok! haha
    //
    // notice: the loop is run at least once!
    //   and it'll do one step...
    // ?NEXT WITHOUT FOR ERROR IN LINE...
  }

  function TO() {
    let line = this;
    let [_, init, to, __, step] =
	line.match(/^FOR\s*(.*?)\s*TO\s*(.*?)\s*(STEP\s*(.*)|)\s*$/);
    print('TO.to: ' + to);
    print('TO.step: ' + step);

    to = EVAL(to); // once or every time?
    step = EVAL(step); // once or every time?
    if (variable <= to)
      stack.push([lineno, `TO ${to} STEP ${step}`]);
  }

  function NEXT() {
    // TODO: ...
    // cheat for now
    return RETURN(); 
  }

  // TEST:
  //  IF 1 THEN ?1 ELSE ?2 => 1
  //  IF 0 THEN ?1 ELSE ?2 => 2
  //  IF1THENIF1THEN?1ELSE?2ELSE?3 => 1
  //  IF1THENIF0THEN?1ELSE?2ELSE?3 => 2
  //  IF0THENIF0THEN?1ELSE?2ELSE?3 =>>
  //  IF0THENIF1THEN?1ELSE?2ELSE?3 =>>
  

  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  //  IF 1 THEN IF 1 THEN ?1 ELSE ?2 ELSE ?3=>1
  // IF 1 THEN ?2 : ?3 ELSE ?4 : ?5 : ?6
  //   => 2 3 5 6
  // IF "" THEN ?1 ELSE ?2 => 2
  // IF ("") THEN ?1 ELSE ?2 => ?FORMULA COMPL
  // IF "A" THEN ?1 ELSE ?2 => 1
  // IF ("A") THEN ?1 ELSE ?2 => 1
  
  function IF(e) {
    let line = this;
    while(line.length) {
      print('IF: ' + line);
      line = line.trim();

      // we're (maybe) in the THEN
      // - skip the first statement after ELSE
      // continue with the rest!
      if (line.match(/^ELSE/)) {
	print('ELSE: ' + line);
	// remove anything before ':'
	//   (':' inside "string" ok)
	line = line.replace(
	  /^[^:"]*("[^"]*"[^:"]*)\s*/,
	  '');

	print('ELSE.replace: ' + line);

	// if just a single statement no ':'
	if (line.length && line[0] != ':')
	  return;

	// we've skipped the ELSE part
	// IF 1 THEN ?3:?4 ELSE ?5:?6:?7=>3467
	// how to go to "run"?

	// TODO: make cont()/nextline()
	//   use queue to pull next thing?

	lineToDo.unshift(line);
	return;
      }
      
      let exp, expr;
      line = line.replace(
	/^IF\s*(.*?)\s*THEN\s*/,
	(_, e)=>{
	  exp = e;
	  // string constant, strange!
	  if (exp.startsWith('"')) {
	    // "" => false
	    // "A" => true
	    expr = (exp !== '""');
	  } else if (exp.match(/^\w+$/)) {
	    // any string variale => true
	    expr = true;
	  } else { // ok, let's guess number?
	    let r = VAL(exp);
	    expr = (r !== 0);
	  }
	  return '';
	});

      print('IF.match: ' + line);
      print('IF.exp: ' + exp);
      print('IF.expr: ' + expr);

      // did we get it?
      if (exp === undefined || expr === undefined)
	syntax_error();

      // not true => ELSE
      if (!expr) {
	print('IF.false ' + expr);
	// TOOD: this cheats: "foo ELSE ..."
	let t = line.indexOf('THEN');
	let e = line.indexOf('ELSE');

	print('IF.false t=' + t + ' e=' + e);

	// no ELSE - we're done!
	if (e < 0) return;

	// TODO: check, for loop in THEN?
	// and can it have ELSE inside? LOL
	// see gphotos: IF-FOR-ELSE!!!
	// seems
	// IF THEN ?1:FORI=0:IF THEN ELSE:NEXT:?77 ELSE <never reached> - so it's OK!

	// have more THEN - ELSE=not ours!
	if (t >= 0) return;

	// skip to after ELSE and do rest
	line = line.substring(e+4);
      }

      // if true - just continue!
      // but keep in mind that when
      // reach 'ELSE ?3:?4:?5' skip to
      // ?4 ...
    }
  }
  
  function REPEAT() {}
  function UNTIL() {}

  function stop(noprompt) {
    //print('STOPPED!');
    let wasrunning = running();
    if (col > 2) print();
    if (wasrunning) {
      clearInterval(RUN.interval);
      delete RUN.interval;
      if (!noprompt) prompt();
    }
    line = '';
    return wasrunning;
  }
  
  function GOTO(lno) {
    // DOC: Goto given LINENO
    // New: if no line, search next
    lineno = lno-1;

    cont();
  }

  // -- dummies
  function REM() {
    // DOC: REMMARK nice days, isn't?
  }
  // haha thought it was autonum?
  function AUTO() {
    // DOC: CSAVE "fnme", AUTO autoruns!
  }
  function CALL() {
    error("?WHO'RE YOU GONNA CALL? STEVE?");
  }
  function USR() {
    error('USSR NOT ANSWERING. TRY LATER!');
  }
  
  function FRE() { return FRE.size; }
  FRE.size = 393737; // Atmos 38737;
  // LOL
  function GRAB() { FRE.size *= 2; }
  function HIMEM() { FRE.size *= 2; }
  function RELEASE() { FRE.size *= 2; }
  
  function STOP() {
    cursorHide();
    let lno = lineno;
    let l = line;
    if (stop('noprompt')) {
      if (col>2) print();
      print(' BREAK IN   '+lineno);
      CONT.lineno = lno;
      CONT.line = l;
    }
    prompt();
    cursorShow();
  }
  
  // WAIT 100 = 1s
  function WAIT(decaseconds) {
  }
  
  function example_VAT() {
    return `
10 REM *VAT Calculation* 
20 INPUT"ENTER SALE PRICE";SELL 
30 LET VAT=0. 15*SELL 
40 LET PRICE=SELL+VAT
50 PRINT "TOTAL=";PRICE 
60 'Round agan for next calculation
70 WAIT 500:CLS:GOTO 20
`;
  }

  function  example_NAME() {
    return `
10 A$="0RIC" 
120 LET Al$="BASI·C" 
130 LET LAST$="LESSON" 
140 INPUT"ENTER YOUR NAME,PLEASE";NAME$ 
150 CLS:PRINT A$;" ";Al$;" ";LAST$ 
160 PRINT "FOR ";NAME$
`;
  }

  function example_KEY() {
    return `
10 PRINT"PRESS A KEY" 
20 GET A$ 
30 PRINT"YOU PRESSED "A$ 
40 PRINT"THE CODE FOR "A$"="ASC(A$) 
50 GOTO 10
`;
  }

  function example_DEF() {
    return`
5 REM*Define Function M to convert feet 
to metres 
10 DEF FNM(FEET)=FEET*0.3048 
20 INPUT"HOW MANY FEET";X 
30 M=FNM(X) 
40 PRINT X;"FEET EQUAL";M;" METRES"
`;
}

  function example_FOR() {
    return `
10 FOR L=l TO 5:PRINT L*L:NEXT L 

10 FOR L=10 TO 5 STEP-l:PRINT L*L:NEXT 

10 CLS 
20 FOR LOOP=0 TO 25 
30 PRINT CHR$(65+LOOP)+CHRS(97+LOOP); 
40 NEXT LOOP 
`;
  }

  function example_READDATA() {
    return `
10 REM*READ o.nd DATA* 
20 FOR 0=0 TO 6 
30 READ D$ 
40 PR1NT D$ 
50 NEXT 
60 REM . . . lots more program 
70 ' 
2000 DATA MONDAY,TUESDAY,WEDNESDAY,THUR 
SDAY 
2010 REM ... more program in between 
3000 DATA FRIDAY, SATURDAY,SUNDAY 
4000 REM .. co.n do it 0.90.in 
4010 RESTORE 
4020 FOR K=l TO 7 
4030 READ DAY$:PRINT DAY$:NEXT
`;
  }

  function example_DIM() {
    return `
10 INPUT"HOW MANY NAMES" ;N% 
20 DIM NAME$(N%):DIM AGE(N%)
30 CLS:SLJM=0 
40 FOR K=1 TO N%
50 PRINT "ENTER NAME t'-10. "K 
60 INPUT NAME$[K]
70 PRINT NAME$[K]"'S AGE ?" 
80 INPUT AGE[K] :SLJM=SLJM+AGE[K]
80 CLS 
100 NEXT K 
110 FOR K=N% TO 1 STEP -1 
120 PRINT :PR1NT NAME$[K]" JS";
130 NEXT K
`;
  }
  
  function example_2DIM() {
    return `
10 DIM NXC10,3) 
20 CLS 
30 FOR K=l TO 10 
40 ~OR J=l TO 3 
50 NxCK,JJ=K"J 
60 PRINT NxCK,JJ 
70 NEXT J 
80 PRINT 
90 NEXT K
`;
  }

  function example_BUBBLESORT() {
    return `
5 REM*NUMERIC BUBBLE SORT** 
10 CLS:LET J=15 'Number of items 
20 DIM NUMCJJ'ATray foT numbeTs 
30 'Example numbers generated here" 
40 FOR K=0 TO J 
50 LET NUMCKJ=RNDC1J*1000 
60 PRINT NUMCKJ 
70 NEXT K 
99 ' 
100 REM*SORT*ROUTINE* 
101 ' 
110 FOR M=l TO CJ-lJ 
120 FOR N=M TO J 
125 REM If correct ordeT 
already,then skip 
130 IF NUMCMJ<NUMCNJ THEN 170 
135 REM Incorrect order,so swap 
140 TEMP=NUMCMJ 
150 NUMCMJ=NUMCNJ 
160 NUMCNJ=TEMP 
170 NEXT N 
180 NEXT M 
189 ' 
190 REM**ENDSORT** 
191 ' 
200 REM *Print sorted list* 
210 CLS:PRINT ''SORTED LIST:" 
220 FOR K::::JTO J 
230 PRINT NUMCKJ 
240 NEXT K 
`;
  }

  // loop is completed, the address is removed, and a subsequent NEXT will 
  // activate a jump to the address now on the top of the pile. The stack can only 
  // hold 10 addresses, and more than 10 loops will give an ?OUT OF MEMOR
  
  function READ() {}
  function DATA() {}
  function RESTORE() {}
  
  // GET K$
  function GET() {}
  function READ() {}
  function DATA() {}

  function ASC(s) {
    // DOC: get ascii number from string
    tString(s, s === '');
    return s.charCodeAt(0);
  }

  function CHR$(n) {
    // DOC: get char from ascii number
    tNum(n, n < 0 || n > 255);
    // TODO: cheat with allo unicode?
    return String.fromCharCode(n);
  }

  function STR$(n) {
    // DOC: make a string from a number
    tNum(n);
    return (n < 0 ? '' : ' ') + n.toString();
  }

  function HEX$(n) {
    // DOC: return #HEX for number
    // Curiosity: return #0 for string
    if (typeof n !== 'number') return '#0';
    tNum(n, n < 0 || n > 65535);
    return '#' + INT(n).toString(16).toUpperCase();
  }  

  function LEN(s) {
    tStr(s);
    return s.length; }

  function LEFT$(s, len) {
    // DOC: From S return LEN first chars.
    tStr(s); tPos(len);
    return  s.substring(0, len);
  }    
  function RIGHT$(s, len) {
    // DOC: From S return LEN last chars.
    tStr(s); tPos(len);
    return  s.substr(-len);
  }

  function MID$(s, pos, len) {
    // DOC: From S from POS get LEN chars
    tStr(s); tPos(pos); tPos(len);
    return s.substr(s, from, len);
  }

  function SPC(n) {
    tPos(n);
    return ' '.repeat(n);
  }
  
    
  function VAL(s) {
    // Oric: doesn't even need to terminate "string in PRINT, but in VAL("FOO   have to...
    
  }    
  
  function INT(n) {
    tNum(n);
    return Math.floor(n);
  }
  
  // REM comment
  // ' commment
  function REM() {}

  // MATH
  // + - * / ^
  //   / == div_error()... check...
  
  // Oric BASIC has the following built-in numeric functions: 
  ABS = Math.abs;
  ATN = Math.atan;
  COS = Math.cos;
  EXP = Math.exp;
  INT = Math.floor;
  LN = Math.ln;
  LOG = Math.ln10;
  PI = Math.PI;
  TRUE = -1;
  FALSE = 0;
  SGN = n=>(n>0)?+1:(n<0)?-1:0;
  SIN = Math.sin;
  SQR = Math.sqrt;
  TAN = Math.tan;
  function RND(n) {
    if (!n) return Math.random();
    return Math.floor(n * Math.random());
  }

  function AND(a, b) {
    // DOC: bitwise and 2 values
    return a & b;
  }
  function OR(a, b) {
    // DOC: bitwise or 2 values
    return a | b;
  }
  function NOT() {
    // DOC: negate all bits (0 <=> -1)
    return ~a;
  }

  // tested by means of conditional operators: 
  // Equal to 
  // <> Not equal to 
  // > Greater than 
  // < Less than 
  // >= Greater than or equal to 
  // < = Less than or equal to 
  // These operate much as you would expect for numeric values. Two things 
  // need to be remembered, however. The fir

  // 10 DEF FNMCFEETJ=FEET*0.3048 
  function DEFFN(n, exp) {}

  function example_ONGOTO() {
    return `
10 l NPUT" ENTER 1 .. 2 OR 3_, PLEASE' ' ;N 
20 ON N GOTO 150,200,300 
140 RP1 
159 PRINT "LINE 150 FROM N=J";GClTO 10 
190 REM 
200 PRINT "LINE 200 FROM N=2":GOTO 10 
290 REM 
300 PRINT "LINE 300 FROM N=3" :GOTO 10
`;
  }

  function PEEK() {}
  function POKE() {}

  function NEW() {
    stop(true);
    lines = {};
  }
  
  // TODO: load basic from any URL!
  function CLOAD(name, info) {
    // DOC: Loads a file "NAME"
    // New: Without arguments lists examples
    // New: With 'CLOAD D' shows names with 'D'
    if (!name) name = '';
    
    let origline = this;
    function load(src) {
      if (!src) return;
      NEW();
      let name = beautyname(names[0]);
      print('Program ' + name + ' loading...');
      let n = 0;
      ('\n'+src).replace(
	/\n\s*(\d+)(.*)/g,
	(_, lno, l)=>{
	  saveline(+lno, l);
	  if (trace) { princ(+lno); print(l); }
	  n++;
	});
      princ(n); print('lines loaded');
      if (origline.match(/,\s*AUTO/)) RUN();
      return true;
    }
    
    // get names from window
    let names = Object.keys(window)
	.filter(n=>n.startsWith('example'));
    // add names from localstorage
    names = names.concat(lssearch('CSAVE:'));

    // filter matches
    if (name) {
      if (name.match(/^".*"/))
	names = names.filter(
	  n=>n.match(RegExp(
	    `^CSAVE:${name.replace(/"/g,'')}\$`)));
      else
	names = names.filter(n=>n.match(name));
    }

    // names are now "ugly" use this to show
    function beautyname(n) {
      return n
	.replace(/^example_+/, '')
	.replace(/^CSAVE:(.*)/, '"$1"');
    }
      
    // to load (instead of list, require match  to be proper prefix)
    if (trace) { print("NAMES:"); print(names); }
    
    if (names.length == 1
	&& names[0].match(RegExp(`^(?:example_*|CSAVE:)${name}`))) {
      let src;
      
      // try load from examplesNAME...
      src = window[names[0]];
      if (src) {
	// ok, it's not a string?
	if (typeof src === 'function') try {
	  src = src();
	} catch(e) {}
      }

      // try localStorage
      if (!src)
	src = lsget(names[0]);

      if (load(src)) return;
    }

    // all else (and no return is:)
    if (name)
      print('?CLOAD NAME ERRROR');

    // list'em
    print("Matching names:");
    print();
    names
      .map(beautyname)
      .forEach(n=>(princ(n), TAB("3")));
    print();
  }
  
  function CSAVE(name, opt) {
    // DOC: Save program lines
    // "foo" - in localStorage
    // TODO: "foo.tap" - download
    if (!name) name = '';
    if (opt) return save_error('USING '+opt);
    name = name.replace(/"/g, '');
    if (name.match(/^\w+/)) {
      let src = Object.keys(lines)
	  .map(lno=>`${lno} ${lines[lno]}\n`)
	  .join('');
      let lns = src.match(/\n/g).length;
      if (trace) print(src);
      lsput('CSAVE:' + name, src);
      princ(lns); 
      print('lines saved in ' + name);
    } else {
      save_error('BAD NAME: '+name);
    }
  }

  function STORE() {}
  function RECALL() {}
  
  function example_TAB() {
    return `
10 FOR 1=0 TO 5 
20 PRINT TAB(I); "HELLO" 
30 NEXT I 
HELLO 
HELLO 
 HELLO 
  HELLO 
   HELLO 
    HELLO
`;
  }
  
  // sounds
  // https://bulba.untergrund.net/emulator_e.htm
  // The PLAY command allows you to mix tones and gives access to eight preset envelope shapes.
  function PLAY() {}
  // After using MUSIC and SOUND to set channel and select the tones and noise you want, you use PLAY to mix the channels, select an envelope and control the duration of the final sound. In this way, quite complex sounds can be built up even considering the limitations of the single voice and the pre-set envelopes. The three main sound commands can be used in programs written in
  function MUSIC() {}
  function SOUND() {}

  function ZAP() {}
  function PING() {}
  function SHOOT() {} // "snare-drum"
  function EXPLODE() {}


</script>

<script>
  DBG('logerr', true);
  
  function rand(n) {
    return Math.floor(Math.random()*n);
  }
  
  TEXT();
  CLS();

  run('boot');

  window.onerror = function(message, url, line, col, errorObj) {
    dom('error', `WINDOW.ERROR:
message  : ${message}
url      : ${url}
line     : ${line}
col      : ${col}
errorObj : ${errorObj}
`);
  }

  let lastrun = 0;
  setInterval(_=>{
    dom('line', line);
    dom('row', row);
    dom('col', col);
    dom('vars', JSON.stringify(vars));
    
    dom('stats', 'Statements: '+run.count+
	' sps= ' + Math.floor(1000*(run.count-lastrun)/(cont.millis)));
    lastrun = run.count;
    
  }, 100);
  // clear initial error
  dom('error', '');
  
  function editChar(ch) {
    cursorHide();
    let c = String.fromCharCode(ch);
    // ignore keyboard setting
    if (caps)
      c = c.toUpperCase();
    else
      c = c.toLowerCase();
    line += c;
    putc(c.charCodeAt(0)); // lol

    cursorShow();
  }    

  function editEnter() {
    cursorHide(); // turned on by run/stop
    print();
    run(line);
    line = '';
  }

  // basically make other arguments splittable
  function quoteStrings(line) {
    return line.replace(
      /\".?\"/g,
      s=>s.replace(/!/g, '!!')
	.replace(/ /g, '!s!')
	.replace(/'/g, '!q!')
	.replace(/:/g, '!c!')
      	.replace(/\(/g, '!po!')
        .replace(/=/g, '!e!')
        .replace(/,/g, '!com!')
    );
  }
  function unquoteStrings(line) {
    return line.replace(
      s=>s.replace(/!c!/g, ':')
	.replace(/!s!/g, ' ')
      	.replace(/!po!/g, '(')
        .replace(/!pc!/g, ')')
        .replace(/!e!/g, '=')
        .replace(/!q!)/g, "'")
        .replace(/!com!)/g, ',')
	.replace(/!!/g, '!'));
  }

  function prompt(noprompt) {
    if (!noprompt) {
      if (col > 2) print();
      print('Ready');
    }
    cursorShow();
  }
  // interprets and runs one line
  // returns true if ok
  // END return false
  function run(line) {
    line = line.trim();
    // remove leading ':' (used for indent!)
    line = line.replace(/^[\s:]*/, '');

    // TODO: remove ll cursorShow from here...
    
    // fast comments
    // TODO: inncorrect REM is a statement...
    //   PRINT 33 : REM foo
    //   PRINT 33 ' foo
    if (line.match(/^(REM|')/))
      return (cursorShow(), 'REM');
	
    if (!line || line === '')
      return (cursorShow(), '');

    // NN PRINT ... new line?
    // New: retains initial spacing! lola
    let linedef = line.match(/^\s*(\d+)(.*)$/);
    if (linedef) {
      saveline(+linedef[1], linedef[2]);
      return (cursorShow(), 'EDIT');
    }

    line = line.trim();
    let orig = line;

    // ok, we have command  to execute
    line = quoteStrings(line);

    // TODO: incorrect as F!
    // if (1) THEN ?3:?4 ELSE ?5 : ?6 : ?7
    //   ORIC => 3 4 6 7
    if (trace) print('LINE: ' + line);
    let many = line.split(':');
    if (trace) print('MANY: ' + many.length);
    // TODO: incorrect, and can't CTRL-C!
    if (many.length > 1) {
      let r= many.map(unquoteStrings)
	  .some(x=>!run_h(x));
      return r;
    }

    let cmd = run_h(line, orig);
    
    // if it's not running in background
    if (!running()) prompt(cmd === 'EDIT');
    return true;
  }
  // internal: takes quotedStrings param
  function run_h(line, orig) {
    run.count++

    // rough parameter extraction
    let a = line.split(/[\s;=\(\),]+\s*/g);
    if (trace) print('------' + a.join(' | '));
    a = a.map(unquoteStrings);
    if (trace) print('------' + a.join(' | '));

    // hehe - crap!
    if (!orig.match(/^(LET|INPUT|FOR|HELP|DIM|CLOAD|CSAVE|REM)/)) {
      if (trace) print('---EVAL---' + a.join(' | '));
      a = a.map((x,i)=>!i?x:EVAL(x));
    }

    // make numbers great again
    a = a.map(x=>(+x==x?+x:x));
    if (trace) print('--num---' + a.join(' | '));

    let cmd = a.shift();

    // call function
    let f = window[cmd];
    if (trace) print('LINE: ' + line);
    if (f) {
      try {
	// TODO if f.len !+ a.length => ?SYN
	// problem is with ...args count=0
	f.apply(orig, a);
      } catch(e) {
	// TOOD: make into error?
	// simplify error handl: just throw strings!
      }
    } else {
      stop(true);
      try { syntax_error(cmd); } catch(e) {}
      return;
    }

    return  cmd;
  }
  run.count = 0;
  
  function editBackspace() {
    cursorHide();
    line = line.substring(0, line.length-1);
    putc(8);
    cursorShow();
  }
  
  function editCancel() {
    line = ''; 
    cursorHide();
    princ('\\');
    print();
    cursorShow();
  }

  function editCopy() {
    let c = screen(row, col);
    editChar(c);
  }

  let arrows = {l:37, u:38, r:39, d:40};
  function cursorMove(direction, steps=1) {
    direction = direction.toLowerCase();
    let c = arrows[direction[0]];
    while(steps--)
      editArrow(c);
  }
  function editArrow(ch) {
    cursorHide();
    switch(ch) {
    case 37: col--; break; // left
    case 38: row--; break; // up
    case 39: col++; break; // right
    case 40: row++; break; // down
    }
    // move cursor, wrap around (?)
    // TODO: columns mode?
    if (col < 2) col = 39;
    if (col > 39) col = 2;
    if (row < 0) row = 27;
    if (row > 27) row = 0;
    cursorShow();
  }

  function showStatus() {
    // make modeline black w white text
    screen(0, 0, 0);
    screen(0, 1, 7);
    
    // save ---
    let r = row, c = col;

    // CTRL-Q: toggle cursor
    row = 0; col = COLWIDTH-4;
    princ(caps?'CAPS':'    ');

    // CTRL-S: toggle screen (centered)
    row = 0; col = Math.floor(COLWIDTH-8)/2;
    princ(scrn?'        ':'SCRN OFF');

    // TODO: column enable disable CTRL-J
    if (column) {
    } else {
    }

    // --- and restore
    row = r;
    col = c;
  }
  
  dom('exp').addEventListener('keydown', function(e) {
    let c = e.ctrlKey, a = e.altKey;
    let k = e.key.toLowerCase();
    let s = e.shiftKey, ch = e.code;
    let kc = e.keyCode;

    if (kc==13) editEnter();
    if (kc==8) editBackspace();

    // WARNING: NO ALT (below here)
    if (a) return;
    
    if (c && k=='c') STOP();
    if (c && k=='x') editCancel();
    if (c && k=='l') {
      cursorHide();
      CLS();
      cursorShow();
    }
    if (c && k=='a') editCopy();
    if (c && k=='f') click = !click;
    if (c && k=='q') cursorToggle();
    if (c && k=='t') showStatus(caps = !caps);
    if (c && k=='s') showStatus(scrn = !scrn);
    if (c && k=='f') clickToggle();
    if (c && k=='d') doubleToggle();
    if (c && k=='g') bell();

    if (c && k=='j') showStatus(column = !column);
    if (37 <= kc && kc <= 40) editArrow(kc);

    // my extensions
    if (c && k=='r') window.location.reload();
    if (c && k=='p') trace = !trace;

    //if (c) e.preventDefault();
  })

  dom('exp').addEventListener('keypress', function(e) {
    let c = e.ctrlKey, k = e.key; s = e.shiftKey;
    let legc = e.charCode, legk = e.keyCode;
    let ch = e.code;
    //    if (legk > 16) 
    //    alert(`k=${k} legc=${legc} legk=${legk} ch=${ch}`);
    // TODO: use e.code - but it's crap
    // and don't reflect shift
    if (e.keyCode==13) return;
    editChar(legc) // , e.getModifierState("CapsLock"));
  });

  // TODO: this shouldn't be needed,
  // but setting background-color changes
  // layout!
  PAPER(7);
  INK(0);

  window.onerror = function(e) {
    dom('error', ''+e);
  };
  
  if (0) {
    screen(10, 10, 77);
    screen(12, 12, 3);
    screen(14, 14, 16+5);
    PAPER(7);
    INK(5);
  }
  
  if (0)
    setInterval(_=>{
      for(let i=0; i<100; i++)
	screen(rand(ROWHEIGHT), rand(COLWIDTH), rand(256));
      PAPER(rand(8));
      INK(rand(8));
    }, 0);


  // ORIC BASIC KEYWORDS
  // https://www.defence-force.org/computing/oric/coding/annexe_1/index.htm

  // Note: STR$ indicates a value of 334 for the token. It seems to be
  // hard to put in a byte !
  // NAME	CODE	TYPE
  function OricKeywords(cb) {
    `
ABS	216	
function
AND	209	
operator
ASC	236	
function
ATN	229	
function
AUTO	199	
parameter
CALL	191	
instruction
CHR$	237	
function
CIRCLE	173	
instruction
CLEAR	189	
instruction
CLOAD	182	
instruction
CLS	148	
instruction
CONT	187	
instruction
COS	226	
function
CSAVE	183	
instruction
CURMOV	171	
instruction
CURSET	170	
instruction
DATA	145	
instruction
DEEK	231	
function
DEF	184	
instruction
DIM	147	
instruction
DOKE	138	
instruction
DRAW	172	
instruction
EDIT	129	
instruction
ELSE	200	
instruction
END	128	
instruction
EXP	225	
function
EXPLODE	164	
instruction
FALSE	240	
constant
FILL	175	
instruction
FN	196	
function
FOR	141	
instruction
FRE	218	
function
GET	190	
function
GO	247
instruction
GOSUB	155	
instruction
GOTO	151	
instruction
GRAB	159	
instruction
HEX$	220	
function
HIMEM	158	
instruction
HIRES	162	
instruction
IF	153	
instruction
INK	178	
instruction
INPUT	146	
instruction
INT	215	
function
KEY$	241	
function
LEFT$	244	
function
LEN	233	
function
LET	150	
instruction
LIST	188	
instruction
LLIST	142	
instruction
LN	224	
function
LOG	232	
function
LORES	137	
instruction
LPRINT	143	
instruction
MID$	146	
function
MUSIC	168	
instruction
NEW	193	
instruction
NEXT	144	
instruction
NOT	202	
operator
ON	180	
instruction
OR	210	
operator
PAPER	177	
instruction
PATTERN	174	
instruction
PEEK	230	
function
PI	238	
constant
PING	166	
instruction
PLAY	169	
instruction
PLOT	135	
instruction
POINT	243	
function
POKE	185	
instruction
POP	134	
instruction
POS	219	
function
PRINT	186	
instruction
PULL	136	
instruction
READ	149	
instruction
RECALL	131	
instruction
RELEASE	160	
instruction
REM	157	
instruction
REPEAT	139	
instruction
RESTORE	154	
instruction
RETURN	156	
instruction
RIGHT$	245	
function
RND	223	
function
RUN	152	
instruction
SCRN	242	
function
SGN	214	
function
SHOOT	163	
instruction
SIN	227	
function
SOUND	167	
instruction
SPC	197	
function
SQR	222	
function
STEP	203	
instruction
STOP	179	
instruction
STORE	130	
instruction
STR$	334	
function
TAB	194	
function
TAN	228	
function
TEXT	161	
instruction
THEN	201	
instruction
TO	195	
instruction
TROFF	133	
instruction
TRON	132	
instruction
TRUE	239	
constant
UNTIL	140	
instruction
USR	217	
function
VAL	235	
function
WAIT	181	
instruction
ZAP	165	
instruction
`.replace(/(\S+)\t(\d+)\t\n(\S+)/g,
	  (_, word, code, what)=>
	  cb(word, code, what));
  }

  OricKeywords.name2code = {};
  OricKeywords.code2name = {};
  OricKeywords.type = {};

  OricKeywords.defined = [];
  OricKeywords.status = {};
  OricKeywords.missing = [];
  OricKeywords.innovated = [];
  
  OricKeywords((name, code, type)=>{
    OricKeywords.name2code[name] = code;
    OricKeywords.code2name[code] = name;
    OricKeywords.type[name] = type;
    OricKeywords.type[code] = type;
  });

  // deduce shit
  OricKeywords.missing = new Set();
  for(let k in OricKeywords.name2code) {
    OricKeywords.missing.add(k);
    // assume mssing till removed
    OricKeywords.status[k] = 'missing';
  }
  for(let k in window) {
    // Oric functions are all uppercase!
    
    if (k.toUpperCase() == k) {
      OricKeywords.missing.delete(k);
      OricKeywords.status[k] = 'window';
      
      OricKeywords.defined.push(k);

      let s = '';
      let f = window[k];
      if (typeof f === 'function')
	s += 'function';
      else
	s += 'const?';
      //if !f) continue; // || !f.toString) continue;
      if (typeof f == 'function') {
	f = f.toString();
	f = f.replace(/^function \w+/);
	if (f.length < 20) s += ',named,dummy';
	if (f.match(/implemented/)) s += ',not implemented';
	if (f.match(/(if|while|return|for|=)/)) s += ',DEFINED';
	if (f.match(/native code/)) s += ',native';
      }

      // NEW?
      if (OricKeywords.name2code[k])
	OricKeywords.missing.delete(k);
      else {
	s += ',NEW';
	OricKeywords.innovated.push(k);
      }

      if (s == '') s = 'UNKNOWN';
      
      dom('info', `== ${k} - - ${s}`, 'a');
      OricKeywords.status[k] = s;
    } else{
      //dom('info', `!! ${k}`, 'a');
    }
  }
  // make array out of set!
  OricKeywords.missing = [...OricKeywords.missing];

  dom('info',
      'INNOVATED - '+OricKeywords.innovated.join('\nINNOVATED - '),
      'a');
  dom('info',
      'MISSING - '+OricKeywords.missing.join('\nMISSING - '),
      'a');
  dom('info',
      Object.keys(OricKeywords.status).map(
	k=>`STATUS - - ${k} - - ${OricKeywords.status[k]}\n`).join(''),
      'a');

  function OKK(s) {
    return Object.keys(OricKeywords.status)
      .filter(
	k=>!!OricKeywords.status[k].match(s));
  }
  function OKC(s) {
    return OKK(s).length;
  }
  dom('info',
      '\nORIC ATMOS BASIC SIMULATOR STATUS'+
      '\n================================='+
      '\nMissing: '+OricKeywords.missing.length+
      '\nDefined: '+OKC(/defined/i)+
      '\nNative: '+OKC('native')+
      '\nNamed: '+OKC('named')+
      '\nNotImpl: '+OKC('impl')+
      '\nInnovated: '+OricKeywords.innovated.length+
      '\n----------------',
      'p');

  // create the missing funcs to throw error
  OricKeywords.missing.forEach(
    n=>window[n]=()=>implemented_error(n));

  // remove non-basic names... not extensions
  'DBG,OKK,OKC,TEMPORARY,PERSISTENT,EVAL,HTML,STORE'.split(',').map(
    n=>{
      delete OricKeywords.status[n];
    });


</script>

<!--
LLIST...

LPRINT BASIC Token: 143
Format: LPRINT A$

This command works exactly the same as a PRINT statement except that it is used to send the print items to a printer. However, it is not possible to use an LPRINT@ statement. Used vvith the control codes listed in Appendix 1, LPRINT can be used to regulate the output to a variety of printers. It is possible to alter the line length of the printer output by using POKE #256,i where i is the required line length. 

Related keywords: CHR$, LLIST, PRINT

-->

<!--

MUSIC BASIC Token: 168
Format: MUSIC c, o, n, v

c=channel 0-3
o=octave 0-7
n=note 1-12
v=volume 0-15

This is one of the Oric's three major sound commands, and as its name implies it is used to generate musical output. The utilisation of the Oric's sound commands is relatively complex, and thus it is important that if you intend to take full advantage of these sophisticated facilities you should refer to the sound chapter. However it is possible here to outline the parameters of the command. 

There are four variables involved in a MUSIC statement and the command itself is usually coupled with PLAY (which creates the "shape" of the sound and determines the number of sound channels in operation at any one time). As laid out in the command format above, c sets the tone channel to be used, whilst o determines which of the eight available octaves is to be used (0--7).

The third variable, n, determines which of the twelve notes in a given octave will be generated ( 1-12).

The last parameter, v, determines the volume of the sound produced (0--15). 

Unless you have a good reason for wanting the last note of your musical masterpiece to drone on for eternity, you must close down all the tone channels by using the statement PLAY 0,0,0,0 to silence the computer.

l REM***MUSIC***
10 FOR 0=0 T0 6
20 FOR N=l T0 12
30 MUSIC l,O,N,10
40 PLAY 3,0,7,0
50 WAIT 30 
60 NEXT N
70 NEXT O
80 PLAY 0,0,0,0
90 EXPLODE

 Related keywords: PLAY, SOUND

----------------------------------------
PLAY BASIC Token: 169
Format: PLAY t, s, e, d

t=tone channel 0-7 (bit value 111)
s=sound channel 0-7 (bit value 111)
e=envelope 0-7
d=duration 0-32767

This is one of the Oric's rather complex sound commands which, once you get used to them, offer a music/sound potential well in advance of the machine's competitors. However, the commands are a little difficult to grasp, particularly if you're not musically minded, so it is well worth spending some time working your way through Chapter 7. For the present we will restrict ourselves to clarifying the format of the command. 
Your Orie is endowed with three sound/tone channels and PLAY is the command which determines the combination of these channels. In terms of the command format at the top of the page, t (tone) ands (sound) determine which channels are activated (0--7). The effects of the combination of channels is really only comprehensible· after a little experimentation, but the following chart will be of some use for future reference.

The column on the left represents the value oft or s, whilst the righthand column tells you which combination of channels are activated by this value. 

channel combination
0 no channels I
1 2 2 3 1and2 4 3 s 1and3 6 2and3 7 1, 2 and 3 

PLAY's third parameter, e, is probably the most difficult to understand, since it is the integer which determines the "shape" of the sound which the Orie produces. Once again the sound chapter should be consulted for a full explanation of this feature.

However, variable e (0-7) when set at 1 or 2 produces what are known as sound envelopes of a fixed length, whilst all other settings generate continuous sounds of various types. The example program below will hopefully clarify the effect of the different PLAY set-tings. Finally d (0-32767) sets the duration of the sound envelope. 

When using either MUSIC or SOUND at some point in the course of your program you will want to turn off the sound channels, which can be achieved by the statement PLAY 0,0,0,0. 

l REM***PLAY***
5 CLS
10 CLS:PRINT:PRJNT
20 INPLJT"ENTER NUMBER C0-7J FDR SOUND S HAPE" ;E
30 JFE<0 DR E>7THEN20
40 INPUT"ENTER A NUMBER C0-65535J FDR D URAT JON" ;O
50 PRINT"THIS IS SOUND ENVELOPE ";E;" W ITH A 11 ;O; II DURATION"
60 SOUND l,1500,0
70 PLAY l,0,E,D
80 PRJNT"PRESS ANY KEY TO STOP PLAY''
90 GETA$: GOT05

Related keywords: MUSIC, SOUND
  -->
<script>
</script>


</body>

</html>

