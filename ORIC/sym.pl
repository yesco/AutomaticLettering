# intended to figure out the optimal way of
# storing symbols for storage on 6502

# data is anecdotial data for length and
# frequences of "public" symbols in 65panda.fun
# generated by:
#   
#   
#
# these words are querky
   if (0) { }
elsif (0) {    open IN, "./run -c | grep 'L:' | cut -c5-21 |tr -s ' ' |" or die "ERROR: $_";}
elsif (0) {    open IN, "forth.lst";}
elsif (0) {    open IN, "4th-asm.lst";}
elsif (0) {    open IN, "asm.lst";}
elsif (1) {    open IN, "amsterdam.lst";}
elsif (0) {    open IN, "lisp.lst";}

$c = 0;
# sama as pascal! extra byte
sub asC {
    my ($name, $len) = @_;
    $c += $len + 1;
    $cbpw = $c / $n;
}

$hi = 0;
# set hi-bit on last char
sub asHi {
    my ($name, $len) = @_;
    $hi += $len;
    $hibpw = $hi / $n;
}

if (0) {
    for $i (0..12) {
	print $i, "\t", 2*int(($i + 2)/3), "\n";
    }
}
$c16pack = 0;
$c16fail = 0;
$c16bad = '';
# 5 bits/char 16 = 5*3 + 1 end bit!
# only have 32 chars: one for space/end
#   
#   ' ' (space/terminator)         (1)
#   abcdefghijklmnopqrstuvwxyz    (25)
#   _ $ - (=these are commeon)  max 6)
#      1: next char is uppercase
#      2: all caps
#      3: next is alternative
#         (ascii 31-63)
#
sub as16pack {
    my ($name, $len) = @_;

    my $origname = $name;
    $name = &packprefixed($name);
    my $elen = length($name);

    if ($name =~ /^[a-z_\$\-\@\%\&]*$/) {
	$c16pack += 2*int(($elen + 2)/3);
    } else {
	# penalty!
	$c16pack += 2*int(($elen + 2)/3)*2;

	$c16fail++;
	$c16bad .= " $name";
    }
    $c16bpw = $c16pack / $n;
}

$m16pack = 0;
$m16his = 0;
# 5 bits/char 16 = 5*3 + 1 end bit!
# only have 32 chars: one for space/end
#   
#   ' ' (space/terminator)         (1)
#   abcdefghijklmnopqrstuvwxyz    (25)
#   _ $ -     @ % &            (max 6)
#
# encoding of first byte
# ----------------------
# 1000 0000 = means use hibit
#    (we define an empty string illegal
#     in mix, so it must be hibit)
#    (pick x80 so it's not 00 terminating
#     and if it used hibit, not valid
#     character anyway)
# (not zero)
#  xxx xxxx = 7 bits non zero+8=15=5*3 3 chars
# 1         = the bits stop after total of 2
# 0xxx xxxx = there is another pack16...
sub mix16pack {
    my ($name, $len) = @_;

    my $origname = $name;
    my $elen = $len;
    if (/[^a-z_\-]/) {
	$name = &packprefixed($name);
	$elen = length($name);
    }
    

    my $fail = ''; my $x = 0;

    $x = 2*int(($elen + 2)/3);
    my $ox = $x;;

    if (($x < $len+1) &&
#	($name =~ /^[a-z_\$\-\@\%\&]*$/)) {
	1) {
	$m16pack += $x;
	# $len = $elen;
    } else {
	$fail = ($x < $len+1)?'HI':'hi';
	$m16his++;
	# wasted one char (=0)
	$x = 1;
	
	# revert to hibit
	$x += $len;
	$m16pack += $x;
    }

    my $d = $x - $len;

    if ($ox != $x) {
	print sprintf("\n%-16s $elen\t$ox  $fail\t- (extra)\n", $name);

    }
    print sprintf("%-16s $len\t$x  $fail\t$d (extra)\n", $origname);

    $m16bpw = $m16pack / $n;
}

sub packprefixed {
    my ($name) = @_;

    # encode other chars w prefix
    # (just using % again, but not correct)
    # (just need to make it one char more)
    $name =~ s/([\!-\@])/\%q/g;

    # if have any uppercase letter try
    # - quote each uc character w prefix
    # - or just quote the first
    #   (and then all the small letters)
    if ($name =~ /[A-Z]/) {
	# mixed :-(
	
	# encode uc w char prefix
	my $cpname = $name;
	$cpname =~ s/([A-Z])/\%$1/g;
	$cpname = lc $cpname;

	# encode uc CAPS (from first L)
	my $CAPSname = $name;
	$CAPSname =~ s/([A-Z])(.*)$/&fix($1, $2)/ge;
	$CAPSname = lc $CAPSname;

	my $cb = 2*int((length($cpname)+2)/3);
	my $Cb = 2*int((length($CAPSname)+2)/3);
	    
	print "\tPACK.c: ",length($cpname), " $cpname ", $cb, "\n";
	print "\tPACK.C: ",length($CAPSname), " $CAPSname ", $Cb,"\n";

	if (length($cpname)<length($CAPSname)) {
	    $name = $cpname;
	} else {
	    $name = $CAPSname;
	}
    }

    return $name;
}

sub fix {
    my ($u, $s) = @_;

    # add CAPS
    my $r = '%' . $u;
    $s =~ s/([a-z])/\%$1/g;

    return $r . $s;
}

# 6 bits/char 64 = (* 6 10) = 60 + 4
# only have 64 chars: one for space/end
#
#   ' ' (space/terminator)         (1)
#   a-z.z A-Z                     (50)
#   0-9	                          (10)
#   _ - \.                     (max 3)
#
#  4 bits (extra info)
#  ------
#  0    = 16pack encoding
#  1    = 64pack encoding
#  11   = continue (6 bits left!)
#         alt  - 1 inline 1 char char (a-z
#         alt  - 1 of 28 special chars + a-z
#         alt  - 1 a-zA-Z rest is hibit style
#  1000 = normal
#  1001 = _ after hibit char (lower case)
#  1010 = - after hibit char (upper case)
#  1011 = 60 bits is 12x 5-bit char  (lc)
$c64pack = 0;
$c64fail = 0;
$c64bad = '';
sub as64pack {
    my ($name, $len) = @_;
    my $c64 = 8*int(($len + 9)/10);
    $c64pack += $c64;
    my $fail = '';
    unless ($name =~ /^[a-zA-Z0-9\_\-\@\%\&]*$/) {
	$c64fail++;
	$c64bad .= " $name";
	$fail = 'FAIL';
    }
    $c64bpw = $c64pack / $n;
}

# 32 pack? same as 2x 16pack?
# I guess?  (* 6 5) = 5 chars + 2 bits


# use first bit 1:
#   0 ==> 16pack
#   1 ==> 64pack
$cstage = 0;
$cstagefail = 0;
$cstagebad = '';
sub asStaged {
    my ($name, $len) = @_;
    if ($name =~ /^[a-z_\$\-\@\%\&]*$/) {
	my $c16 = 2*int(($len + 2)/3);
	$cstage += $c16;
    } else {
	my $c64 = 8*int(($len + 9)/10);
	$cstage += $c64;
    }

    $cstagebpw = $cstage
}

# sorted prefix encoding?
# 4 bits = len from previous char
# ("effcient" search as can keep
#  track of match count???)

$n = 0;
$b = 0;
while (<IN>) {
    chop($_);
    s/^\s*//;
    s/\s*$//;
    next if /._\s*$/; # local label not store
    # grrrr
    next if /^\(.*\)\s*$/; # local label not store
    next if /^$/;


    # any chars goes!
    my $name = $_;
    my $len = length($name);

    print "\n>",$name,"< len=$len\n";


    $n++;
    $b += length($name);
    #print "$len\t$name\n";
	
    &asC($name, $len);
    &asHi($name, $len);
    &as16pack($name, $len);
    &mix16pack($name, $len);
    &as64pack($name, $len);

#    if ($name eq "THEN") {
#	print "THEN: ................\n";
#	exit;
#    }


}

print "===========================\n";
print "c\t$c\t-\t$cbpw\n";
print "hi\t$hi\t-\t$hibpw\n";
print "16pack\t$c16pack\t$c16fail\t$c16bpw\t$c16bad\n";
#print "32pack\t$c32pack\t$c32fail\t$c32bad\n";
print "64pack\t$c64pack\t$c64fail\t$c64bpw\t$c64bad\n";
print "mix16\t$m16pack\t$m16his\t$m16bpw\t$m16bad\n";
print "\n";
print "TOTAL $n words of $b chars ", $b/$n, "\n";

# conclusions

# ---------- 4th-asm.lst (combined)
$a = <<HERE
c	1158	-	4.825
hi	918	-	3.825
16pack	510	81	2.125
64pack	1944	74	8.1
mix16	936	81	3.9	

TOTAL 240 words of 918 chars 3.825

# before???
...
mix16	855	0	3.5625	

TOTAL 240 words of 918 chars 3.825

# ---------- forth.lst
c	934	-	5.07608695652174
hi	750	-	4.07608695652174
16pack	398	81	2.16304347826087
64pack	1496	74	8.1304347826087	
mix16	824	81 	4.47826086956522
                 ^NOT failures, just
		 number of times needed
		 to waste byte to escape
		 to hibit!

# ---------- asm.lst
c	224	-	4
hi	168	-	3
16pack	112	0	2	
64pack	448	0	8	
mix16	112	0	2	

TOTAL 56 words of 168 chars 3

# ---------- panda ...| ||  query words
NEW:

c	635	-	7.13483146067416
hi	546	-	6.13483146067416
16pack	226	41	2.53932584269663
64pack	744	1	8.35955056179775 mul71+3
mix16	531	41	5.96629213483146	
                 ^NOT failures but cases
		 where wasting one byte
		 to choose to use hibit
(I think this decreased when remove space?)
(or have bug?)

(- 546 531) = 16 bytes saved by mix16
              mostly because many funky words
	      (possibly better w english)

TOTAL 89 words of 546 chars 6.13483146067416

mix16	572	41	6.42696629213483	

TOTAL 89 words of 546 chars 6.13483146067416

HERE
;

